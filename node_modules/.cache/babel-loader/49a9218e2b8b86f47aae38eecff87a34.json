{"ast":null,"code":"import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\nimport * as chartConstants from '../../constants/charts';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { getFirst } from '../../util/component-types';\nimport { maxByFields, maxByFieldsStacked } from '../../util/chart-helpers';\nimport Axis from '../Axis/Axis';\nimport AxisLabel from '../AxisLabel/AxisLabel';\nimport Bars from '../Bars/Bars';\nimport ContextMenu from '../ContextMenu/ContextMenu';\nimport Legend from '../Legend/Legend';\nimport EmptyStateWrapper from '../EmptyStateWrapper/EmptyStateWrapper';\nconst cx = lucidClassNames.bind('&-BarChart');\nconst {\n  arrayOf,\n  func,\n  number,\n  object,\n  shape,\n  string,\n  array,\n  bool,\n  oneOfType,\n  oneOf\n} = PropTypes;\nconst defaultProps = {\n  height: 400,\n  width: 1000,\n  // duplicated because `statics` aren't available during getDefaultProps\n  margin: {\n    top: 10,\n    right: 20,\n    bottom: 50,\n    left: 80\n  },\n  palette: chartConstants.PALETTE_7,\n  hasToolTips: true,\n  hasLegend: false,\n  renderTooltipBody: null,\n  xAxisField: 'x',\n  xAxisTickCount: null,\n  xAxisTitle: null,\n  xAxisTitleColor: '#000',\n  xAxisFormatter: _.identity,\n  xAxisTextOrientation: 'horizontal',\n  yAxisFields: ['y'],\n  yAxisTickCount: null,\n  yAxisIsStacked: false,\n  yAxisMin: 0,\n  yAxisTitle: null,\n  yAxisTitleColor: '#000',\n  yAxisTooltipFormatter: (yField, yValueFormatted) => `${yField}: ${yValueFormatted}`,\n  yAxisTextOrientation: 'horizontal'\n};\nexport const BarChart = props => {\n  const {\n    className,\n    height,\n    width,\n    margin: marginOriginal,\n    data,\n    legend,\n    isLoading,\n    hasToolTips,\n    hasLegend,\n    palette,\n    colorMap,\n    renderTooltipBody,\n    xAxisField,\n    xAxisFormatter,\n    xAxisTitle,\n    xAxisTitleColor,\n    xAxisTickCount,\n    xAxisTextOrientation,\n    yAxisFields,\n    yAxisFormatter,\n    yAxisTitle,\n    yAxisTitleColor,\n    yAxisIsStacked,\n    yAxisTickCount,\n    yAxisMin,\n    yAxisTooltipFormatter,\n    yAxisTooltipDataFormatter,\n    yAxisMax = yAxisIsStacked ? maxByFieldsStacked(data, yAxisFields) : maxByFields(data, yAxisFields),\n    yAxisTextOrientation,\n    ...passThroughs\n  } = props;\n  const margin = {\n    ...BarChart.MARGIN,\n    ...marginOriginal\n  };\n  const svgClasses = cx(className, '&');\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n  // `paddingInner` determines the space between the bars or groups of bars\n  const paddingInner = yAxisFields.length > 1 ? BarChart.PADDING_GROUPED_OR_STACKED : BarChart.PADDING;\n  const xScale = d3Scale.scaleBand().domain(_.map(data, xAxisField)).range([0, innerWidth]).paddingInner(paddingInner).paddingOuter(0.5);\n  const yScale = d3Scale.scaleLinear().domain([yAxisMin, yAxisMax]).range([innerHeight, 0]);\n  // @ts-ignore\n  const xAxisFinalFormatter = xAxisFormatter || xScale.tickFormat();\n  const yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();\n  const yFinalFormatter = yAxisTooltipDataFormatter ? yAxisTooltipDataFormatter : yAxisFinalFormatter;\n  if (_.isEmpty(data) || width < 1 || height < 1 || isLoading) {\n    const emptyStateWrapper = getFirst(props, BarChart.EmptyStateWrapper) || React.createElement(BarChart.EmptyStateWrapper, {\n      Title: 'You have no data.'\n    });\n    return React.createElement(EmptyStateWrapper, {\n      ...emptyStateWrapper.props,\n      isEmpty: _.isEmpty(data),\n      isLoading: isLoading\n    }, emptyStateWrapper.props.children, React.createElement(\"svg\", {\n      ...passThroughs,\n      className: svgClasses,\n      width: width,\n      height: height\n    }, React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${innerHeight + margin.top})`\n    }, React.createElement(Axis, {\n      orient: 'bottom',\n      scale: xScale,\n      tickCount: xAxisTickCount\n    })), React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top})`\n    }, React.createElement(Axis, {\n      orient: 'left',\n      scale: yScale,\n      tickFormat: yFinalFormatter,\n      tickCount: yAxisTickCount\n    }))));\n  }\n  return React.createElement(\"svg\", {\n    ...passThroughs,\n    className: svgClasses,\n    width: width,\n    height: height\n  }, React.createElement(\"g\", {\n    transform: `translate(${margin.left}, ${innerHeight + margin.top})`\n  }, React.createElement(Axis, {\n    orient: 'bottom',\n    // @ts-ignore\n    scale: xScale,\n    outerTickSize: 0,\n    tickFormat: xAxisFinalFormatter,\n    tickCount: xAxisTickCount,\n    textOrientation: xAxisTextOrientation\n  }), hasLegend ? React.createElement(ContextMenu, {\n    direction: 'down',\n    alignment: 'center',\n    directonOffset: (margin.bottom / 2 + Legend.HEIGHT / 2) * -1 /* should center the legend in the bottom margin */\n  }, React.createElement(ContextMenu.Target, {\n    elementType: 'g'\n  }, React.createElement(\"rect\", {\n    className: cx('&-invisible'),\n    width: innerWidth,\n    height: margin.bottom\n  })), React.createElement(ContextMenu.FlyOut, {\n    className: cx('&-legend-container')\n  }, React.createElement(Legend, {\n    orient: 'horizontal'\n  }, _.map(yAxisFields, (field, index) => React.createElement(Legend.Item, {\n    key: index,\n    hasPoint: true,\n    hasLine: false,\n    color: _.get(colorMap, field, palette[index % palette.length]),\n    pointKind: 1\n  }, _.get(legend, field, field)))))) : null), xAxisTitle ? React.createElement(\"g\", {\n    transform: `translate(${margin.left}, ${margin.top + innerHeight})`\n  }, React.createElement(AxisLabel, {\n    orient: 'bottom',\n    width: innerWidth,\n    height: margin.bottom,\n    label: xAxisTitle,\n    color: _.isString(xAxisTitleColor) ? xAxisTitleColor : palette[xAxisTitleColor % palette.length]\n  })) : null, React.createElement(\"g\", {\n    transform: `translate(${margin.left}, ${margin.top})`\n  }, React.createElement(Axis, {\n    orient: 'left',\n    scale: yScale,\n    tickFormat: yAxisFinalFormatter,\n    tickCount: yAxisTickCount,\n    textOrientation: yAxisTextOrientation\n  })), yAxisTitle ? React.createElement(\"g\", {\n    transform: `translate(0, ${margin.top})`\n  }, React.createElement(AxisLabel, {\n    orient: 'left',\n    width: margin.left,\n    height: innerHeight,\n    label: yAxisTitle,\n    color: _.isString(yAxisTitleColor) ? yAxisTitleColor : palette[yAxisTitleColor % palette.length]\n  })) : null, React.createElement(\"g\", {\n    transform: `translate(${margin.left}, ${margin.top})`\n  }, React.createElement(Bars, {\n    xField: xAxisField,\n    xScale: xScale,\n    xFormatter: xAxisFormatter,\n    yFields: yAxisFields,\n    yScale: yScale,\n    // @ts-ignore\n    yFormatter: yFinalFormatter,\n    yStackedMax: yAxisMax,\n    data: data,\n    isStacked: yAxisIsStacked,\n    yTooltipFormatter: yAxisTooltipFormatter,\n    hasToolTips: hasToolTips,\n    legend: legend,\n    palette: palette,\n    colorMap: colorMap,\n    renderTooltipBody: renderTooltipBody\n  })));\n};\nBarChart.displayName = 'BarChart';\nBarChart.propTypes = {\n  /**\n      Appended to the component-specific class names set on the root element.\n  */\n  className: string,\n  /**\n      Height of the chart.\n  */\n  height: number,\n  /**\n      Width of the chart.\n  */\n  width: number,\n  /**\n      An object defining the margins of the chart. These margins typically\n      contain the axis and labels.\n  */\n  margin: shape({\n    top: number,\n    right: number,\n    bottom: number,\n    left: number\n  }),\n  /**\n      Data for the chart. E.g.\n           [\n              { x: 'Monday'    , y: 1 } ,\n              { x: 'Tuesday'   , y: 2 } ,\n              { x: 'Wednesday' , y: 3 } ,\n              { x: 'Thursday'  , y: 2 } ,\n              { x: 'Friday'    , y: 5 } ,\n          ]\n  */\n  data: arrayOf(object),\n  /**\n      An object with human readable names for fields that will be used for legends and tooltips. E.g:\n           {\n              x: 'Date',\n              y: 'Impressions',\n          }\n  */\n  legend: object,\n  /**\n      Controls the visibility of the \\`LoadingMessage\\`.\n  */\n  isLoading: bool,\n  /**\n      Show tool tips on hover.\n  */\n  hasToolTips: bool,\n  /**\n      Show a legend at the bottom of the chart.\n  */\n  hasLegend: bool,\n  /**\n      Takes one of the palettes exported from \\`lucid.chartConstants\\`. Available palettes:\n       - \\`PALETTE_7\\` (default)\n      - \\`PALETTE_30\\`\n      - \\`PALETTE_MONOCHROME_0_5\\`\n      - \\`PALETTE_MONOCHROME_1_5\\`\n      - \\`PALETTE_MONOCHROME_2_5\\`\n      - \\`PALETTE_MONOCHROME_3_5\\`\n      - \\`PALETTE_MONOCHROME_4_5\\`\n      - \\`PALETTE_MONOCHROME_5_5\\`\n      - \\`PALETTE_MONOCHROME_6_5\\`\n  */\n  palette: arrayOf(string),\n  /**\n      You can pass in an object if you want to map x values to \\`lucid.chartConstants\\` or custom colors:\n           {\n              'imps': COLOR_0,\n              'rev': COLOR_3,\n              'clicks': '#abc123',\n          }\n  */\n  colorMap: object,\n  /**\n      The field we should look up your x data by. Your actual x data must be\n      strings.\n  */\n  xAxisField: string,\n  /**\n      There are some cases where you need to only show a \"sampling\" of ticks on\n      the x axis. This number will control that.\n  */\n  xAxisTickCount: number,\n  /**\n      An optional function used to format your x axis data. If you don't\n      provide anything, we'll use an identity function.\n  */\n  xAxisFormatter: func,\n  /**\n      Set a title for the x axis.\n  */\n  xAxisTitle: string,\n  /**\n      Set a color for the x axis title. Use the color constants exported off \\`lucid.chartConstants\\`. E.g.:\n       - \\`COLOR_0\\`\n      - \\`COLOR_GOOD\\`\n      - \\`'#123abc'\\` // custom color hex\n       \\`number\\` is supported only for backwards compatability.\n  */\n  xAxisTitleColor: oneOfType([number, string]),\n  /**\n      An array of your y axis fields. Typically this will just be a single item\n      unless you need to display grouped or stacked bars. The order of the\n      array determines the series order in the chart.\n  */\n  yAxisFields: array,\n  /**\n      The minimum number the y axis should display. Typically this should be be\n      \\`0\\`.\n  */\n  yAxisMin: number,\n  /**\n      The maximum number the y axis should display. This should almost always\n      be the largest number from your dataset.\n  */\n  yAxisMax: number,\n  /**\n      An optional function used to format your y axis data. If you don't\n      provide anything, we use the default D3 number formatter.\n  */\n  yAxisFormatter: func,\n  /**\n      Stack the y axis data instead of showing it as groups. This is only\n      useful if you have multiple \\`yAxisFields\\`. Stacking will cause the\n      chart to be aggregated by sum.\n  */\n  yAxisIsStacked: bool,\n  /**\n      There are some cases where you need to only show a \"sampling\" of ticks on\n      the y axis. This number will control that.\n  */\n  yAxisTickCount: number,\n  /**\n      Set a title for the y axis.\n  */\n  yAxisTitle: string,\n  /**\n      Set a color for the y axis title. Use the color constants exported off \\`lucid.chartConstants\\`. E.g.:\n       - \\`COLOR_0\\`\n      - \\`COLOR_GOOD\\`\n      - \\`'#123abc'\\` // custom color hex\n       \\`number\\` is supported only for backwards compatability.\n  */\n  yAxisTitleColor: oneOfType([number, string]),\n  /**\n      An optional function used to format your y axis titles and data in the\n      tooltip legends. The first value is the name of your y field, the second value\n      is your post-formatted y value, and the third value is your non-formatted\n      y-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n  */\n  yAxisTooltipFormatter: func,\n  /**\n      An optional function used to format y-values in the tooltip legends.\n  */\n  yAxisTooltipDataFormatter: func,\n  /**\n      An optional function used to format the entire tooltip body. The only arg is\n      the associated data point. This formatter will over-ride yAxisTooltipFormatter\n      and yAxisTooltipDataFormatter. Signature:\n      \\`dataPoint => {}\\`\n  */\n  renderTooltipBody: func,\n  /**\n      Determines the orientation of the tick text. This may override what the orient prop\n      tries to determine.\n  */\n  xAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),\n  /**\n      Determines the orientation of the tick text. This may override what the orient prop\n      tries to determine.\n  */\n  yAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal'])\n};\nBarChart.defaultProps = defaultProps;\nBarChart.peek = {\n  description: `A \\`Bar Chart\\` is great for showing data that fits neatly into \"buckets\". The x axis data must be strings, and the y axis data must be numeric.`,\n  categories: ['visualizations', 'charts'],\n  madeFrom: ['ContextMenu', 'ToolTip']\n};\nBarChart.EmptyStateWrapper = EmptyStateWrapper;\nBarChart.PADDING = 0.05;\nBarChart.PADDING_GROUPED_OR_STACKED = 0.3;\nBarChart.MARGIN = {\n  top: 10,\n  right: 20,\n  bottom: 50,\n  left: 80\n};\nexport default BarChart;","map":{"version":3,"mappings":"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","names":["_","React","PropTypes","d3Scale","chartConstants","lucidClassNames","getFirst","maxByFields","maxByFieldsStacked","Axis","AxisLabel","Bars","ContextMenu","Legend","EmptyStateWrapper","cx","bind","arrayOf","func","number","object","shape","string","array","bool","oneOfType","oneOf","defaultProps","height","width","margin","top","right","bottom","left","palette","PALETTE_7","hasToolTips","hasLegend","renderTooltipBody","xAxisField","xAxisTickCount","xAxisTitle","xAxisTitleColor","xAxisFormatter","identity","xAxisTextOrientation","yAxisFields","yAxisTickCount","yAxisIsStacked","yAxisMin","yAxisTitle","yAxisTitleColor","yAxisTooltipFormatter","yField","yValueFormatted","yAxisTextOrientation","BarChart","props","className","marginOriginal","data","legend","isLoading","colorMap","yAxisFormatter","yAxisTooltipDataFormatter","yAxisMax","passThroughs","MARGIN","svgClasses","innerWidth","innerHeight","paddingInner","length","PADDING_GROUPED_OR_STACKED","PADDING","xScale","scaleBand","domain","map","range","paddingOuter","yScale","scaleLinear","xAxisFinalFormatter","tickFormat","yAxisFinalFormatter","yFinalFormatter","isEmpty","emptyStateWrapper","Title","children","transform","orient","scale","tickCount","outerTickSize","textOrientation","direction","alignment","directonOffset","HEIGHT","Target","elementType","FlyOut","field","index","Item","key","hasPoint","hasLine","color","get","pointKind","label","isString","xField","xFormatter","yFields","yFormatter","yStackedMax","isStacked","yTooltipFormatter","displayName","propTypes","peek","description","categories","madeFrom"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/BarChart/BarChart.tsx"],"sourcesContent":["import _ from 'lodash';\nimport React, { Key } from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\nimport * as chartConstants from '../../constants/charts';\n\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { getFirst, StandardProps } from '../../util/component-types';\nimport {\n\tCollection,\n\tmaxByFields,\n\tmaxByFieldsStacked,\n} from '../../util/chart-helpers';\nimport Axis from '../Axis/Axis';\nimport AxisLabel from '../AxisLabel/AxisLabel';\nimport Bars from '../Bars/Bars';\nimport ContextMenu from '../ContextMenu/ContextMenu';\nimport Legend from '../Legend/Legend';\nimport EmptyStateWrapper from '../EmptyStateWrapper/EmptyStateWrapper';\n\nconst cx = lucidClassNames.bind('&-BarChart');\n\nconst {\n\tarrayOf,\n\tfunc,\n\tnumber,\n\tobject,\n\tshape,\n\tstring,\n\tarray,\n\tbool,\n\toneOfType,\n\toneOf,\n} = PropTypes;\n\nexport interface IBarChartProps\n\textends StandardProps,\n\t\tReact.DetailedHTMLProps<\n\t\t\tReact.HTMLAttributes<HTMLDivElement>,\n\t\t\tHTMLDivElement\n\t\t> {\n\t/** Child components of LineChart */\n\tEmptyStateWrapper?: React.ReactNode;\n\n\t/**\n\t * Height of the chart.\n\t */\n\theight: number;\n\n\t/** Width of the chart. */\n\twidth: number;\n\n\t/** An object defining the margins of the chart. These margins typically\n\t * contain the axis and labels. */\n\tmargin: {\n\t\ttop: number;\n\t\tright: number;\n\t\tbottom: number;\n\t\tleft: number;\n\t};\n\n\t/** Data for the chart. E.g.\n\t * [\n\t * \t{ x: 'Monday'    , y: 1 } ,\n\t * \t{ x: 'Tuesday'   , y: 2 } ,\n\t * \t{ x: 'Wednesday' , y: 3 } ,\n\t * \t{ x: 'Thursday'  , y: 2 } ,\n\t * \t{ x: 'Friday'    , y: 5 } ,\n\t * ]\n\t */\n\tdata: Collection;\n\n\t/** An object with human readable names for fields that will be used for legends and tooltips. E.g:\n\t * {\n\t * \tx: 'Date',\n\t * \ty: 'Impressions',\n\t * }\n\t */\n\tlegend?: {};\n\n\t/** Controls the visibility of the \\`LoadingMessage\\`. */\n\tisLoading?: boolean;\n\n\t/** Show tool tips on hover. */\n\thasToolTips: boolean;\n\n\t/** Show a legend at the bottom of the chart. */\n\thasLegend: boolean;\n\n\t/** Takes one of the palettes exported from \\`lucid.chartConstants\\`. Available palettes:\n\t * - \\`PALETTE_7\\` (default)\n\t * - \\`PALETTE_30\\`\n\t * - \\`PALETTE_MONOCHROME_0_5\\`\n\t * - \\`PALETTE_MONOCHROME_1_5\\`\n\t * - \\`PALETTE_MONOCHROME_2_5\\`\n\t * - \\`PALETTE_MONOCHROME_3_5\\`\n\t * - \\`PALETTE_MONOCHROME_4_5\\`\n\t * - \\`PALETTE_MONOCHROME_5_5\\`\n\t * - \\`PALETTE_MONOCHROME_6_5\\`\n\t */\n\tpalette: string[];\n\n\t/** You can pass in an object if you want to map x values to \\`lucid.chartConstants\\` or custom colors:\n\t * {\n\t * \t'imps': COLOR_0,\n\t * \t'rev': COLOR_3,\n\t * \t'clicks': '#abc123',\n\t * }\n\t */\n\tcolorMap?: {};\n\n\t/** The field we should look up your x data by. Your actual x data must be\n\t * strings.\n\t */\n\txAxisField: string;\n\n\t/** There are some cases where you need to only show a \"sampling\" of ticks on\n\t * the x axis. This number will control that.\n\t */\n\txAxisTickCount: number | null;\n\n\t/** An optional function used to format your x axis data. If you don't\n\t * provide anything, we'll use an identity function.\n\t */\n\txAxisFormatter: (d: number | Date) => string;\n\n\t/** Set a title for the x axis. */\n\txAxisTitle: string | null;\n\n\t/** Set a color for the x axis title. Use the color constants exported off \\`lucid.chartConstants\\`. E.g.:\n\t * \t- \\`COLOR_0\\`\n\t * \t- \\`COLOR_GOOD\\`\n\t * \t- \\`'#123abc'\\`  * custom color hex\n\t *  \\`number\\` is supported only for backwards compatability.\n\t */\n\txAxisTitleColor: string | number;\n\n\t/** An array of your y axis fields. Typically this will just be a single item\n\t * unless you need to display grouped or stacked bars. The order of the\n\t * array determines the series order in the chart.\n\t */\n\tyAxisFields: string[];\n\n\t/** The minimum number the y axis should display. Typically this should be be\n\t * \\`0\\`.\n\t */\n\tyAxisMin: number;\n\n\t/** The maximum number the y axis should display. This should almost always\n\t * be the largest number from your dataset.\n\t */\n\tyAxisMax?: number;\n\n\t/** An optional function used to format your y axis data. If you don't\n\t * provide anything, we use the default D3 number formatter.\n\t */\n\tyAxisFormatter?: (v: unknown) => string;\n\n\t/** Stack the y axis data instead of showing it as groups. This is only\n\t * useful if you have multiple \\`yAxisFields\\`. Stacking will cause the\n\t * chart to be aggregated by sum.\n\t */\n\tyAxisIsStacked: boolean;\n\n\t/** There are some cases where you need to only show a \"sampling\" of ticks on\n\t * the y axis. This number will control that.\n\t */\n\tyAxisTickCount: number | null;\n\n\t/** Set a title for the y axis.\n\t */\n\tyAxisTitle: string | null;\n\n\t/** Set a color for the y axis title. Use the color constants exported off \\`lucid.chartConstants\\`. E.g.:\n\t * - \\`COLOR_0\\`\n\t * - \\`COLOR_GOOD\\`\n\t * - \\`'#123abc'\\`  * custom color hex\n\t * \\`number\\` is supported only for backwards compatability.\n\t */\n\tyAxisTitleColor: number | string;\n\n\t/** An optional function used to format your y axis titles and data in the\n\t * tooltip legends. The first value is the name of your y field, the second value\n\t * is your post-formatted y value, and the third value is your non-formatted\n\t * y-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n\t */\n\tyAxisTooltipFormatter: (\n\t\tyField: string,\n\t\tyValueFormatted: Key,\n\t\tyValue: number\n\t) => Key;\n\n\t/** An optional function used to format y-values in the tooltip legends. */\n\tyAxisTooltipDataFormatter?: (d: number | Date) => string;\n\n\t/** An optional function used to format the entire tooltip body. The only arg is\n\t * the associated data point. This formatter will over-ride yAxisTooltipFormatter\n\t * and yAxisTooltipDataFormatter. Signature:\n\t * \\`dataPoint => {}\\`\n\t */\n\trenderTooltipBody: (dataPoint: string | number | object) => {};\n\n\t/** Determines the orientation of the tick text. This may override what the orient prop\n\t * tries to determine.\n\t */\n\txAxisTextOrientation: 'vertical' | 'horizontal' | 'diagonal';\n\n\t/** Determines the orientation of the tick text. This may override what the orient prop\n\t * tries to determine.\n\t */\n\tyAxisTextOrientation: 'vertical' | 'horizontal' | 'diagonal';\n}\n\nconst defaultProps = {\n\theight: 400,\n\twidth: 1000,\n\t// duplicated because `statics` aren't available during getDefaultProps\n\tmargin: {\n\t\ttop: 10,\n\t\tright: 20,\n\t\tbottom: 50,\n\t\tleft: 80,\n\t},\n\tpalette: chartConstants.PALETTE_7,\n\thasToolTips: true,\n\thasLegend: false,\n\n\trenderTooltipBody: null,\n\n\txAxisField: 'x',\n\txAxisTickCount: null,\n\txAxisTitle: null,\n\txAxisTitleColor: '#000',\n\txAxisFormatter: _.identity,\n\txAxisTextOrientation: 'horizontal',\n\n\tyAxisFields: ['y'],\n\tyAxisTickCount: null,\n\tyAxisIsStacked: false,\n\tyAxisMin: 0,\n\tyAxisTitle: null,\n\tyAxisTitleColor: '#000',\n\tyAxisTooltipFormatter: (yField: unknown, yValueFormatted: unknown) =>\n\t\t`${yField}: ${yValueFormatted}`,\n\tyAxisTextOrientation: 'horizontal',\n};\n\nexport const BarChart = (props: IBarChartProps): React.ReactElement => {\n\tconst {\n\t\tclassName,\n\t\theight,\n\t\twidth,\n\t\tmargin: marginOriginal,\n\t\tdata,\n\t\tlegend,\n\t\tisLoading,\n\t\thasToolTips,\n\t\thasLegend,\n\t\tpalette,\n\t\tcolorMap,\n\t\trenderTooltipBody,\n\t\txAxisField,\n\t\txAxisFormatter,\n\t\txAxisTitle,\n\t\txAxisTitleColor,\n\t\txAxisTickCount,\n\t\txAxisTextOrientation,\n\t\tyAxisFields,\n\t\tyAxisFormatter,\n\t\tyAxisTitle,\n\t\tyAxisTitleColor,\n\t\tyAxisIsStacked,\n\t\tyAxisTickCount,\n\t\tyAxisMin,\n\t\tyAxisTooltipFormatter,\n\t\tyAxisTooltipDataFormatter,\n\t\tyAxisMax = yAxisIsStacked\n\t\t\t? maxByFieldsStacked(data, yAxisFields)\n\t\t\t: maxByFields(data, yAxisFields),\n\t\tyAxisTextOrientation,\n\t\t...passThroughs\n\t} = props;\n\n\tconst margin = {\n\t\t...BarChart.MARGIN,\n\t\t...marginOriginal,\n\t};\n\n\tconst svgClasses = cx(className, '&');\n\tconst innerWidth = width - margin.left - margin.right;\n\tconst innerHeight = height - margin.top - margin.bottom;\n\n\t// `paddingInner` determines the space between the bars or groups of bars\n\tconst paddingInner =\n\t\tyAxisFields.length > 1\n\t\t\t? BarChart.PADDING_GROUPED_OR_STACKED\n\t\t\t: BarChart.PADDING;\n\n\tconst xScale = d3Scale\n\t\t.scaleBand()\n\t\t.domain(_.map(data, xAxisField))\n\t\t.range([0, innerWidth])\n\t\t.paddingInner(paddingInner)\n\t\t.paddingOuter(0.5);\n\n\tconst yScale = d3Scale\n\t\t.scaleLinear()\n\t\t.domain([yAxisMin, yAxisMax as any])\n\t\t.range([innerHeight, 0]);\n\n\t// @ts-ignore\n\tconst xAxisFinalFormatter = xAxisFormatter || xScale.tickFormat();\n\n\tconst yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();\n\n\tconst yFinalFormatter = yAxisTooltipDataFormatter\n\t\t? yAxisTooltipDataFormatter\n\t\t: yAxisFinalFormatter;\n\n\tif (_.isEmpty(data) || width < 1 || height < 1 || isLoading) {\n\t\tconst emptyStateWrapper: any = getFirst(\n\t\t\tprops,\n\t\t\tBarChart.EmptyStateWrapper\n\t\t) || <BarChart.EmptyStateWrapper Title='You have no data.' />;\n\n\t\treturn (\n\t\t\t<EmptyStateWrapper\n\t\t\t\t{...emptyStateWrapper.props}\n\t\t\t\tisEmpty={_.isEmpty(data)}\n\t\t\t\tisLoading={isLoading}\n\t\t\t>\n\t\t\t\t{emptyStateWrapper.props.children}\n\t\t\t\t<svg\n\t\t\t\t\t{...(passThroughs as any)}\n\t\t\t\t\tclassName={svgClasses}\n\t\t\t\t\twidth={width}\n\t\t\t\t\theight={height}\n\t\t\t\t>\n\t\t\t\t\t{/* x axis */}\n\t\t\t\t\t<g\n\t\t\t\t\t\ttransform={`translate(${margin.left}, ${innerHeight + margin.top})`}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Axis\n\t\t\t\t\t\t\torient='bottom'\n\t\t\t\t\t\t\tscale={xScale as any}\n\t\t\t\t\t\t\ttickCount={xAxisTickCount}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\n\t\t\t\t\t{/* y axis */}\n\t\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t\t<Axis\n\t\t\t\t\t\t\torient='left'\n\t\t\t\t\t\t\tscale={yScale}\n\t\t\t\t\t\t\ttickFormat={yFinalFormatter}\n\t\t\t\t\t\t\ttickCount={yAxisTickCount}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t</svg>\n\t\t\t</EmptyStateWrapper>\n\t\t);\n\t}\n\n\treturn (\n\t\t<svg\n\t\t\t{...(passThroughs as any)}\n\t\t\tclassName={svgClasses}\n\t\t\twidth={width}\n\t\t\theight={height}\n\t\t>\n\t\t\t{/* x axis */}\n\t\t\t<g transform={`translate(${margin.left}, ${innerHeight + margin.top})`}>\n\t\t\t\t<Axis\n\t\t\t\t\torient='bottom'\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tscale={xScale}\n\t\t\t\t\touterTickSize={0}\n\t\t\t\t\ttickFormat={xAxisFinalFormatter}\n\t\t\t\t\ttickCount={xAxisTickCount}\n\t\t\t\t\ttextOrientation={xAxisTextOrientation}\n\t\t\t\t/>\n\n\t\t\t\t{hasLegend ? (\n\t\t\t\t\t<ContextMenu\n\t\t\t\t\t\tdirection='down'\n\t\t\t\t\t\talignment='center'\n\t\t\t\t\t\tdirectonOffset={\n\t\t\t\t\t\t\t(margin.bottom / 2 + Legend.HEIGHT / 2) *\n\t\t\t\t\t\t\t-1 /* should center the legend in the bottom margin */\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\t\t\t\t<ContextMenu.Target elementType='g'>\n\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\tclassName={cx('&-invisible')}\n\t\t\t\t\t\t\t\twidth={innerWidth}\n\t\t\t\t\t\t\t\theight={margin.bottom}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</ContextMenu.Target>\n\t\t\t\t\t\t<ContextMenu.FlyOut className={cx('&-legend-container')}>\n\t\t\t\t\t\t\t<Legend orient='horizontal'>\n\t\t\t\t\t\t\t\t{_.map(yAxisFields, (field, index) => (\n\t\t\t\t\t\t\t\t\t<Legend.Item\n\t\t\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\t\t\thasPoint={true}\n\t\t\t\t\t\t\t\t\t\thasLine={false}\n\t\t\t\t\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t\t\t\t\t\tpalette[index % palette.length]\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\tpointKind={1}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{_.get(legend, field, field)}\n\t\t\t\t\t\t\t\t\t</Legend.Item>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</Legend>\n\t\t\t\t\t\t</ContextMenu.FlyOut>\n\t\t\t\t\t</ContextMenu>\n\t\t\t\t) : null}\n\t\t\t</g>\n\n\t\t\t{/* x axis title */}\n\t\t\t{xAxisTitle ? (\n\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top + innerHeight})`}>\n\t\t\t\t\t<AxisLabel\n\t\t\t\t\t\torient='bottom'\n\t\t\t\t\t\twidth={innerWidth}\n\t\t\t\t\t\theight={margin.bottom}\n\t\t\t\t\t\tlabel={xAxisTitle}\n\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t_.isString(xAxisTitleColor)\n\t\t\t\t\t\t\t\t? xAxisTitleColor\n\t\t\t\t\t\t\t\t: palette[xAxisTitleColor % palette.length]\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\t\t\t) : null}\n\n\t\t\t{/* y axis */}\n\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t<Axis\n\t\t\t\t\torient='left'\n\t\t\t\t\tscale={yScale}\n\t\t\t\t\ttickFormat={yAxisFinalFormatter}\n\t\t\t\t\ttickCount={yAxisTickCount}\n\t\t\t\t\ttextOrientation={yAxisTextOrientation}\n\t\t\t\t/>\n\t\t\t</g>\n\n\t\t\t{/* y axis title */}\n\t\t\t{yAxisTitle ? (\n\t\t\t\t<g transform={`translate(0, ${margin.top})`}>\n\t\t\t\t\t<AxisLabel\n\t\t\t\t\t\torient='left'\n\t\t\t\t\t\twidth={margin.left}\n\t\t\t\t\t\theight={innerHeight}\n\t\t\t\t\t\tlabel={yAxisTitle}\n\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t_.isString(yAxisTitleColor)\n\t\t\t\t\t\t\t\t? yAxisTitleColor\n\t\t\t\t\t\t\t\t: palette[yAxisTitleColor % palette.length]\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\t\t\t) : null}\n\n\t\t\t{/* bars */}\n\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t<Bars\n\t\t\t\t\txField={xAxisField}\n\t\t\t\t\txScale={xScale}\n\t\t\t\t\txFormatter={xAxisFormatter}\n\t\t\t\t\tyFields={yAxisFields}\n\t\t\t\t\tyScale={yScale}\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tyFormatter={yFinalFormatter}\n\t\t\t\t\tyStackedMax={yAxisMax as any}\n\t\t\t\t\tdata={data}\n\t\t\t\t\tisStacked={yAxisIsStacked}\n\t\t\t\t\tyTooltipFormatter={yAxisTooltipFormatter}\n\t\t\t\t\thasToolTips={hasToolTips}\n\t\t\t\t\tlegend={legend}\n\t\t\t\t\tpalette={palette}\n\t\t\t\t\tcolorMap={colorMap}\n\t\t\t\t\trenderTooltipBody={renderTooltipBody}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t</svg>\n\t);\n};\n\nBarChart.displayName = 'BarChart';\n\nBarChart.propTypes = {\n\t/**\n\t\tAppended to the component-specific class names set on the root element.\n\t*/\n\tclassName: string,\n\n\t/**\n\t\tHeight of the chart.\n\t*/\n\theight: number,\n\n\t/**\n\t\tWidth of the chart.\n\t*/\n\twidth: number,\n\n\t/**\n\t\tAn object defining the margins of the chart. These margins typically\n\t\tcontain the axis and labels.\n\t*/\n\tmargin: shape({\n\t\ttop: number,\n\t\tright: number,\n\t\tbottom: number,\n\t\tleft: number,\n\t}),\n\n\t/**\n\t\tData for the chart. E.g.\n\n\t\t\t[\n\t\t\t\t{ x: 'Monday'    , y: 1 } ,\n\t\t\t\t{ x: 'Tuesday'   , y: 2 } ,\n\t\t\t\t{ x: 'Wednesday' , y: 3 } ,\n\t\t\t\t{ x: 'Thursday'  , y: 2 } ,\n\t\t\t\t{ x: 'Friday'    , y: 5 } ,\n\t\t\t]\n\t*/\n\tdata: arrayOf(object),\n\n\t/**\n\t\tAn object with human readable names for fields that will be used for legends and tooltips. E.g:\n\n\t\t\t{\n\t\t\t\tx: 'Date',\n\t\t\t\ty: 'Impressions',\n\t\t\t}\n\t*/\n\tlegend: object,\n\n\t/**\n\t\tControls the visibility of the \\`LoadingMessage\\`.\n\t*/\n\tisLoading: bool,\n\n\t/**\n\t\tShow tool tips on hover.\n\t*/\n\thasToolTips: bool,\n\n\t/**\n\t\tShow a legend at the bottom of the chart.\n\t*/\n\thasLegend: bool,\n\n\t/**\n\t\tTakes one of the palettes exported from \\`lucid.chartConstants\\`. Available palettes:\n\n\t\t- \\`PALETTE_7\\` (default)\n\t\t- \\`PALETTE_30\\`\n\t\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t\t- \\`PALETTE_MONOCHROME_6_5\\`\n\t*/\n\tpalette: arrayOf(string),\n\n\t/**\n\t\tYou can pass in an object if you want to map x values to \\`lucid.chartConstants\\` or custom colors:\n\n\t\t\t{\n\t\t\t\t'imps': COLOR_0,\n\t\t\t\t'rev': COLOR_3,\n\t\t\t\t'clicks': '#abc123',\n\t\t\t}\n\t*/\n\tcolorMap: object,\n\n\t/**\n\t\tThe field we should look up your x data by. Your actual x data must be\n\t\tstrings.\n\t*/\n\txAxisField: string,\n\n\t/**\n\t\tThere are some cases where you need to only show a \"sampling\" of ticks on\n\t\tthe x axis. This number will control that.\n\t*/\n\txAxisTickCount: number,\n\n\t/**\n\t\tAn optional function used to format your x axis data. If you don't\n\t\tprovide anything, we'll use an identity function.\n\t*/\n\txAxisFormatter: func,\n\n\t/**\n\t\tSet a title for the x axis.\n\t*/\n\txAxisTitle: string,\n\n\t/**\n\t\tSet a color for the x axis title. Use the color constants exported off \\`lucid.chartConstants\\`. E.g.:\n\n\t\t- \\`COLOR_0\\`\n\t\t- \\`COLOR_GOOD\\`\n\t\t- \\`'#123abc'\\` // custom color hex\n\n\t\t\\`number\\` is supported only for backwards compatability.\n\t*/\n\txAxisTitleColor: oneOfType([number, string]),\n\n\t/**\n\t\tAn array of your y axis fields. Typically this will just be a single item\n\t\tunless you need to display grouped or stacked bars. The order of the\n\t\tarray determines the series order in the chart.\n\t*/\n\tyAxisFields: array,\n\n\t/**\n\t\tThe minimum number the y axis should display. Typically this should be be\n\t\t\\`0\\`.\n\t*/\n\tyAxisMin: number,\n\n\t/**\n\t\tThe maximum number the y axis should display. This should almost always\n\t\tbe the largest number from your dataset.\n\t*/\n\tyAxisMax: number,\n\n\t/**\n\t\tAn optional function used to format your y axis data. If you don't\n\t\tprovide anything, we use the default D3 number formatter.\n\t*/\n\tyAxisFormatter: func,\n\n\t/**\n\t\tStack the y axis data instead of showing it as groups. This is only\n\t\tuseful if you have multiple \\`yAxisFields\\`. Stacking will cause the\n\t\tchart to be aggregated by sum.\n\t*/\n\tyAxisIsStacked: bool,\n\n\t/**\n\t\tThere are some cases where you need to only show a \"sampling\" of ticks on\n\t\tthe y axis. This number will control that.\n\t*/\n\tyAxisTickCount: number,\n\n\t/**\n\t\tSet a title for the y axis.\n\t*/\n\tyAxisTitle: string,\n\n\t/**\n\t\tSet a color for the y axis title. Use the color constants exported off \\`lucid.chartConstants\\`. E.g.:\n\n\t\t- \\`COLOR_0\\`\n\t\t- \\`COLOR_GOOD\\`\n\t\t- \\`'#123abc'\\` // custom color hex\n\n\t\t\\`number\\` is supported only for backwards compatability.\n\t*/\n\tyAxisTitleColor: oneOfType([number, string]),\n\n\t/**\n\t\tAn optional function used to format your y axis titles and data in the\n\t\ttooltip legends. The first value is the name of your y field, the second value\n\t\tis your post-formatted y value, and the third value is your non-formatted\n\t\ty-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n\t*/\n\tyAxisTooltipFormatter: func,\n\n\t/**\n\t\tAn optional function used to format y-values in the tooltip legends.\n\t*/\n\tyAxisTooltipDataFormatter: func,\n\n\t/**\n\t\tAn optional function used to format the entire tooltip body. The only arg is\n\t\tthe associated data point. This formatter will over-ride yAxisTooltipFormatter\n\t\tand yAxisTooltipDataFormatter. Signature:\n\t\t\\`dataPoint => {}\\`\n\t*/\n\trenderTooltipBody: func,\n\n\t/**\n\t\tDetermines the orientation of the tick text. This may override what the orient prop\n\t\ttries to determine.\n\t*/\n\txAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),\n\n\t/**\n\t\tDetermines the orientation of the tick text. This may override what the orient prop\n\t\ttries to determine.\n\t*/\n\tyAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),\n};\n\nBarChart.defaultProps = defaultProps;\n\nBarChart.peek = {\n\tdescription: `A \\`Bar Chart\\` is great for showing data that fits neatly into \"buckets\". The x axis data must be strings, and the y axis data must be numeric.`,\n\tcategories: ['visualizations', 'charts'],\n\tmadeFrom: ['ContextMenu', 'ToolTip'],\n};\n\nBarChart.EmptyStateWrapper = EmptyStateWrapper;\n\nBarChart.PADDING = 0.05;\n\nBarChart.PADDING_GROUPED_OR_STACKED = 0.3;\n\nBarChart.MARGIN = {\n\ttop: 10,\n\tright: 20,\n\tbottom: 50,\n\tleft: 80,\n};\n\nexport default BarChart;\n"]},"metadata":{},"sourceType":"module"}