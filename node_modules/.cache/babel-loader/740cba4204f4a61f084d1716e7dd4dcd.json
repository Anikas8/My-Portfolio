{"ast":null,"code":"import _ from 'lodash';\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { extractFields, stackByFields } from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\nimport Bar from '../Bar/Bar';\nimport { ToolTipDumb as ToolTip } from '../ToolTip/ToolTip';\nimport Legend from '../Legend/Legend';\n// memoizing to maintain referential equality across renders, for performance\n// optimization with shallow comparison\nconst memoizedExtractFields = _.memoize(extractFields);\nconst memoizedStackByFields = _.memoize(stackByFields);\nconst cx = lucidClassNames.bind('&-Bars');\nconst {\n  arrayOf,\n  func,\n  number,\n  object,\n  bool,\n  string\n} = PropTypes;\n/** TODO: Remove this constant when the component is converted to a functional component */\nconst nonPassThroughs = ['className', 'data', 'legend', 'hasToolTips', 'palette', 'colorMap', 'xScale', 'xField', 'xFormatter', 'yScale', 'yFields', 'yFormatter', 'yStackedMax', 'yTooltipFormatter', 'isStacked', 'colorOffset', 'renderTooltipBody'];\nexport class Bars extends PureComponent {\n  constructor() {\n    super(...arguments);\n    this.defaultTooltipFormatter = dataPoint => {\n      const {\n        colorMap,\n        colorOffset,\n        isStacked,\n        legend,\n        palette,\n        yFields,\n        yFormatter,\n        yTooltipFormatter\n      } = this.props;\n      return React.createElement(Legend, {\n        hasBorders: false,\n        isReversed: isStacked\n      }, _.map(yFields, (field, fieldIndex) => React.createElement(Legend.Item, {\n        key: fieldIndex,\n        hasPoint: true,\n        pointKind: 1,\n        color: _.get(colorMap, field, palette[(fieldIndex + colorOffset) % palette.length])\n      }, yTooltipFormatter(_.get(legend, field, field), yFormatter(dataPoint[field], dataPoint), dataPoint[field]))));\n    };\n    this.handleMouseEnter = hoveringSeriesIndex => {\n      this.setState({\n        hoveringSeriesIndex\n      });\n    };\n    this.handleMouseOut = () => {\n      this.setState({\n        hoveringSeriesIndex: null\n      });\n    };\n    this.state = {\n      hoveringSeriesIndex: null\n    };\n  }\n  render() {\n    const {\n      className,\n      data,\n      hasToolTips,\n      palette,\n      colorMap,\n      colorOffset,\n      xScale,\n      xField,\n      xFormatter,\n      yScale: yScaleOriginal,\n      yFields,\n      yStackedMax,\n      renderTooltipBody,\n      isStacked,\n      ...passThroughs\n    } = this.props;\n    const {\n      hoveringSeriesIndex\n    } = this.state;\n    // This scale is used for grouped bars\n    const innerXScale = d3Scale.scaleBand().domain(_.times(yFields.length, num => `${num}`)).range([0, xScale.bandwidth()]).round(true);\n    // Copy the original so we can mutate it\n    const yScale = yScaleOriginal.copy();\n    // If we are stacked, we need to calculate a new domain based on the sum of\n    // the various series' y data. One row per series.\n    const transformedData = isStacked ? memoizedStackByFields(data, yFields) : memoizedExtractFields(data, yFields, yScale.domain()[0]);\n    // If we are stacked, we need to calculate a new domain based on the sum of\n    // the various group's y data\n    if (isStacked) {\n      yScale.domain([yScale.domain()[0],\n      //@ts-ignore\n      yStackedMax || _.max(_.map(transformedData, x => _.last(_.last(x))))]);\n    }\n    return React.createElement(\"g\", {\n      ..._.omit(passThroughs, nonPassThroughs),\n      className: cx(className, '&')\n    }, _.map(transformedData, (series, seriesIndex) => React.createElement(\"g\", {\n      key: seriesIndex\n    }, _.map(series, (_ref, pointsIndex) => {\n      let [start, end] = _ref;\n      return React.createElement(Bar, {\n        key: pointsIndex,\n        x: isStacked ?\n        // @ts-ignore\n        xScale(data[seriesIndex][xField]) :\n        // prettier-ignore\n        // @ts-ignore\n        innerXScale(pointsIndex) +\n        // prettier-ignore\n        // @ts-ignore\n        xScale(data[seriesIndex][xField]),\n        y: yScale(end),\n        height: yScale(start) - yScale(end),\n        width: isStacked ? xScale.bandwidth() : innerXScale.bandwidth(),\n        color: _.get(colorMap, yFields[pointsIndex], palette[(pointsIndex + colorOffset) % palette.length])\n      });\n    }), React.createElement(PureToolTip, {\n      isExpanded: hasToolTips && hoveringSeriesIndex === seriesIndex,\n      height: isStacked ?\n      // prettier-ignore\n      //@ts-ignore\n      yScale.range()[0] - yScale(_.last(series)[1]) :\n      // prettier-ignore\n      //@ts-ignore\n      yScale.range()[0] - yScale(_.max(_.flatten(series))),\n      width: xScale.bandwidth(),\n      // @ts-ignore\n      x: xScale(data[seriesIndex][xField]),\n      y: yScale(_.max(_.flatten(series))),\n      series: series,\n      seriesIndex: seriesIndex,\n      onMouseEnter: this.handleMouseEnter,\n      onMouseOut: this.handleMouseOut,\n      xFormatter: xFormatter,\n      xField: xField,\n      renderBody: renderTooltipBody || this.defaultTooltipFormatter,\n      data: data\n    }))));\n  }\n}\nBars.displayName = 'Bars';\nBars.peek = {\n  description: `For use within an \\`svg\\`. \\`Bars\\` are typically used to represent categorical data and can be stacked or grouped.`,\n  categories: ['visualizations', 'chart primitives'],\n  madeFrom: ['Bar', 'ToolTip', 'Legend']\n};\nBars.propTypes = {\n  /**\n      Appended to the component-specific class names set on the root element.\n  */\n  className: string,\n  /**\n      De-normalized data\n           [\n              { x: 'one', y0: 1, y1: 2, y2: 3, y3: 5 },\n              { x: 'two', y0: 2, y1: 3, y2: 4, y3: 6 },\n              { x: 'three', y0: 2, y1: 4, y2: 5, y3: 6 },\n              { x: 'four', y0: 3, y1: 6, y2: 7, y3: 7 },\n              { x: 'five', y0: 4, y1: 8, y2: 9, y3: 8 },\n          ]\n  */\n  data: arrayOf(object).isRequired,\n  /**\n      An object with human readable names for fields that  will be used for\n      tooltips. E.g:\n           {\n              rev: 'Revenue',\n              imps: 'Impressions',\n          }\n  */\n  legend: object,\n  /**\n   * Show tool tips on hover.\n   */\n  hasToolTips: bool,\n  /**\n      Takes one of the palettes exported from \\`lucid.chartConstants\\`.\n      Available palettes:\n       - \\`PALETTE_7\\` (default)\n      - \\`PALETTE_30\\`\n      - \\`PALETTE_MONOCHROME_0_5\\`\n      - \\`PALETTE_MONOCHROME_1_5\\`\n      - \\`PALETTE_MONOCHROME_2_5\\`\n      - \\`PALETTE_MONOCHROME_3_5\\`\n      - \\`PALETTE_MONOCHROME_4_5\\`\n      - \\`PALETTE_MONOCHROME_5_5\\`\n      - \\`PALETTE_MONOCHROME_6_5\\`\n  */\n  palette: arrayOf(string),\n  /**\n      You can pass in an object if you want to map fields to\n      \\`lucid.chartConstants\\` or custom colors:\n           {\n              'imps': COLOR_0,\n              'rev': COLOR_3,\n              'clicks': '#abc123',\n          }\n  */\n  colorMap: object,\n  /**\n      The scale for the x axis. Must be a d3 band scale. Lucid exposes the\n      \\`lucid.d3Scale.scaleBand\\` library for use here.\n  */\n  xScale: func.isRequired,\n  /**\n      The field we should look up your x data by.\n  */\n  xField: string,\n  /**\n      Function to format the x data.\n  */\n  xFormatter: func,\n  /**\n      The scale for the y axis. Must be a d3 scale. Lucid exposes the\n      \\`lucid.d3Scale\\` library for use here.\n  */\n  yScale: func.isRequired,\n  /**\n      The field(s) we should look up your y data by. Each entry represents a\n      series. Your actual y data should be numeric.\n  */\n  yFields: arrayOf(string),\n  /**\n      Function to format the y data.\n  */\n  yFormatter: func,\n  /**\n      Typically this number can be derived from the yScale. However when we're\n      \\`isStacked\\` we need to calculate a new domain for the yScale based on\n      the sum of the data. If you need explicit control of the y max when\n      stacking, pass it in here.\n  */\n  yStackedMax: number,\n  /**\n      An optional function used to format your y axis titles and data in the\n      tooltips. The first value is the name of your y field, the second value\n      is your post-formatted y value, and the third value is your non-formatted\n      y-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n  */\n  yTooltipFormatter: func,\n  /**\n      This will stack the data instead of grouping it. In order to stack the\n      data we have to calculate a new domain for the y scale that is based on\n      the \\`sum\\` of the data.\n  */\n  isStacked: bool,\n  /**\n      Sometimes you might not want the colors to start rotating at the blue\n      color, this number will be added the bar index in determining which color\n      the bars are.\n  */\n  colorOffset: number,\n  /**\n      An optional function used to format the entire tooltip body. The only arg is\n      the associated data point. This formatter will over-ride yTooltipFormatter\n      and yAxisTooltipDataFormatter. Signature:\n      \\`dataPoint => {}\\`\n  */\n  renderTooltipBody: func\n};\nBars.defaultProps = {\n  hasToolTips: true,\n  xField: 'x',\n  xFormatter: _.identity,\n  yFields: ['y'],\n  yFormatter: _.identity,\n  yTooltipFormatter: (yField, yValueFormatted) => `${yField}: ${yValueFormatted}`,\n  renderTooltipBody: undefined,\n  isStacked: false,\n  colorOffset: 0,\n  palette: chartConstants.PALETTE_7\n};\nexport class PureToolTip extends PureComponent {\n  constructor() {\n    super(...arguments);\n    this.handleMouseEnter = () => {\n      this.props.onMouseEnter(this.props.seriesIndex);\n    };\n  }\n  render() {\n    const {\n      isExpanded,\n      height,\n      width,\n      x,\n      y,\n      seriesIndex,\n      onMouseOut,\n      renderBody,\n      data,\n      xFormatter,\n      xField\n    } = this.props;\n    return React.createElement(ToolTip, {\n      isExpanded: isExpanded,\n      flyOutMaxWidth: 'none',\n      isLight: true\n    }, React.createElement(ToolTip.Target, {\n      elementType: 'g'\n    }, React.createElement(\"rect\", {\n      className: cx('&-tooltip-hover-zone'),\n      height: height,\n      width: width,\n      x: x,\n      y: y,\n      onMouseEnter: this.handleMouseEnter,\n      onMouseOut: onMouseOut\n    })), React.createElement(ToolTip.Title, null, xFormatter(\n    //@ts-ignore\n    data[seriesIndex][xField], data[seriesIndex])), React.createElement(ToolTip.Body, null, renderBody(data[seriesIndex])));\n  }\n}\nPureToolTip.displayName = 'PureToolTip';\nPureToolTip._isPrivate = true;\nPureToolTip.propTypes = {\n  data: arrayOf(object),\n  height: number,\n  isExpanded: bool,\n  onMouseEnter: func,\n  onMouseOut: func,\n  renderBody: func,\n  seriesIndex: number,\n  width: number,\n  x: number,\n  xField: string,\n  xFormatter: func,\n  y: number\n};\nexport default Bars;","map":{"version":3,"mappings":"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","names":["_","React","PureComponent","PropTypes","d3Scale","lucidClassNames","extractFields","stackByFields","chartConstants","Bar","ToolTipDumb","ToolTip","Legend","memoizedExtractFields","memoize","memoizedStackByFields","cx","bind","arrayOf","func","number","object","bool","string","nonPassThroughs","Bars","constructor","dataPoint","colorMap","colorOffset","isStacked","legend","palette","yFields","yFormatter","yTooltipFormatter","props","hasBorders","isReversed","map","field","fieldIndex","Item","key","hasPoint","pointKind","color","get","length","hoveringSeriesIndex","setState","render","className","data","hasToolTips","xScale","xField","xFormatter","yScale","yScaleOriginal","yStackedMax","renderTooltipBody","passThroughs","state","innerXScale","scaleBand","domain","times","num","range","bandwidth","round","copy","transformedData","max","x","last","omit","series","seriesIndex","pointsIndex","start","end","y","height","width","PureToolTip","isExpanded","flatten","onMouseEnter","handleMouseEnter","onMouseOut","handleMouseOut","renderBody","defaultTooltipFormatter","description","categories","madeFrom","isRequired","identity","yField","yValueFormatted","undefined","PALETTE_7","flyOutMaxWidth","isLight","Target","elementType","Title","Body"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/Bars/Bars.tsx"],"sourcesContent":["import _ from 'lodash';\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\n\nimport { lucidClassNames } from '../../util/style-helpers';\nimport {\n\tCollection,\n\textractFields,\n\tstackByFields,\n} from '../../util/chart-helpers';\nimport { StandardProps } from '../../util/component-types';\nimport * as chartConstants from '../../constants/charts';\nimport Bar from '../Bar/Bar';\nimport { ToolTipDumb as ToolTip } from '../ToolTip/ToolTip';\nimport Legend from '../Legend/Legend';\n\n// memoizing to maintain referential equality across renders, for performance\n// optimization with shallow comparison\nconst memoizedExtractFields = _.memoize(extractFields);\nconst memoizedStackByFields = _.memoize(stackByFields);\n\nconst cx = lucidClassNames.bind('&-Bars');\n\nconst { arrayOf, func, number, object, bool, string } = PropTypes;\n\nexport interface IBarsProps extends StandardProps {\n\t/**\n\t * De-normalized data\n\t *\n\t * [\n\t * \t{ x: 'one', y0: 1, y1: 2, y2: 3, y3: 5 },\n\t * \t{ x: 'two', y0: 2, y1: 3, y2: 4, y3: 6 },\n\t * \t{ x: 'three', y0: 2, y1: 4, y2: 5, y3: 6 },\n\t * \t{ x: 'four', y0: 3, y1: 6, y2: 7, y3: 7 },\n\t * \t{ x: 'five', y0: 4, y1: 8, y2: 9, y3: 8 },\n\t * ]\n\t */\n\tdata: Collection;\n\n\t/**\n\t * \tAn object with human readable names for fields that  will be used for tooltips. E.g:\n\t * \t{\n\t * \t\trev: 'Revenue',\n\t * \t\timps: 'Impressions',\n\t * \t}\n\t */\n\tlegend?: object;\n\n\t/** Show tool tips on hover. Default is true. */\n\thasToolTips: boolean;\n\n\t/**\n\t * \tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\t * Available palettes:\n\t * - \\`PALETTE_7\\` (default)\n\t * - \\`PALETTE_30\\`\n\t * - \\`PALETTE_MONOCHROME_0_5\\`\n\t * - \\`PALETTE_MONOCHROME_1_5\\`\n\t * - \\`PALETTE_MONOCHROME_2_5\\`\n\t * - \\`PALETTE_MONOCHROME_3_5\\`\n\t * - \\`PALETTE_MONOCHROME_4_5\\`\n\t * - \\`PALETTE_MONOCHROME_5_5\\`\n\t * - \\`PALETTE_MONOCHROME_6_5\\`\n\t */\n\tpalette: string[];\n\n\t/**\n\t * You can pass in an object if you want to map fields to `lucid.chartConstants\\`\n\t * or custom colors:\n\t * {\n\t * \t'imps': COLOR_0,\n\t * \t'rev': COLOR_3,\n\t * \t'clicks': '#abc123',\n\t * }\n\t *\n\t */\n\tcolorMap?: object;\n\n\t/** The scale for the x axis.\n\t * Must be a d3 band scale.\n\t * Lucid exposes the\\`lucid.d3Scale.scaleBand\\` library for use here.\n\t */\n\t//xScale: (x: string) => number | undefined;\n\txScale:\n\t\t| d3Scale.ScaleBand<string>\n\t\t| d3Scale.ScaleBand<number>\n\t\t| d3Scale.ScalePoint<string>;\n\n\t/** The field we should look up your x data by.*/\n\txField: string;\n\n\t/** Function to format the x data. */\n\txFormatter: (d: Date) => string;\n\n\t/** The scale for the y axis. Is required.\n\t * Must be a d3 scale.\n\t * Lucid exposes the \\`lucid.d3Scale\\` library for use here.\n\t * */\n\tyScale:\n\t\t| d3Scale.ScaleBand<string | number>\n\t\t| d3Scale.ScalePoint<string | number>\n\t\t| d3Scale.ScaleLinear<number, number>;\n\n\t/** The field(s) we should look up your y data by.\n\t * Each entry represents a series.\n\t * The actual y data should be numeric. */\n\tyFields: string[];\n\n\t/** Function to format the y data.\n\t * Signature yFormatter(dataPoint[field], dataPoint),\n\t */\n\tyFormatter: (\n\t\ty: string | number,\n\t\tdataPoint: { [key: string]: string | number }\n\t) => string;\n\n\t/** Typically this number can be derived from the yScale.\n\t * However when we're \\`isStacked\\` we need to calculate a new domain for the yScale\n\t * based on the sum of the data.\n\t * If you need explicit control of the y max when stacking, pass it in here. */\n\tyStackedMax?: number;\n\n\t/** An optional function used to format your y axis titles and data in the tooltips.\n\t * The first value is the name of your y field,\n\t * the second value is your post-formatted y value,\n\t * and the third value is your non-formatted y-value.\n\t * Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n\t * */\n\t// (yField, yValueFormatted) => `${yField}: ${yValueFormatted}`,\n\tyTooltipFormatter: (\n\t\tyField: string,\n\t\tyValueFormatted: string | number,\n\t\tyValue: number\n\t) => string | number;\n\n\t/** This will stack the data instead of grouping it.\n\t * In order to stack the data we have to calculate a new domain for the y scale\n\t * that is based on the \\`sum\\` of the data. */\n\tisStacked: boolean;\n\n\t/** Sometimes you might not want the colors to start rotating at the blue color,\n\t * this number will be added the bar index in determining which color the bars are. */\n\tcolorOffset: number;\n\n\t/** An optional function used to format the entire tooltip body.\n\t * The only arg is the associated data point.\n\t * This formatter will over-ride yTooltipFormatter and yAxisTooltipDataFormatter.\n\t * Signature: \\`dataPoint => {}\\`\n\t */\n\trenderTooltipBody: (dataPoint: number | string | object) => {};\n}\n\ninterface IBarsState {\n\thoveringSeriesIndex: null | number;\n}\n\n/** TODO: Remove this constant when the component is converted to a functional component */\nconst nonPassThroughs = [\n\t'className',\n\t'data',\n\t'legend',\n\t'hasToolTips',\n\t'palette',\n\t'colorMap',\n\t'xScale',\n\t'xField',\n\t'xFormatter',\n\t'yScale',\n\t'yFields',\n\t'yFormatter',\n\t'yStackedMax',\n\t'yTooltipFormatter',\n\t'isStacked',\n\t'colorOffset',\n\t'renderTooltipBody',\n];\n\nexport class Bars extends PureComponent<IBarsProps, IBarsState> {\n\tstatic displayName = 'Bars';\n\n\tstatic peek = {\n\t\tdescription: `For use within an \\`svg\\`. \\`Bars\\` are typically used to represent categorical data and can be stacked or grouped.`,\n\t\tcategories: ['visualizations', 'chart primitives'],\n\t\tmadeFrom: ['Bar', 'ToolTip', 'Legend'],\n\t};\n\n\tstatic propTypes = {\n\t\t/**\n\t\t\tAppended to the component-specific class names set on the root element.\n\t\t*/\n\t\tclassName: string,\n\n\t\t/**\n\t\t\tDe-normalized data\n\n\t\t\t\t[\n\t\t\t\t\t{ x: 'one', y0: 1, y1: 2, y2: 3, y3: 5 },\n\t\t\t\t\t{ x: 'two', y0: 2, y1: 3, y2: 4, y3: 6 },\n\t\t\t\t\t{ x: 'three', y0: 2, y1: 4, y2: 5, y3: 6 },\n\t\t\t\t\t{ x: 'four', y0: 3, y1: 6, y2: 7, y3: 7 },\n\t\t\t\t\t{ x: 'five', y0: 4, y1: 8, y2: 9, y3: 8 },\n\t\t\t\t]\n\t\t*/\n\t\tdata: arrayOf(object).isRequired,\n\n\t\t/**\n\t\t\tAn object with human readable names for fields that  will be used for\n\t\t\ttooltips. E.g:\n\n\t\t\t\t{\n\t\t\t\t\trev: 'Revenue',\n\t\t\t\t\timps: 'Impressions',\n\t\t\t\t}\n\t\t*/\n\t\tlegend: object,\n\n\t\t/**\n\t\t * Show tool tips on hover.\n\t\t */\n\t\thasToolTips: bool,\n\n\t\t/**\n\t\t\tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\t\t\tAvailable palettes:\n\n\t\t\t- \\`PALETTE_7\\` (default)\n\t\t\t- \\`PALETTE_30\\`\n\t\t\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_6_5\\`\n\t\t*/\n\t\tpalette: arrayOf(string),\n\n\t\t/**\n\t\t\tYou can pass in an object if you want to map fields to\n\t\t\t\\`lucid.chartConstants\\` or custom colors:\n\n\t\t\t\t{\n\t\t\t\t\t'imps': COLOR_0,\n\t\t\t\t\t'rev': COLOR_3,\n\t\t\t\t\t'clicks': '#abc123',\n\t\t\t\t}\n\t\t*/\n\t\tcolorMap: object,\n\n\t\t/**\n\t\t\tThe scale for the x axis. Must be a d3 band scale. Lucid exposes the\n\t\t\t\\`lucid.d3Scale.scaleBand\\` library for use here.\n\t\t*/\n\t\txScale: func.isRequired,\n\n\t\t/**\n\t\t\tThe field we should look up your x data by.\n\t\t*/\n\t\txField: string,\n\n\t\t/**\n\t\t\tFunction to format the x data.\n\t\t*/\n\t\txFormatter: func,\n\n\t\t/**\n\t\t\tThe scale for the y axis. Must be a d3 scale. Lucid exposes the\n\t\t\t\\`lucid.d3Scale\\` library for use here.\n\t\t*/\n\t\tyScale: func.isRequired,\n\n\t\t/**\n\t\t\tThe field(s) we should look up your y data by. Each entry represents a\n\t\t\tseries. Your actual y data should be numeric.\n\t\t*/\n\t\tyFields: arrayOf(string),\n\n\t\t/**\n\t\t\tFunction to format the y data.\n\t\t*/\n\t\tyFormatter: func,\n\n\t\t/**\n\t\t\tTypically this number can be derived from the yScale. However when we're\n\t\t\t\\`isStacked\\` we need to calculate a new domain for the yScale based on\n\t\t\tthe sum of the data. If you need explicit control of the y max when\n\t\t\tstacking, pass it in here.\n\t\t*/\n\t\tyStackedMax: number,\n\n\t\t/**\n\t\t\tAn optional function used to format your y axis titles and data in the\n\t\t\ttooltips. The first value is the name of your y field, the second value\n\t\t\tis your post-formatted y value, and the third value is your non-formatted\n\t\t\ty-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n\t\t*/\n\t\tyTooltipFormatter: func,\n\n\t\t/**\n\t\t\tThis will stack the data instead of grouping it. In order to stack the\n\t\t\tdata we have to calculate a new domain for the y scale that is based on\n\t\t\tthe \\`sum\\` of the data.\n\t\t*/\n\t\tisStacked: bool,\n\n\t\t/**\n\t\t\tSometimes you might not want the colors to start rotating at the blue\n\t\t\tcolor, this number will be added the bar index in determining which color\n\t\t\tthe bars are.\n\t\t*/\n\t\tcolorOffset: number,\n\n\t\t/**\n\t\t\tAn optional function used to format the entire tooltip body. The only arg is\n\t\t\tthe associated data point. This formatter will over-ride yTooltipFormatter\n\t\t\tand yAxisTooltipDataFormatter. Signature:\n\t\t\t\\`dataPoint => {}\\`\n\t\t*/\n\t\trenderTooltipBody: func,\n\t};\n\n\tdefaultTooltipFormatter = (dataPoint: { [key: string]: number }) => {\n\t\tconst {\n\t\t\tcolorMap,\n\t\t\tcolorOffset,\n\t\t\tisStacked,\n\t\t\tlegend,\n\t\t\tpalette,\n\t\t\tyFields,\n\t\t\tyFormatter,\n\t\t\tyTooltipFormatter,\n\t\t} = this.props;\n\n\t\treturn (\n\t\t\t<Legend hasBorders={false} isReversed={isStacked}>\n\t\t\t\t{_.map(yFields, (field: string | number, fieldIndex) => (\n\t\t\t\t\t<Legend.Item\n\t\t\t\t\t\tkey={fieldIndex}\n\t\t\t\t\t\thasPoint={true}\n\t\t\t\t\t\tpointKind={1}\n\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t\tpalette[(fieldIndex + colorOffset) % palette.length]\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{yTooltipFormatter(\n\t\t\t\t\t\t\t_.get(legend, field, field),\n\t\t\t\t\t\t\tyFormatter(dataPoint[field], dataPoint),\n\t\t\t\t\t\t\tdataPoint[field]\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Legend.Item>\n\t\t\t\t))}\n\t\t\t</Legend>\n\t\t);\n\t};\n\n\thandleMouseEnter = (hoveringSeriesIndex: number) => {\n\t\tthis.setState({\n\t\t\thoveringSeriesIndex,\n\t\t});\n\t};\n\n\thandleMouseOut = () => {\n\t\tthis.setState({ hoveringSeriesIndex: null });\n\t};\n\n\tstatic defaultProps = {\n\t\thasToolTips: true,\n\t\txField: 'x',\n\t\txFormatter: _.identity,\n\t\tyFields: ['y'],\n\t\tyFormatter: _.identity,\n\t\tyTooltipFormatter: (yField: string, yValueFormatted: any) =>\n\t\t\t`${yField}: ${yValueFormatted}`,\n\t\trenderTooltipBody: undefined,\n\t\tisStacked: false,\n\t\tcolorOffset: 0,\n\t\tpalette: chartConstants.PALETTE_7,\n\t};\n\n\tstate = {\n\t\thoveringSeriesIndex: null,\n\t};\n\n\trender() {\n\t\tconst {\n\t\t\tclassName,\n\t\t\tdata,\n\t\t\thasToolTips,\n\t\t\tpalette,\n\t\t\tcolorMap,\n\t\t\tcolorOffset,\n\t\t\txScale,\n\t\t\txField,\n\t\t\txFormatter,\n\t\t\tyScale: yScaleOriginal,\n\t\t\tyFields,\n\t\t\tyStackedMax,\n\t\t\trenderTooltipBody,\n\t\t\tisStacked,\n\t\t\t...passThroughs\n\t\t} = this.props;\n\n\t\tconst { hoveringSeriesIndex } = this.state;\n\n\t\t// This scale is used for grouped bars\n\t\tconst innerXScale = d3Scale\n\t\t\t.scaleBand()\n\t\t\t.domain(_.times(yFields.length, (num: number) => `${num}`))\n\t\t\t.range([0, xScale.bandwidth()])\n\t\t\t.round(true);\n\n\t\t// Copy the original so we can mutate it\n\t\tconst yScale = yScaleOriginal.copy();\n\n\t\t// If we are stacked, we need to calculate a new domain based on the sum of\n\t\t// the various series' y data. One row per series.\n\t\tconst transformedData = isStacked\n\t\t\t? memoizedStackByFields(data, yFields)\n\t\t\t: memoizedExtractFields(data, yFields, (yScale.domain() as number[])[0]);\n\n\t\t// If we are stacked, we need to calculate a new domain based on the sum of\n\t\t// the various group's y data\n\t\tif (isStacked) {\n\t\t\tyScale.domain([\n\t\t\t\tyScale.domain()[0] as any,\n\t\t\t\t//@ts-ignore\n\t\t\t\tyStackedMax || _.max(_.map(transformedData, (x) => _.last(_.last(x)))),\n\t\t\t]);\n\t\t}\n\n\t\treturn (\n\t\t\t<g\n\t\t\t\t{..._.omit(passThroughs, nonPassThroughs)}\n\t\t\t\tclassName={cx(className, '&')}\n\t\t\t>\n\t\t\t\t{_.map(transformedData, (series, seriesIndex) => (\n\t\t\t\t\t<g key={seriesIndex}>\n\t\t\t\t\t\t{_.map(series, ([start, end], pointsIndex) => (\n\t\t\t\t\t\t\t<Bar\n\t\t\t\t\t\t\t\tkey={pointsIndex}\n\t\t\t\t\t\t\t\tx={\n\t\t\t\t\t\t\t\t\tisStacked\n\t\t\t\t\t\t\t\t\t\t? // @ts-ignore\n\t\t\t\t\t\t\t\t\t\t  xScale(data[seriesIndex][xField])\n\t\t\t\t\t\t\t\t\t\t: // prettier-ignore\n\t\t\t\t\t\t\t\t\t\t  // @ts-ignore\n\t\t\t\t\t\t\t\t\t\t  innerXScale(pointsIndex) +\n\t\t\t\t\t\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\t\t\txScale(data[seriesIndex][xField] as any)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ty={yScale(end)}\n\t\t\t\t\t\t\t\theight={(yScale(start) as any) - (yScale(end) as any)}\n\t\t\t\t\t\t\t\twidth={isStacked ? xScale.bandwidth() : innerXScale.bandwidth()}\n\t\t\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\t\t\tyFields[pointsIndex],\n\t\t\t\t\t\t\t\t\tpalette[(pointsIndex + colorOffset) % palette.length]\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\n\t\t\t\t\t\t<PureToolTip\n\t\t\t\t\t\t\tisExpanded={hasToolTips && hoveringSeriesIndex === seriesIndex}\n\t\t\t\t\t\t\theight={\n\t\t\t\t\t\t\t\tisStacked\n\t\t\t\t\t\t\t\t\t? // prettier-ignore\n\t\t\t\t\t\t\t\t\t  //@ts-ignore\n\t\t\t\t\t\t\t\t\t  yScale.range()[0] - yScale(_.last(series)[1])\n\t\t\t\t\t\t\t\t\t: // prettier-ignore\n\t\t\t\t\t\t\t\t\t  //@ts-ignore\n\t\t\t\t\t\t\t\t\t  yScale.range()[0] - yScale(_.max(_.flatten(series)))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twidth={xScale.bandwidth()}\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tx={xScale(data[seriesIndex][xField])}\n\t\t\t\t\t\t\ty={yScale(_.max(_.flatten(series)) as any)}\n\t\t\t\t\t\t\tseries={series}\n\t\t\t\t\t\t\tseriesIndex={seriesIndex}\n\t\t\t\t\t\t\tonMouseEnter={this.handleMouseEnter}\n\t\t\t\t\t\t\tonMouseOut={this.handleMouseOut}\n\t\t\t\t\t\t\txFormatter={xFormatter}\n\t\t\t\t\t\t\txField={xField}\n\t\t\t\t\t\t\trenderBody={renderTooltipBody || this.defaultTooltipFormatter}\n\t\t\t\t\t\t\tdata={data}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t))}\n\t\t\t</g>\n\t\t);\n\t}\n}\n\nexport interface IPureToolTipsProps extends StandardProps {\n\tisExpanded: boolean;\n\n\theight: number;\n\n\twidth: number;\n\n\tx?: number;\n\n\ty?: number;\n\n\tseries: Array<[number, number]>;\n\n\tseriesIndex: number;\n\n\tonMouseEnter: (seriesIndex: number) => void;\n\t//onMouseEnter: (event: MouseEvent<SVGRectElement, MouseEvent>) => void\n\n\tonMouseOut?:\n\t\t| ((event: React.MouseEvent<SVGRectElement, MouseEvent>) => void)\n\t\t| undefined;\n\n\txFormatter: (d: Date, seriesIndex: number) => string;\n\n\txField: string;\n\n\trenderBody: (dataPoint: number) => {};\n\n\tdata: Array<{ [key: string]: string | number }>;\n}\n\nexport class PureToolTip extends PureComponent<IPureToolTipsProps> {\n\tstatic displayName = 'PureToolTip';\n\n\tstatic _isPrivate = true;\n\n\tstatic propTypes = {\n\t\tdata: arrayOf(object),\n\t\theight: number,\n\t\tisExpanded: bool,\n\t\tonMouseEnter: func,\n\t\tonMouseOut: func,\n\t\trenderBody: func,\n\t\tseriesIndex: number,\n\t\twidth: number,\n\t\tx: number,\n\t\txField: string,\n\t\txFormatter: func,\n\t\ty: number,\n\t};\n\n\thandleMouseEnter = () => {\n\t\tthis.props.onMouseEnter(this.props.seriesIndex);\n\t};\n\n\trender(): React.ReactNode {\n\t\tconst {\n\t\t\tisExpanded,\n\t\t\theight,\n\t\t\twidth,\n\t\t\tx,\n\t\t\ty,\n\t\t\tseriesIndex,\n\t\t\tonMouseOut,\n\t\t\trenderBody,\n\t\t\tdata,\n\t\t\txFormatter,\n\t\t\txField,\n\t\t} = this.props;\n\n\t\treturn (\n\t\t\t<ToolTip isExpanded={isExpanded} flyOutMaxWidth='none' isLight={true}>\n\t\t\t\t<ToolTip.Target elementType='g'>\n\t\t\t\t\t<rect\n\t\t\t\t\t\tclassName={cx('&-tooltip-hover-zone')}\n\t\t\t\t\t\theight={height}\n\t\t\t\t\t\twidth={width}\n\t\t\t\t\t\tx={x}\n\t\t\t\t\t\ty={y}\n\t\t\t\t\t\tonMouseEnter={this.handleMouseEnter}\n\t\t\t\t\t\tonMouseOut={onMouseOut}\n\t\t\t\t\t/>\n\t\t\t\t</ToolTip.Target>\n\n\t\t\t\t<ToolTip.Title>\n\t\t\t\t\t{xFormatter(\n\t\t\t\t\t\t//@ts-ignore\n\t\t\t\t\t\tdata[seriesIndex][xField],\n\t\t\t\t\t\tdata[seriesIndex]\n\t\t\t\t\t)}\n\t\t\t\t</ToolTip.Title>\n\n\t\t\t\t<ToolTip.Body>{renderBody(data[seriesIndex] as any)}</ToolTip.Body>\n\t\t\t</ToolTip>\n\t\t);\n\t}\n}\n\nexport default Bars;\n"]},"metadata":{},"sourceType":"module"}