{"ast":null,"code":"import _, { omit } from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\nimport * as d3TimeFormat from 'd3-time-format';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { getFirst } from '../../util/component-types';\nimport { minByFields, maxByFields, maxByFieldsStacked, formatDate, nearest } from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\nimport Axis from '../Axis/Axis';\nimport AxisLabel from '../AxisLabel/AxisLabel';\nimport Legend from '../Legend/Legend';\nimport Lines from '../Lines/Lines';\nimport Points from '../Points/Points';\nimport { ToolTipDumb as ToolTip } from '../ToolTip/ToolTip';\nimport ContextMenu from '../ContextMenu/ContextMenu';\nimport EmptyStateWrapper from '../EmptyStateWrapper/EmptyStateWrapper';\nconst cx = lucidClassNames.bind('&-LineChart');\nconst {\n  arrayOf,\n  func,\n  instanceOf,\n  number,\n  object,\n  shape,\n  string,\n  bool,\n  oneOfType,\n  oneOf\n} = PropTypes;\n/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */\nconst nonPassThroughs = ['className', 'height', 'width', 'margin', 'data', 'legend', 'isLoading', 'hasToolTips', 'hasLegend', 'palette', 'colorMap', 'xAxisField', 'xAxisMin', 'xAxisMax', 'xAxisFormatter', 'xAxisTooltipFormatter', 'xAxisTickCount', 'xAxisTicks', 'xAxisTitle', 'xAxisTitleColor', 'xAxisTextOrientation', 'yAxisFields', 'yAxisMin', 'yAxisMax', 'yAxisFormatter', 'yAxisIsStacked', 'yAxisHasPoints', 'yAxisTickCount', 'yAxisTitle', 'yAxisTitleColor', 'yAxisTooltipFormatter', 'yAxisTooltipDataFormatter', 'yAxisColorOffset', 'y2AxisFields', 'y2AxisMin', 'y2AxisMax', 'y2AxisFormatter', 'y2AxisTooltipDataFormatter', 'y2AxisIsStacked', 'y2AxisHasPoints', 'y2AxisTickCount', 'y2AxisTitle', 'y2AxisTitleColor', 'y2AxisColorOffset', 'yAxisTextOrientation', 'callbackId', 'initialState'];\nclass LineChart extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      isHovering: false,\n      mouseX: undefined\n    };\n    this.handleToolTipHoverZone = (_ref, xPoints) => {\n      let {\n        clientX,\n        target\n      } = _ref;\n      const mouseX = nearest(xPoints, clientX - target.getBoundingClientRect().left);\n      if (!this.state.isHovering || this.state.mouseX !== mouseX) {\n        this.setState({\n          isHovering: true,\n          mouseX: nearest(xPoints, clientX - target.getBoundingClientRect().left)\n        });\n      }\n    };\n    this.renderY2Axis = (xScale, y2Scale, y2AxisFinalFormatter, margin) => {\n      const {\n        y2AxisFields,\n        yAxisFields,\n        y2AxisTickCount,\n        y2AxisTitle,\n        y2AxisTitleColor,\n        palette,\n        xAxisField,\n        y2AxisMax,\n        data,\n        y2AxisIsStacked,\n        y2AxisColorOffset,\n        colorMap,\n        y2AxisHasPoints\n      } = this.props;\n      /* y2 axis */\n      const axis = y2AxisFields ? React.createElement(\"g\", {\n        transform: `translate(${margin.left + innerWidth}, ${margin.top})`\n      }, React.createElement(Axis, {\n        orient: 'right',\n        scale: y2Scale,\n        tickFormat: y2AxisFinalFormatter,\n        tickCount: y2AxisTickCount\n      })) : null;\n      /* y2 axis title */\n      const axisTitle = y2AxisTitle ? React.createElement(\"g\", {\n        transform: `translate(${margin.left + innerWidth}, ${margin.top})`\n      }, React.createElement(AxisLabel, {\n        orient: 'right',\n        width: margin.right,\n        height: innerHeight,\n        label: y2AxisTitle,\n        color: _.isString(y2AxisTitleColor) ? y2AxisTitleColor : palette[y2AxisTitleColor % palette.length]\n      })) : null;\n      const axisLines = y2AxisFields ? React.createElement(\"g\", {\n        transform: `translate(${margin.left}, ${margin.top})`\n      }, React.createElement(Lines, {\n        xScale: xScale,\n        yScale: y2Scale,\n        xField: xAxisField,\n        yFields: y2AxisFields,\n        yStackedMax: y2AxisMax,\n        data: data || {},\n        isStacked: y2AxisIsStacked,\n        colorOffset: y2AxisColorOffset + yAxisFields.length,\n        colorMap: colorMap,\n        palette: palette\n      })) : null;\n      const axisPoints = y2AxisFields && y2AxisHasPoints ? React.createElement(\"g\", {\n        transform: `translate(${margin.left}, ${margin.top})`\n      }, React.createElement(Points, {\n        xScale: xScale,\n        yScale: y2Scale,\n        xField: xAxisField,\n        yFields: y2AxisFields,\n        yStackedMax: y2AxisMax,\n        data: data || {},\n        isStacked: y2AxisIsStacked,\n        colorOffset: y2AxisColorOffset + yAxisFields.length,\n        colorMap: colorMap,\n        palette: palette\n      })) : null;\n      return {\n        title: axisTitle,\n        lines: axisLines,\n        points: axisPoints,\n        axis: axis\n      };\n    };\n  }\n  render() {\n    const {\n      className,\n      height,\n      width,\n      margin: marginOriginal,\n      data,\n      legend,\n      isLoading,\n      hasToolTips,\n      hasLegend,\n      palette,\n      colorMap,\n      xAxisField,\n      xAxisTickCount,\n      xAxisTicks,\n      xAxisTitle,\n      xAxisTitleColor,\n      xAxisFormatter,\n      xAxisTooltipFormatter,\n      xAxisMin = minByFields(data, xAxisField),\n      xAxisMax = maxByFields(data, xAxisField),\n      xAxisTextOrientation,\n      yAxisFields,\n      yAxisFormatter,\n      yAxisHasPoints,\n      yAxisIsStacked,\n      yAxisTickCount,\n      yAxisTitle,\n      yAxisTitleColor,\n      yAxisMin,\n      yAxisTooltipFormatter,\n      yAxisTooltipDataFormatter,\n      yAxisMax = yAxisIsStacked ? maxByFieldsStacked(data, yAxisFields) : maxByFields(data, yAxisFields),\n      yAxisColorOffset,\n      y2AxisFields,\n      y2AxisFormatter,\n      y2AxisTooltipDataFormatter,\n      y2AxisHasPoints,\n      y2AxisIsStacked,\n      y2AxisMin,\n      y2AxisMax = y2AxisFields && y2AxisIsStacked ? maxByFieldsStacked(data, y2AxisFields) : maxByFields(data, y2AxisFields),\n      y2AxisColorOffset,\n      yAxisTextOrientation,\n      ...passThroughs\n    } = this.props;\n    const {\n      isHovering,\n      mouseX\n    } = this.state;\n    const margin = {\n      ...LineChart.MARGIN,\n      ...marginOriginal\n    };\n    const svgClasses = cx(className, '&');\n    const innerWidth = width - margin.left - margin.right;\n    const innerHeight = height - margin.top - margin.bottom;\n    /**\n     * x axis\n     */\n    const xScale = d3Scale.scaleTime().domain([xAxisMin, xAxisMax]).range([0, innerWidth]);\n    const xFinalFormatter = xAxisFormatter ? xAxisFormatter : xScale.tickFormat();\n    const allYFields = _.compact(yAxisFields.concat(y2AxisFields));\n    // This is used to map x mouse values back to data points.\n    const xPointMap = _.reduce(data, (acc, d) => {\n      // `floor` to avoid rounding errors, it doesn't need to be super precise\n      // since we're dealing with pixels\n      const point = Math.floor(xScale(d[xAxisField]));\n      _.each(allYFields, field => {\n        _.set(acc, `${point}.y.${field}`, d[field]);\n        _.set(acc, `${point}.x`, d[xAxisField]);\n      });\n      return acc;\n    }, {});\n    const xPoints = _.map(_.keys(xPointMap), _.toNumber);\n    /**\n     * y axis\n     */\n    const yScale = d3Scale.scaleLinear().domain([yAxisMin, yAxisMax]).range([innerHeight, 0]);\n    const yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();\n    const yFinalFormatter = yAxisTooltipDataFormatter ? yAxisTooltipDataFormatter : yAxisFinalFormatter;\n    const yAxisHasLinesFinal = !(yAxisIsStacked && !yAxisHasPoints);\n    const yAxisHasPointsFinal = yAxisHasPoints || yAxisIsStacked;\n    /**\n     * y2 axis\n     */\n    let y2Axis = {};\n    let y2AxisLegend = null;\n    let y2AxisToolTip = null;\n    if (y2AxisFields) {\n      const y2Scale = d3Scale.scaleLinear().domain([y2AxisMin, y2AxisMax]).range([innerHeight, 0]);\n      const y2AxisFinalFormatter = y2AxisFormatter ? y2AxisFormatter : y2Scale ? y2Scale.tickFormat() : _.identity;\n      const y2FinalFormatter = y2AxisTooltipDataFormatter ? y2AxisTooltipDataFormatter : y2AxisFinalFormatter;\n      const y2AxisHasPointsFinal = y2AxisHasPoints || y2AxisIsStacked;\n      const y2AxisHasLinesFinal = !(y2AxisIsStacked && !y2AxisHasPoints);\n      y2Axis = this.renderY2Axis(xScale, y2Scale, y2AxisFinalFormatter, margin);\n      y2AxisLegend = _.map(y2AxisFields, (field, index) => React.createElement(Legend.Item, {\n        key: index,\n        hasPoint: y2AxisHasPointsFinal,\n        hasLine: y2AxisHasLinesFinal,\n        color: _.get(colorMap, field, palette[y2AxisColorOffset + index + yAxisFields.length % palette.length]),\n        pointKind: y2AxisHasPoints ? y2AxisColorOffset + index + yAxisFields.length : 1\n      }, _.get(legend, field, field)));\n      y2AxisToolTip = _.map(y2AxisFields, (field, index) => !_.isNil(_.get(xPointMap, mouseX + '.y.' + field)) ? React.createElement(Legend.Item, {\n        key: index,\n        hasPoint: y2AxisHasPointsFinal,\n        hasLine: y2AxisHasLinesFinal,\n        color: _.get(colorMap, field, palette[y2AxisColorOffset + index + yAxisFields.length % palette.length]),\n        pointKind: y2AxisHasPoints ? y2AxisColorOffset + index + yAxisFields.length : 1\n      }, yAxisTooltipFormatter(_.get(legend, field, field), y2FinalFormatter(_.get(xPointMap, mouseX + '.y.' + field)), _.get(xPointMap, mouseX + '.y.' + field))) : null);\n    }\n    if (_.isEmpty(data) || width < 1 || height < 1 || isLoading) {\n      const emptyStateWrapper = getFirst(this.props, LineChart.EmptyStateWrapper) || React.createElement(LineChart.EmptyStateWrapper, {\n        Title: 'You have no data.'\n      });\n      const emptyStateWrapperProps = _.get(emptyStateWrapper, 'props', {});\n      const emptyStateWrapperChildren = _.get(emptyStateWrapperProps, 'children', []);\n      return React.createElement(EmptyStateWrapper, {\n        ...emptyStateWrapperProps,\n        isEmpty: _.isEmpty(data),\n        isLoading: isLoading\n      }, emptyStateWrapperChildren, React.createElement(\"svg\", {\n        ...omit(passThroughs, nonPassThroughs),\n        className: svgClasses,\n        width: width,\n        height: height\n      }, React.createElement(\"g\", {\n        transform: `translate(${margin.left}, ${margin.top})`\n      }, React.createElement(Axis, {\n        orient: 'left',\n        scale: yScale,\n        tickFormat: yAxisFormatter\n      })), React.createElement(\"g\", {\n        transform: `translate(${margin.left}, ${innerHeight + margin.top})`\n      }, React.createElement(Axis, {\n        orient: 'bottom',\n        scale: xScale,\n        tickFormat: xFinalFormatter\n      }))));\n    }\n    return React.createElement(\"svg\", {\n      ...omit(passThroughs, nonPassThroughs),\n      className: svgClasses,\n      width: width,\n      height: height\n    }, React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top})`\n    }, hasToolTips && isHovering && !_.isNil(mouseX) ? React.createElement(ToolTip, {\n      isLight: true,\n      isExpanded: true,\n      flyOutMaxWidth: 'none',\n      alignment: mouseX < innerWidth * 0.15 ? 'start' : mouseX > innerWidth * 0.85 ? 'end' : 'center'\n    }, React.createElement(ToolTip.Target, {\n      elementType: 'g'\n    }, React.createElement(\"path\", {\n      className: cx('&-tooltip-line'),\n      d: `M${mouseX},0 L${mouseX},${innerHeight}`\n    })), React.createElement(ToolTip.Title, null, xAxisTooltipFormatter(_.get(xPointMap, `${mouseX}.x`))), React.createElement(ToolTip.Body, null, React.createElement(Legend, {\n      hasBorders: false,\n      isReversed: yAxisIsStacked\n    }, _.map(yAxisFields, (field, index) => !_.isNil(_.get(xPointMap, mouseX + '.y.' + field)) ? React.createElement(Legend.Item, {\n      key: index,\n      hasPoint: yAxisHasPointsFinal,\n      hasLine: yAxisHasLinesFinal,\n      color: _.get(colorMap, field, palette[(index + yAxisColorOffset) % palette.length]),\n      pointKind: yAxisHasPoints ? index + yAxisColorOffset : 1\n    }, yAxisTooltipFormatter(_.get(legend, field, field), yFinalFormatter(_.get(xPointMap, mouseX + '.y.' + field)), _.get(xPointMap, mouseX + '.y.' + field))) : null), y2AxisToolTip))) : null), React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${innerHeight + margin.top})`\n    }, React.createElement(Axis, {\n      orient: 'bottom',\n      scale: xScale,\n      outerTickSize: 0,\n      tickFormat: xFinalFormatter,\n      tickCount: xAxisTickCount,\n      ticks: xAxisTicks,\n      textOrientation: xAxisTextOrientation\n    }), hasLegend ? React.createElement(ContextMenu, {\n      direction: 'down',\n      alignment: 'center',\n      directonOffset: (margin.bottom / 2 + Legend.HEIGHT / 2) * -1 /* should center the legend in the bottom margin */\n    }, React.createElement(ContextMenu.Target, {\n      elementType: 'g'\n    }, React.createElement(\"rect\", {\n      className: cx('&-invisible'),\n      width: innerWidth,\n      height: margin.bottom\n    })), React.createElement(ContextMenu.FlyOut, {\n      className: cx('&-legend-container')\n    }, React.createElement(Legend, {\n      orient: 'horizontal'\n    }, _.map(yAxisFields, (field, index) => React.createElement(Legend.Item, {\n      key: index,\n      hasPoint: yAxisHasPointsFinal,\n      hasLine: yAxisHasLinesFinal,\n      color: _.get(colorMap, field, palette[index + yAxisColorOffset % palette.length]),\n      pointKind: yAxisHasPoints ? index + yAxisColorOffset : 1\n    }, _.get(legend, field, field))), y2AxisLegend))) : null), xAxisTitle ? React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top + innerHeight})`\n    }, React.createElement(AxisLabel, {\n      orient: 'bottom',\n      width: innerWidth,\n      height: margin.bottom,\n      label: xAxisTitle,\n      color: _.isString(xAxisTitleColor) ? xAxisTitleColor : palette[xAxisTitleColor % palette.length]\n    })) : null, React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top})`\n    }, React.createElement(Axis, {\n      orient: 'left',\n      scale: yScale,\n      tickFormat: yAxisFinalFormatter,\n      tickCount: yAxisTickCount,\n      textOrientation: yAxisTextOrientation\n    })), yAxisTitle ? React.createElement(\"g\", {\n      transform: `translate(0, ${margin.top})`\n    }, React.createElement(AxisLabel, {\n      orient: 'left',\n      width: margin.left,\n      height: innerHeight,\n      label: yAxisTitle,\n      color: _.isString(yAxisTitleColor) ? yAxisTitleColor : palette[yAxisTitleColor % palette.length]\n    })) : null, _.get(y2Axis, 'axis', null), _.get(y2Axis, 'title', null), React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top})`\n    }, React.createElement(Lines, {\n      xScale: xScale,\n      yScale: yScale,\n      xField: xAxisField,\n      yFields: yAxisFields,\n      yStackedMax: yAxisMax,\n      data: data || {},\n      isStacked: yAxisIsStacked,\n      colorMap: colorMap,\n      palette: palette,\n      colorOffset: yAxisColorOffset\n    })), yAxisHasPoints ? React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top})`\n    }, React.createElement(Points, {\n      xScale: xScale,\n      yScale: yScale,\n      xField: xAxisField,\n      yFields: yAxisFields,\n      yStackedMax: yAxisMax,\n      data: data,\n      isStacked: yAxisIsStacked,\n      colorMap: colorMap,\n      palette: palette,\n      colorOffset: yAxisColorOffset\n    })) : null, _.get(y2Axis, 'lines', null), _.get(y2Axis, 'points', null), hasToolTips ? React.createElement(\"g\", {\n      transform: `translate(${margin.left}, ${margin.top})`\n    }, React.createElement(\"rect\", {\n      className: cx('&-invisible'),\n      width: innerWidth,\n      height: innerHeight,\n      onMouseMove: event => {\n        this.handleToolTipHoverZone(event, xPoints);\n      },\n      onMouseOut: () => {\n        this.setState({\n          isHovering: false\n        });\n      }\n    })) : null);\n  }\n}\nLineChart.displayName = 'LineChart';\nLineChart.peek = {\n  description: `The \\`LineChart\\` presents data over time. Currently only dates are supported on the x axis and numeric values on the y. If you need discrete values on the x axis, consider using the \\`BarChart\\` instead.`,\n  categories: ['visualizations', 'charts'],\n  madeFrom: ['ContextMenu', 'ToolTip']\n};\nLineChart.MARGIN = {\n  top: 10,\n  right: 80,\n  bottom: 65,\n  left: 80\n};\nLineChart.propTypes = {\n  /**\n      Appended to the component-specific class names set on the root element.\n  */\n  className: string,\n  /**\n      Height of the chart.\n  */\n  height: number,\n  /**\n      Width of the chart.\n  */\n  width: number,\n  /**\n      An object defining the margins of the chart. These margins will contain\n      the axis and labels.\n  */\n  margin: shape({\n    top: number,\n    right: number,\n    bottom: number,\n    left: number\n  }),\n  /**\n      Data for the chart. E.g.\n           [\n              { x: new Date('2015-01-01') , y: 1 } ,\n              { x: new Date('2015-01-02') , y: 2 } ,\n              { x: new Date('2015-01-03') , y: 3 } ,\n              { x: new Date('2015-01-04') , y: 2 } ,\n              { x: new Date('2015-01-05') , y: 5 } ,\n          ]\n  */\n  data: arrayOf(object),\n  /**\n      An object with human readable names for fields that will be used for\n      legends and tooltips. E.g:\n           {\n              x: 'Date',\n              y: 'Impressions',\n          }\n  */\n  legend: object,\n  /**\n      Controls the visibility of the \\`LoadingMessage\\`.\n  */\n  isLoading: bool,\n  /**\n      Show tool tips on hover.\n  */\n  hasToolTips: bool,\n  /**\n      Show a legend at the bottom of the chart.\n  */\n  hasLegend: bool,\n  /**\n      Takes one of the palettes exported from \\`lucid.chartConstants\\`.\n      Available palettes:\n       - \\`PALETTE_7\\` (default)\n      - \\`PALETTE_30\\`\n      - \\`PALETTE_MONOCHROME_0_5\\`\n      - \\`PALETTE_MONOCHROME_1_5\\`\n      - \\`PALETTE_MONOCHROME_2_5\\`\n      - \\`PALETTE_MONOCHROME_3_5\\`\n      - \\`PALETTE_MONOCHROME_4_5\\`\n      - \\`PALETTE_MONOCHROME_5_5\\`\n      - \\`PALETTE_MONOCHROME_6_5\\`\n  */\n  palette: arrayOf(string),\n  /**\n      You can pass in an object if you want to map fields to\n      \\`lucid.chartConstants\\` or custom colors:\n           {\n              'imps': COLOR_0,\n              'rev': COLOR_3,\n              'clicks': '#abc123',\n          }\n  */\n  colorMap: object,\n  /**\n      The field we should look up your x data by. The data must be valid\n      javascript dates.\n  */\n  xAxisField: string,\n  /**\n      The minimum date the x axis should display. Typically this will be the\n      smallest items from your dataset.\n  */\n  xAxisMin: instanceOf(Date),\n  /**\n      The maximum date the x axis should display. This should almost always be\n      the largest date from your dataset.\n  */\n  xAxisMax: instanceOf(Date),\n  /**\n      An optional function used to format your x axis data. If you don't\n      provide anything, we use the default D3 date variable formatter.\n  */\n  xAxisFormatter: func,\n  /**\n      An optional function used to format your x axis dates in the tooltips.\n  */\n  xAxisTooltipFormatter: func,\n  /**\n      There are some cases where you need to only show a \"sampling\" of ticks on\n      the x axis. This number will control that.\n  */\n  xAxisTickCount: number,\n  /**\n      In some cases xAxisTickCount is not enough and you want to specify\n      exactly where the tick marks should appear on the x axis. This prop takes\n      an array of dates (currently only dates are supported for the x axis).\n      This prop will override the \\`xAxisTickCount\\` prop.\n  */\n  xAxisTicks: arrayOf(instanceOf(Date)),\n  /**\n      Set a title for the x axis.\n  */\n  xAxisTitle: string,\n  /**\n      Set a color for the x axis title. Use the color constants exported off\n      \\`lucid.chartConstants\\`. E.g.:\n       - \\`COLOR_0\\`\n      - \\`COLOR_GOOD\\`\n      - \\`'#123abc'\\` // custom color hex\n       \\`number\\` is supported only for backwards compatability.\n  */\n  xAxisTitleColor: oneOfType([number, string]),\n  /**\n      Determines the orientation of the tick text. This may override what the orient prop\n      tries to determine.\n  */\n  xAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),\n  /**\n      An array of your y axis fields. Typically this will just be a single item\n      unless you need to display multiple lines. The order of the array\n      determines the series order in the chart.\n  */\n  yAxisFields: arrayOf(string),\n  /**\n      The minimum number the y axis should display. Typically this should be\n      \\`0\\`.\n  */\n  yAxisMin: number,\n  /**\n      The maximum number the y axis should display. This should almost always\n      be the largest number from your dataset.\n  */\n  yAxisMax: number,\n  /**\n      An optional function used to format your y axis data. If you don't\n      provide anything, we use the default D3 formatter.\n  */\n  yAxisFormatter: func,\n  /**\n      Stack the y axis data. This is only useful if you have multiple\n      \\`yAxisFields\\`. Stacking will cause the chart to be aggregated by sum.\n  */\n  yAxisIsStacked: bool,\n  /**\n      Display points along with the y axis lines.\n  */\n  yAxisHasPoints: bool,\n  /**\n      There are some cases where you need to only show a \"sampling\" of ticks on\n      the y axis. This number will control that.\n  */\n  yAxisTickCount: number,\n  /**\n      Set a title for the y axis.\n  */\n  yAxisTitle: string,\n  /**\n      Set a color for the y axis title. Use the color constants exported off\n      \\`lucid.chartConstants\\`. E.g.:\n       - \\`COLOR_0\\`\n      - \\`COLOR_GOOD\\`\n      - \\`'#123abc'\\` // custom color hex\n       \\`number\\` is supported only for backwards compatability.\n  */\n  yAxisTitleColor: oneOfType([number, string]),\n  /**\n      An optional function used to format your y axis titles and data in the\n      tooltips. The first value is the name of your y field, the second value\n      is your post-formatted y value, and the third value is your non-formatted\n      y-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n  */\n  yAxisTooltipFormatter: func,\n  /**\n      An optional function used to format data in the tooltips.\n  */\n  yAxisTooltipDataFormatter: func,\n  /**\n      Set the starting index where colors start rotating for points and lines\n      along the y axis.\n  */\n  yAxisColorOffset: number,\n  /**\n      An array of your y2 axis fields. Typically this will just be a single\n      item unless you need to display multiple lines. The order of the array\n      determines the series order in the chart.\n  */\n  y2AxisFields: arrayOf(string),\n  /**\n      The minimum number the y2 axis should display. Typically this should be\n      \\`0\\`.\n  */\n  y2AxisMin: number,\n  /**\n      The maximum number the y2 axis should display. This should almost always\n      be the largest number from your dataset.\n  */\n  y2AxisMax: number,\n  /**\n      An optional function used to format your y2 axis data. If you don't\n      provide anything, we use the default D3 formatter.\n  */\n  y2AxisFormatter: func,\n  /**\n      An optional function used to format data in the tooltips.\n  */\n  y2AxisTooltipDataFormatter: func,\n  /**\n      Stack the y2 axis data. This is only useful if you have multiple\n      \\`y2AxisFields\\`. Stacking will cause the chart to be aggregated by sum.\n  */\n  y2AxisIsStacked: bool,\n  /**\n      Display points along with the y2 axis lines.\n  */\n  y2AxisHasPoints: bool,\n  /**\n      There are some cases where you need to only show a \"sampling\" of ticks on\n      the y2 axis. This number will control that.\n  */\n  y2AxisTickCount: number,\n  /**\n      Set a title for the y2 axis.\n  */\n  y2AxisTitle: string,\n  /**\n      Set a color for the y2 axis title. Use the color constants exported off\n      \\`lucid.chartConstants\\`. E.g.:\n       - \\`COLOR_0\\`\n      - \\`COLOR_GOOD\\`\n      - \\`'#123abc'\\` // custom color hex\n       \\`number\\` is supported only for backwards compatability.\n  */\n  y2AxisTitleColor: oneOfType([number, string]),\n  /**\n      Set the starting index where colors start rotating for points and lines\n      along the y2 axis.\n  */\n  y2AxisColorOffset: number,\n  /**\n      Determines the orientation of the tick text. This may override what the orient prop\n      tries to determine.\n  */\n  yAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal'])\n};\nLineChart.defaultProps = {\n  height: 400,\n  width: 1000,\n  margin: {\n    top: 10,\n    right: 80,\n    bottom: 65,\n    left: 80\n  },\n  hasToolTips: true,\n  hasLegend: false,\n  palette: chartConstants.PALETTE_7,\n  xAxisField: 'x',\n  xAxisFormatter: formatDate,\n  // E.g. \"Mon 06/06/2016 15:46:19\"\n  xAxisTooltipFormatter: d3TimeFormat.timeFormat('%a %x %X'),\n  xAxisTickCount: null,\n  xAxisTicks: undefined,\n  xAxisTitle: null,\n  xAxisTitleColor: '#000',\n  xAxisTextOrientation: 'horizontal',\n  yAxisFields: ['y'],\n  yAxisMin: 0,\n  yAxisIsStacked: false,\n  yAxisHasPoints: true,\n  yAxisTickCount: null,\n  yAxisTitle: null,\n  yAxisTitleColor: '#000',\n  yAxisTooltipFormatter: (yField, yValueFormatted) => `${yField}: ${yValueFormatted}`,\n  yAxisColorOffset: 0,\n  y2AxisFields: [],\n  y2AxisMin: 0,\n  y2AxisIsStacked: false,\n  y2AxisHasPoints: true,\n  y2AxisTickCount: null,\n  y2AxisTitle: null,\n  y2AxisTitleColor: '#000',\n  y2AxisColorOffset: 1,\n  yAxisTextOrientation: 'horizontal'\n};\nLineChart.EmptyStateWrapper = EmptyStateWrapper;\nexport default LineChart;","map":{"version":3,"mappings":"AAAA,OAAOA,CAAC,IAAIC,IAAI,QAAQ,QAAQ;AAChC,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,SAAS,MAAM,YAAY;AAClC,OAAO,KAAKC,OAAO,MAAM,UAAU;AACnC,OAAO,KAAKC,YAAY,MAAM,gBAAgB;AAE9C,SAASC,eAAe,QAAQ,0BAA0B;AAC1D,SAAwBC,QAAQ,QAAmB,4BAA4B;AAC/E,SACCC,WAAW,EACXC,WAAW,EACXC,kBAAkB,EAClBC,UAAU,EACVC,OAAO,QAED,0BAA0B;AACjC,OAAO,KAAKC,cAAc,MAAM,wBAAwB;AACxD,OAAOC,IAAI,MAAM,cAAc;AAC/B,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,MAAM,MAAM,kBAAkB;AACrC,OAAOC,KAAK,MAAM,gBAAgB;AAClC,OAAOC,MAAM,MAAM,kBAAkB;AACrC,SAASC,WAAW,IAAIC,OAAO,QAAQ,oBAAoB;AAC3D,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,iBAAiB,MAAM,wCAAwC;AAEtE,MAAMC,EAAE,GAAGjB,eAAe,CAACkB,IAAI,CAAC,aAAa,CAAC;AAE9C,MAAM;EACLC,OAAO;EACPC,IAAI;EACJC,UAAU;EACVC,MAAM;EACNC,MAAM;EACNC,KAAK;EACLC,MAAM;EACNC,IAAI;EACJC,SAAS;EACTC;AAAK,CACL,GAAG/B,SAAS;AA0Pb;AACA,MAAMgC,eAAe,GAAG,CACvB,WAAW,EACX,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,MAAM,EACN,QAAQ,EACR,WAAW,EACX,aAAa,EACb,WAAW,EACX,SAAS,EACT,UAAU,EACV,YAAY,EACZ,UAAU,EACV,UAAU,EACV,gBAAgB,EAChB,uBAAuB,EACvB,gBAAgB,EAChB,YAAY,EACZ,YAAY,EACZ,iBAAiB,EACjB,sBAAsB,EACtB,aAAa,EACb,UAAU,EACV,UAAU,EACV,gBAAgB,EAChB,gBAAgB,EAChB,gBAAgB,EAChB,gBAAgB,EAChB,YAAY,EACZ,iBAAiB,EACjB,uBAAuB,EACvB,2BAA2B,EAC3B,kBAAkB,EAClB,cAAc,EACd,WAAW,EACX,WAAW,EACX,iBAAiB,EACjB,4BAA4B,EAC5B,iBAAiB,EACjB,iBAAiB,EACjB,iBAAiB,EACjB,aAAa,EACb,kBAAkB,EAClB,mBAAmB,EACnB,sBAAsB,EACtB,YAAY,EACZ,cAAc,CACd;AAYD,MAAMC,SAAU,SAAQlC,KAAK,CAACmC,SAA+C;EAA7EC;;IAsXC,UAAK,GAAG;MACPC,UAAU,EAAE,KAAK;MACjBC,MAAM,EAAEC;KACR;IAID,2BAAsB,GAAG,OAExBC,OAAiB,KACR;MAAA,IAFT;QAAEC,OAAO;QAAEC;MAAM,CAA+C;MAGhE,MAAMJ,MAAM,GAAG5B,OAAO,CACrB8B,OAAO,EACPC,OAAO,GAAGC,MAAM,CAACC,qBAAqB,EAAE,CAACC,IAAI,CAC7C;MACD,IAAI,CAAC,IAAI,CAACC,KAAK,CAACR,UAAU,IAAI,IAAI,CAACQ,KAAK,CAACP,MAAM,KAAKA,MAAM,EAAE;QAC3D,IAAI,CAACQ,QAAQ,CAAC;UACbT,UAAU,EAAE,IAAI;UAChBC,MAAM,EAAE5B,OAAO,CAAC8B,OAAO,EAAEC,OAAO,GAAGC,MAAM,CAACC,qBAAqB,EAAE,CAACC,IAAI;SACtE,CAAC;;IAEJ,CAAC;IAED,iBAAY,GAAG,CACdG,MAAyC,EACzCC,OAA4C,EAC5CC,oBAAwC,EACxCC,MAAwB,KACrB;MACH,MAAM;QACLC,YAAY;QACZC,WAAW;QACXC,eAAe;QACfC,WAAW;QACXC,gBAAgB;QAChBC,OAAO;QACPC,UAAU;QACVC,SAAS;QACTC,IAAI;QACJC,eAAe;QACfC,iBAAiB;QACjBC,QAAQ;QACRC;MAAe,CACf,GAAG,IAAI,CAACC,KAA2B;MAEpC;MACA,MAAMC,IAAI,GAAGd,YAAY,GACxBnD;QACCkE,SAAS,EAAE,aAAchB,MAAM,CAACN,IAAe,GAAGuB,UAAU,KAC3DjB,MAAM,CAACkB,GACR;MAAG,GAEHpE,oBAACY,IAAI;QACJyD,MAAM,EAAC,OAAO;QACdC,KAAK,EAAEtB,OAAO;QACduB,UAAU,EAAEtB,oBAA2B;QACvCuB,SAAS,EAAEnB;MAAe,EACzB,CACC,GACD,IAAI;MAER;MACA,MAAMoB,SAAS,GAAGnB,WAAW,GAC5BtD;QACCkE,SAAS,EAAE,aAAchB,MAAM,CAACN,IAAe,GAAGuB,UAAU,KAC3DjB,MAAM,CAACkB,GACR;MAAG,GAEHpE,oBAACa,SAAS;QACTwD,MAAM,EAAC,OAAO;QACdK,KAAK,EAAExB,MAAM,CAACyB,KAAe;QAC7BC,MAAM,EAAEC,WAAW;QACnBC,KAAK,EAAExB,WAAW;QAClByB,KAAK,EACJjF,CAAC,CAACkF,QAAQ,CAACzB,gBAAgB,CAAC,GACzBA,gBAAgB,GAChBC,OAAO,CAACD,gBAAgB,GAAGC,OAAO,CAACyB,MAAM;MAAC,EAE7C,CACC,GACD,IAAI;MAER,MAAMC,SAAS,GAAG/B,YAAY,GAC7BnD;QAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAc,KAAKM,MAAM,CAACkB,GAAG;MAAG,GACjEpE,oBAACe,KAAK;QACLgC,MAAM,EAAEA,MAAM;QACdoC,MAAM,EAAEnC,OAAO;QACfoC,MAAM,EAAE3B,UAAU;QAClB4B,OAAO,EAAElC,YAAY;QACrBmC,WAAW,EAAE5B,SAAS;QACtBC,IAAI,EAAEA,IAAI,IAAK,EAAU;QACzB4B,SAAS,EAAE3B,eAAe;QAC1B4B,WAAW,EAAE3B,iBAAiB,GAAGT,WAAW,CAAC6B,MAAM;QACnDnB,QAAQ,EAAEA,QAAQ;QAClBN,OAAO,EAAEA;MAAO,EACf,CACC,GACD,IAAI;MAER,MAAMiC,UAAU,GACftC,YAAY,IAAIY,eAAe,GAC9B/D;QAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;MAAG,GACvDpE,oBAACgB,MAAM;QACN+B,MAAM,EAAEA,MAAM;QACdoC,MAAM,EAAEnC,OAAO;QACfoC,MAAM,EAAE3B,UAAU;QAClB4B,OAAO,EAAElC,YAAY;QACrBmC,WAAW,EAAE5B,SAAS;QACtBC,IAAI,EAAEA,IAAI,IAAK,EAAU;QACzB4B,SAAS,EAAE3B,eAAe;QAC1B4B,WAAW,EAAE3B,iBAAiB,GAAGT,WAAW,CAAC6B,MAAM;QACnDnB,QAAQ,EAAEA,QAAQ;QAClBN,OAAO,EAAEA;MAAO,EACf,CACC,GACD,IAAI;MAET,OAAO;QACNkC,KAAK,EAAEjB,SAAS;QAChBkB,KAAK,EAAET,SAAS;QAChBU,MAAM,EAAEH,UAAU;QAClBxB,IAAI,EAAEA;OACN;IACF,CAAC;EAkeF;EAheC4B,MAAM;IACL,MAAM;MACLC,SAAS;MACTlB,MAAM;MACNF,KAAK;MACLxB,MAAM,EAAE6C,cAAc;MACtBpC,IAAI;MACJqC,MAAM;MACNC,SAAS;MACTC,WAAW;MACXC,SAAS;MACT3C,OAAO;MACPM,QAAQ;MAERL,UAAU;MACV2C,cAAc;MACdC,UAAU;MACVC,UAAU;MACVC,eAAe;MACfC,cAAc;MACdC,qBAAqB;MACrBC,QAAQ,GAAGpG,WAAW,CAACqD,IAAW,EAAEF,UAAU,CAAS;MACvDkD,QAAQ,GAAGpG,WAAW,CAACoD,IAAW,EAAEF,UAAU,CAAS;MACvDmD,oBAAoB;MAEpBxD,WAAW;MACXyD,cAAc;MACdC,cAAc;MACdC,cAAc;MACdC,cAAc;MACdC,UAAU;MACVC,eAAe;MACfC,QAAQ;MACRC,qBAAqB;MACrBC,yBAAyB;MACzBC,QAAQ,GAAIP,cAAc,GACvBvG,kBAAkB,CAACmD,IAAW,EAAEP,WAAW,CAAC,GAC5C7C,WAAW,CAACoD,IAAW,EAAEP,WAAW,CAAY;MACnDmE,gBAAgB;MAEhBpE,YAAY;MACZqE,eAAe;MACfC,0BAA0B;MAC1B1D,eAAe;MACfH,eAAe;MACf8D,SAAS;MACThE,SAAS,GAAIP,YAAY,IAAIS,eAAe,GACzCpD,kBAAkB,CAACmD,IAAW,EAAER,YAAY,CAAC,GAC7C5C,WAAW,CAACoD,IAAW,EAAER,YAAY,CAAY;MACpDU,iBAAiB;MACjB8D,oBAAoB;MACpB,GAAGC;IAAY,CACf,GAAG,IAAI,CAAC5D,KAAK;IAEd,MAAM;MAAE3B,UAAU;MAAEC;IAAM,CAAE,GAAG,IAAI,CAACO,KAAK;IAEzC,MAAMK,MAAM,GAAG;MACd,GAAGhB,SAAS,CAAC2F,MAAM;MACnB,GAAG9B;KACH;IAED,MAAM+B,UAAU,GAAGzG,EAAE,CAACyE,SAAS,EAAE,GAAG,CAAC;IAErC,MAAM3B,UAAU,GAAGO,KAAK,GAAGxB,MAAM,CAACN,IAAI,GAAGM,MAAM,CAACyB,KAAK;IACrD,MAAME,WAAW,GAAGD,MAAM,GAAG1B,MAAM,CAACkB,GAAG,GAAGlB,MAAM,CAAC6E,MAAM;IAEvD;;;IAGA,MAAMhF,MAAM,GAAG7C,OAAO,CACpB8H,SAAS,EAAE,CACXC,MAAM,CAAC,CAACvB,QAAQ,EAAEC,QAAQ,CAAC,CAAC,CAC5BuB,KAAK,CAAC,CAAC,CAAC,EAAE/D,UAAU,CAAC,CAAC;IAExB,MAAMgE,eAAe,GAAG3B,cAAc,GACnCA,cAAc,GACdzD,MAAM,CAACwB,UAAU,EAAE;IAEtB,MAAM6D,UAAU,GAAGtI,CAAC,CAACuI,OAAO,CAACjF,WAAW,CAACkF,MAAM,CAACnF,YAAY,CAAC,CAAC;IAE9D;IACA,MAAMoF,SAAS,GAAGzI,CAAC,CAAC0I,MAAM,CACzB7E,IAAI,EACJ,CAAC8E,GAAG,EAAEC,CAAC,KAAI;MACV;MACA;MACA,MAAMC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAAC9F,MAAM,CAAC2F,CAAC,CAACjF,UAAU,CAAQ,CAAQ,CAAC;MAE7D3D,CAAC,CAACgJ,IAAI,CAACV,UAAU,EAAGW,KAAK,IAAI;QAC5BjJ,CAAC,CAACkJ,GAAG,CAACP,GAAG,EAAE,GAAGE,KAAK,MAAMI,KAAK,EAAE,EAAEL,CAAC,CAACK,KAAK,CAAC,CAAC;QAC3CjJ,CAAC,CAACkJ,GAAG,CAACP,GAAG,EAAE,GAAGE,KAAK,IAAI,EAAED,CAAC,CAACjF,UAAU,CAAC,CAAC;MACxC,CAAC,CAAC;MAEF,OAAOgF,GAAG;IACX,CAAC,EACD,EAAE,CACF;IACD,MAAMjG,OAAO,GAAG1C,CAAC,CAACmJ,GAAG,CAACnJ,CAAC,CAACoJ,IAAI,CAACX,SAAS,CAAC,EAAEzI,CAAC,CAACqJ,QAAQ,CAAC;IAEpD;;;IAGA,MAAMhE,MAAM,GAAGjF,OAAO,CACpBkJ,WAAW,EAAE,CACbnB,MAAM,CAAC,CAACd,QAAQ,EAAEG,QAAQ,CAAC,CAAC,CAC5BY,KAAK,CAAC,CAACrD,WAAW,EAAE,CAAC,CAAC,CAAC;IAEzB,MAAMwE,mBAAmB,GAAGxC,cAAc,IAAI1B,MAAM,CAACZ,UAAU,EAAE;IAEjE,MAAM+E,eAAe,GAAGjC,yBAAyB,GAC9CA,yBAAyB,GACzBgC,mBAAmB;IAEtB,MAAME,kBAAkB,GAAG,EAAExC,cAAc,IAAI,CAACD,cAAc,CAAC;IAC/D,MAAM0C,mBAAmB,GAAG1C,cAAc,IAAIC,cAAc;IAE5D;;;IAGA,IAAI0C,MAAM,GAAG,EAAE;IACf,IAAIC,YAAY,GAAyB,IAAI;IAC7C,IAAIC,aAAa,GAAqC,IAAI;IAC1D,IAAIxG,YAAY,EAAE;MACjB,MAAMH,OAAO,GAAG9C,OAAO,CACrBkJ,WAAW,EAAE,CACbnB,MAAM,CAAC,CAACP,SAAS,EAAEhE,SAAS,CAAC,CAAC,CAC9BwE,KAAK,CAAC,CAACrD,WAAW,EAAE,CAAC,CAAC,CAAC;MAEzB,MAAM5B,oBAAoB,GAAGuE,eAAe,GACzCA,eAAe,GACfxE,OAAO,GACPA,OAAO,CAACuB,UAAU,EAAE,GACnBzE,CAAC,CAAC8J,QAA+B;MAErC,MAAMC,gBAAgB,GAAGpC,0BAA0B,GAChDA,0BAA0B,GAC1BxE,oBAAoB;MAEvB,MAAM6G,oBAAoB,GAAG/F,eAAe,IAAIH,eAAe;MAC/D,MAAMmG,mBAAmB,GAAG,EAAEnG,eAAe,IAAI,CAACG,eAAe,CAAC;MAElE0F,MAAM,GAAG,IAAI,CAACO,YAAY,CAACjH,MAAM,EAAEC,OAAO,EAAEC,oBAAoB,EAAEC,MAAM,CAAC;MAEzEwG,YAAY,GAAG5J,CAAC,CAACmJ,GAAG,CAAC9F,YAAY,EAAE,CAAC4F,KAAK,EAAEkB,KAAK,KAC/CjK,oBAACc,MAAM,CAACoJ,IAAI;QACXC,GAAG,EAAEF,KAAK;QACVG,QAAQ,EAAEN,oBAAoB;QAC9BO,OAAO,EAAEN,mBAAmB;QAC5BhF,KAAK,EAAEjF,CAAC,CAACwK,GAAG,CACXxG,QAAQ,EACRiF,KAAK,EACLvF,OAAO,CACNK,iBAAiB,GAAGoG,KAAK,GAAI7G,WAAW,CAAC6B,MAAM,GAAGzB,OAAO,CAACyB,MAAO,CACjE,CACD;QACDsF,SAAS,EACRxG,eAAe,GAAGF,iBAAiB,GAAGoG,KAAK,GAAG7G,WAAW,CAAC6B,MAAM,GAAG;MAAC,GAGpEnF,CAAC,CAACwK,GAAG,CAACtE,MAAM,EAAE+C,KAAK,EAAEA,KAAK,CAAC,CAE7B,CAAC;MAEFY,aAAa,GAAG7J,CAAC,CAACmJ,GAAG,CAAC9F,YAAY,EAAE,CAAC4F,KAAK,EAAEkB,KAAK,KAChD,CAACnK,CAAC,CAAC0K,KAAK,CAAC1K,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAEjG,MAAM,GAAG,KAAK,GAAGyG,KAAK,CAAC,CAAC,GACjD/I,oBAACc,MAAM,CAACoJ,IAAI;QACXC,GAAG,EAAEF,KAAK;QACVG,QAAQ,EAAEN,oBAAoB;QAC9BO,OAAO,EAAEN,mBAAmB;QAC5BhF,KAAK,EAAEjF,CAAC,CAACwK,GAAG,CACXxG,QAAQ,EACRiF,KAAK,EACLvF,OAAO,CACNK,iBAAiB,GAChBoG,KAAK,GACJ7G,WAAW,CAAC6B,MAAM,GAAGzB,OAAO,CAACyB,MAAO,CACtC,CACD;QACDsF,SAAS,EACRxG,eAAe,GACZF,iBAAiB,GAAGoG,KAAK,GAAG7G,WAAW,CAAC6B,MAAM,GAC9C;MAAC,GAGJmC,qBAAqB,CACrBtH,CAAC,CAACwK,GAAG,CAACtE,MAAM,EAAE+C,KAAK,EAAEA,KAAK,CAAC,EAC3Bc,gBAAgB,CAAC/J,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAEjG,MAAM,GAAG,KAAK,GAAGyG,KAAK,CAAC,CAAC,EAC1DjJ,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAEjG,MAAM,GAAG,KAAK,GAAGyG,KAAK,CAAC,CACxC,CACY,GACX,IAAI,CACR;;IAGF,IAAIjJ,CAAC,CAAC2K,OAAO,CAAC9G,IAAI,CAAC,IAAIe,KAAK,GAAG,CAAC,IAAIE,MAAM,GAAG,CAAC,IAAIqB,SAAS,EAAE;MAC5D,MAAMyE,iBAAiB,GAAGrK,QAAQ,CACjC,IAAI,CAAC2D,KAAK,EACV9B,SAAS,CAACd,iBAAiB,CAC3B,IAAIpB,oBAACkC,SAAS,CAACd,iBAAiB;QAACuJ,KAAK,EAAC;MAAmB,EAAG;MAC9D,MAAMC,sBAAsB,GAAG9K,CAAC,CAACwK,GAAG,CAACI,iBAAiB,EAAE,OAAO,EAAE,EAAE,CAAC;MACpE,MAAMG,yBAAyB,GAAG/K,CAAC,CAACwK,GAAG,CACtCM,sBAAsB,EACtB,UAAU,EACV,EAAE,CACF;MAED,OACC5K,oBAACoB,iBAAiB;QAAA,GACbwJ,sBAAsB;QAC1BH,OAAO,EAAE3K,CAAC,CAAC2K,OAAO,CAAC9G,IAAI,CAAC;QACxBsC,SAAS,EAAEA;MAAS,GAEnB4E,yBAAyB,EAC1B7K;QAAA,GACMD,IAAI,CAAC6H,YAAY,EAAE3F,eAAe,CAAS;QAChD6D,SAAS,EAAEgC,UAAU;QACrBpD,KAAK,EAAEA,KAAK;QACZE,MAAM,EAAEA;MAAM,GAGd5E;QAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;MAAG,GACvDpE,oBAACY,IAAI;QACJyD,MAAM,EAAC,MAAM;QACbC,KAAK,EAAEa,MAAM;QACbZ,UAAU,EAAEsC;MAAqB,EAChC,CACC,EAEJ7G;QACCkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAClCiC,WAAW,GAAG3B,MAAM,CAACkB,GACtB;MAAG,GAEHpE,oBAACY,IAAI;QACJyD,MAAM,EAAC,QAAQ;QACfC,KAAK,EAAEvB,MAAM;QACbwB,UAAU,EAAE4D;MAAsB,EACjC,CACC,CACC,CACa;;IAItB,OACCnI;MAAA,GACMD,IAAI,CAAC6H,YAAY,EAAE3F,eAAe,CAAS;MAChD6D,SAAS,EAAEgC,UAAU;MACrBpD,KAAK,EAAEA,KAAK;MACZE,MAAM,EAAEA;IAAM,GAGd5E;MAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;IAAG,GACtD8B,WAAW,IAAI7D,UAAU,IAAI,CAACvC,CAAC,CAAC0K,KAAK,CAAClI,MAAM,CAAC,GAC7CtC,oBAACkB,OAAO;MACP4J,OAAO,EAAE,IAAI;MACbC,UAAU,EAAE,IAAI;MAChBC,cAAc,EAAC,MAAM;MACrBC,SAAS,EACP3I,MAA4B,GAAG6B,UAAU,GAAG,IAAI,GAC9C,OAAO,GACN7B,MAA4B,GAAG6B,UAAU,GAAG,IAAI,GACjD,KAAK,GACL;IAAQ,GAGZnE,oBAACkB,OAAO,CAACgK,MAAM;MAACC,WAAW,EAAC;IAAG,GAC9BnL;MACC8F,SAAS,EAAEzE,EAAE,CAAC,gBAAgB,CAAC;MAC/BqH,CAAC,EAAE,IAAIpG,MAAM,OAAOA,MAAM,IAAIuC,WAAW;IAAE,EAC1C,CACc,EACjB7E,oBAACkB,OAAO,CAACyJ,KAAK,QACZlE,qBAAqB,CAAC3G,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAE,GAAGjG,MAAM,IAAI,CAAC,CAAC,CACxC,EAChBtC,oBAACkB,OAAO,CAACkK,IAAI,QACZpL,oBAACc,MAAM;MAACuK,UAAU,EAAE,KAAK;MAAEC,UAAU,EAAEvE;IAAc,GACnDjH,CAAC,CAACmJ,GAAG,CAAC7F,WAAW,EAAE,CAAC2F,KAAK,EAAEkB,KAAK,KAChC,CAACnK,CAAC,CAAC0K,KAAK,CAAC1K,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAEjG,MAAM,GAAG,KAAK,GAAGyG,KAAK,CAAC,CAAC,GACjD/I,oBAACc,MAAM,CAACoJ,IAAI;MACXC,GAAG,EAAEF,KAAK;MACVG,QAAQ,EAAEZ,mBAAmB;MAC7Ba,OAAO,EAAEd,kBAAkB;MAC3BxE,KAAK,EAAEjF,CAAC,CAACwK,GAAG,CACXxG,QAAQ,EACRiF,KAAK,EACLvF,OAAO,CAAC,CAACyG,KAAK,GAAG1C,gBAAgB,IAAI/D,OAAO,CAACyB,MAAM,CAAC,CACpD;MACDsF,SAAS,EACRzD,cAAc,GAAGmD,KAAK,GAAG1C,gBAAgB,GAAG;IAAC,GAG7CH,qBAAqB,CACrBtH,CAAC,CAACwK,GAAG,CAACtE,MAAM,EAAE+C,KAAK,EAAEA,KAAK,CAAC,EAC3BO,eAAe,CACdxJ,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAEjG,MAAM,GAAG,KAAK,GAAGyG,KAAK,CAAC,CACxC,EACDjJ,CAAC,CAACwK,GAAG,CAAC/B,SAAS,EAAEjG,MAAM,GAAG,KAAK,GAAGyG,KAAK,CAAC,CACxC,CACY,GACX,IAAI,CACR,EACAY,aAAa,CACN,CACK,CACN,GACP,IAAI,CACL,EAGJ3J;MAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKiC,WAAW,GAAG3B,MAAM,CAACkB,GAAG;IAAG,GACrEpE,oBAACY,IAAI;MACJyD,MAAM,EAAC,QAAQ;MACfC,KAAK,EAAEvB,MAAM;MACbwI,aAAa,EAAE,CAAC;MAChBhH,UAAU,EAAE4D,eAAsB;MAClC3D,SAAS,EAAE4B,cAAc;MACzBoF,KAAK,EAAEnF,UAAU;MACjBoF,eAAe,EAAE7E;IAAoB,EACpC,EAGDT,SAAS,GACTnG,oBAACmB,WAAW;MACXuK,SAAS,EAAC,MAAM;MAChBT,SAAS,EAAC,QAAQ;MAClBU,cAAc,EACb,CAACzI,MAAM,CAAC6E,MAAM,GAAG,CAAC,GAAGjH,MAAM,CAAC8K,MAAM,GAAG,CAAC,IACtC,CAAC,CAAC,CAAC;IAAmD,GAGvD5L,oBAACmB,WAAW,CAAC+J,MAAM;MAACC,WAAW,EAAC;IAAG,GAClCnL;MACC8F,SAAS,EAAEzE,EAAE,CAAC,aAAa,CAAC;MAC5BqD,KAAK,EAAEP,UAAU;MACjBS,MAAM,EAAE1B,MAAM,CAAC6E;IAAM,EACpB,CACkB,EACrB/H,oBAACmB,WAAW,CAAC0K,MAAM;MAAC/F,SAAS,EAAEzE,EAAE,CAAC,oBAAoB;IAAC,GACtDrB,oBAACc,MAAM;MAACuD,MAAM,EAAC;IAAY,GACzBvE,CAAC,CAACmJ,GAAG,CAAC7F,WAAW,EAAE,CAAC2F,KAAK,EAAEkB,KAAK,KAChCjK,oBAACc,MAAM,CAACoJ,IAAI;MACXC,GAAG,EAAEF,KAAK;MACVG,QAAQ,EAAEZ,mBAAmB;MAC7Ba,OAAO,EAAEd,kBAAkB;MAC3BxE,KAAK,EAAEjF,CAAC,CAACwK,GAAG,CACXxG,QAAQ,EACRiF,KAAK,EACLvF,OAAO,CAACyG,KAAK,GAAI1C,gBAAgB,GAAG/D,OAAO,CAACyB,MAAO,CAAC,CACpD;MACDsF,SAAS,EAAEzD,cAAc,GAAGmD,KAAK,GAAG1C,gBAAgB,GAAG;IAAC,GAEvDzH,CAAC,CAACwK,GAAG,CAACtE,MAAM,EAAE+C,KAAK,EAAEA,KAAK,CAAC,CAE7B,CAAC,EACDW,YAAY,CACL,CACW,CACR,GACX,IAAI,CACL,EAGHpD,UAAU,GACVtG;MACCkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG,GAAGS,WAAW;IAAG,GAEnE7E,oBAACa,SAAS;MACTwD,MAAM,EAAC,QAAQ;MACfK,KAAK,EAAEP,UAAU;MACjBS,MAAM,EAAE1B,MAAM,CAAC6E,MAAM;MACrBjD,KAAK,EAAEwB,UAAU;MACjBvB,KAAK,EACJjF,CAAC,CAACkF,QAAQ,CAACuB,eAAe,CAAC,GACxBA,eAAe,GACf/C,OAAO,CAAC+C,eAAe,GAAG/C,OAAO,CAACyB,MAAM;IAAC,EAE5C,CACC,GACD,IAAI,EAGRjF;MAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;IAAG,GACvDpE,oBAACY,IAAI;MACJyD,MAAM,EAAC,MAAM;MACbC,KAAK,EAAEa,MAAM;MACbZ,UAAU,EAAE8E,mBAA0B;MACtC7E,SAAS,EAAEwC,cAAc;MACzByE,eAAe,EAAE9D;IAAoB,EACpC,CACC,EAGHV,UAAU,GACVjH;MAAGkE,SAAS,EAAE,gBAAgBhB,MAAM,CAACkB,GAAG;IAAG,GAC1CpE,oBAACa,SAAS;MACTwD,MAAM,EAAC,MAAM;MACbK,KAAK,EAAExB,MAAM,CAACN,IAAI;MAClBgC,MAAM,EAAEC,WAAW;MACnBC,KAAK,EAAEmC,UAAU;MACjBlC,KAAK,EACJjF,CAAC,CAACkF,QAAQ,CAACkC,eAAe,CAAC,GACxBA,eAAe,GACf1D,OAAO,CAAC0D,eAAe,GAAG1D,OAAO,CAACyB,MAAM;IAAC,EAE5C,CACC,GACD,IAAI,EAGPnF,CAAC,CAACwK,GAAG,CAACb,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,EAG3B3J,CAAC,CAACwK,GAAG,CAACb,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,EAG7BzJ;MAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;IAAG,GACvDpE,oBAACe,KAAK;MACLgC,MAAM,EAAEA,MAAM;MACdoC,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAE3B,UAAU;MAClB4B,OAAO,EAAEjC,WAAW;MACpBkC,WAAW,EAAEgC,QAAQ;MACrB3D,IAAI,EAAEA,IAAI,IAAK,EAAU;MACzB4B,SAAS,EAAEwB,cAAc;MACzBjD,QAAQ,EAAEA,QAAQ;MAClBN,OAAO,EAAEA,OAAO;MAChBgC,WAAW,EAAE+B;IAAgB,EAC5B,CACC,EAGHT,cAAc,GACd9G;MAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;IAAG,GACvDpE,oBAACgB,MAAM;MACN+B,MAAM,EAAEA,MAAM;MACdoC,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAE3B,UAAU;MAClB4B,OAAO,EAAEjC,WAAW;MACpBkC,WAAW,EAAEgC,QAAQ;MACrB3D,IAAI,EAAEA,IAAW;MACjB4B,SAAS,EAAEwB,cAAc;MACzBjD,QAAQ,EAAEA,QAAQ;MAClBN,OAAO,EAAEA,OAAO;MAChBgC,WAAW,EAAE+B;IAAgB,EAC5B,CACC,GACD,IAAI,EAGPzH,CAAC,CAACwK,GAAG,CAACb,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,EAG5B3J,CAAC,CAACwK,GAAG,CAACb,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,EAG7BvD,WAAW,GACXlG;MAAGkE,SAAS,EAAE,aAAahB,MAAM,CAACN,IAAI,KAAKM,MAAM,CAACkB,GAAG;IAAG,GACvDpE;MACC8F,SAAS,EAAEzE,EAAE,CAAC,aAAa,CAAC;MAC5BqD,KAAK,EAAEP,UAAU;MACjBS,MAAM,EAAEC,WAAW;MACnBiH,WAAW,EAAGC,KAAK,IAAI;QACtB,IAAI,CAACC,sBAAsB,CAC1BD,KAGC,EACDvJ,OAAO,CACP;MACF,CAAC;MACDyJ,UAAU,EAAE,MAAK;QAChB,IAAI,CAACnJ,QAAQ,CAAC;UAAET,UAAU,EAAE;QAAK,CAAE,CAAC;MACrC;IAAC,EACA,CACC,GACD,IAAI,CACH;EAER;;AAj9BOH,qBAAW,GAAG,WAAW;AAEzBA,cAAI,GAAG;EACbgK,WAAW,EAAE,8MAA8M;EAC3NC,UAAU,EAAE,CAAC,gBAAgB,EAAE,QAAQ,CAAC;EACxCC,QAAQ,EAAE,CAAC,aAAa,EAAE,SAAS;CACnC;AAEMlK,gBAAM,GAAG;EACfkC,GAAG,EAAE,EAAE;EACPO,KAAK,EAAE,EAAE;EACToD,MAAM,EAAE,EAAE;EACVnF,IAAI,EAAE;CACN;AAEMV,mBAAS,GAAG;EAClB;;;EAGA4D,SAAS,EAAEjE,MAAM;EAEjB;;;EAGA+C,MAAM,EAAElD,MAAM;EAEd;;;EAGAgD,KAAK,EAAEhD,MAAM;EAEb;;;;EAIAwB,MAAM,EAAEtB,KAAK,CAAC;IACbwC,GAAG,EAAE1C,MAAM;IACXiD,KAAK,EAAEjD,MAAM;IACbqG,MAAM,EAAErG,MAAM;IACdkB,IAAI,EAAElB;GACN,CAAC;EAEF;;;;;;;;;;EAWAiC,IAAI,EAAEpC,OAAO,CAACI,MAAM,CAAC;EAErB;;;;;;;;EASAqE,MAAM,EAAErE,MAAM;EAEd;;;EAGAsE,SAAS,EAAEnE,IAAI;EAEf;;;EAGAoE,WAAW,EAAEpE,IAAI;EAEjB;;;EAGAqE,SAAS,EAAErE,IAAI;EAEf;;;;;;;;;;;;;EAcA0B,OAAO,EAAEjC,OAAO,CAACM,MAAM,CAAC;EAExB;;;;;;;;;EAUAiC,QAAQ,EAAEnC,MAAM;EAEhB;;;;EAIA8B,UAAU,EAAE5B,MAAM;EAElB;;;;EAIA6E,QAAQ,EAAEjF,UAAU,CAAC4K,IAAI,CAAC;EAE1B;;;;EAIA1F,QAAQ,EAAElF,UAAU,CAAC4K,IAAI,CAAC;EAE1B;;;;EAIA7F,cAAc,EAAEhF,IAAI;EAEpB;;;EAGAiF,qBAAqB,EAAEjF,IAAI;EAE3B;;;;EAIA4E,cAAc,EAAE1E,MAAM;EAEtB;;;;;;EAMA2E,UAAU,EAAE9E,OAAO,CAACE,UAAU,CAAC4K,IAAI,CAAC,CAAC;EAErC;;;EAGA/F,UAAU,EAAEzE,MAAM;EAElB;;;;;;;;EAUA0E,eAAe,EAAExE,SAAS,CAAC,CAACL,MAAM,EAAEG,MAAM,CAAC,CAAC;EAE5C;;;;EAIA+E,oBAAoB,EAAE5E,KAAK,CAAC,CAAC,UAAU,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;EAEnE;;;;;EAKAoB,WAAW,EAAE7B,OAAO,CAACM,MAAM,CAAC;EAE5B;;;;EAIAsF,QAAQ,EAAEzF,MAAM;EAEhB;;;;EAIA4F,QAAQ,EAAE5F,MAAM;EAEhB;;;;EAIAmF,cAAc,EAAErF,IAAI;EAEpB;;;;EAIAuF,cAAc,EAAEjF,IAAI;EAEpB;;;EAGAgF,cAAc,EAAEhF,IAAI;EAEpB;;;;EAIAkF,cAAc,EAAEtF,MAAM;EAEtB;;;EAGAuF,UAAU,EAAEpF,MAAM;EAElB;;;;;;;;EAUAqF,eAAe,EAAEnF,SAAS,CAAC,CAACL,MAAM,EAAEG,MAAM,CAAC,CAAC;EAE5C;;;;;;EAMAuF,qBAAqB,EAAE5F,IAAI;EAE3B;;;EAGA6F,yBAAyB,EAAE7F,IAAI;EAE/B;;;;EAIA+F,gBAAgB,EAAE7F,MAAM;EAExB;;;;;EAKAyB,YAAY,EAAE5B,OAAO,CAACM,MAAM,CAAC;EAE7B;;;;EAIA6F,SAAS,EAAEhG,MAAM;EAEjB;;;;EAIAgC,SAAS,EAAEhC,MAAM;EAEjB;;;;EAIA8F,eAAe,EAAEhG,IAAI;EAErB;;;EAGAiG,0BAA0B,EAAEjG,IAAI;EAEhC;;;;EAIAoC,eAAe,EAAE9B,IAAI;EAErB;;;EAGAiC,eAAe,EAAEjC,IAAI;EAErB;;;;EAIAuB,eAAe,EAAE3B,MAAM;EAEvB;;;EAGA4B,WAAW,EAAEzB,MAAM;EAEnB;;;;;;;;EAUA0B,gBAAgB,EAAExB,SAAS,CAAC,CAACL,MAAM,EAAEG,MAAM,CAAC,CAAC;EAE7C;;;;EAIAgC,iBAAiB,EAAEnC,MAAM;EAEzB;;;;EAIAiG,oBAAoB,EAAE3F,KAAK,CAAC,CAAC,UAAU,EAAE,YAAY,EAAE,UAAU,CAAC;CAClE;AAEME,sBAAY,GAAG;EACrB0C,MAAM,EAAE,GAAG;EACXF,KAAK,EAAE,IAAI;EACXxB,MAAM,EAAE;IACPkB,GAAG,EAAE,EAAE;IACPO,KAAK,EAAE,EAAE;IACToD,MAAM,EAAE,EAAE;IACVnF,IAAI,EAAE;GACN;EACDsD,WAAW,EAAE,IAAI;EACjBC,SAAS,EAAE,KAAK;EAChB3C,OAAO,EAAE7C,cAAc,CAAC2L,SAAS;EACjC7I,UAAU,EAAE,GAAG;EACf+C,cAAc,EAAE/F,UAAU;EAC1B;EACAgG,qBAAqB,EAAEtG,YAAY,CAACoM,UAAU,CAAC,UAAU,CAAC;EAC1DnG,cAAc,EAAE,IAAI;EACpBC,UAAU,EAAE9D,SAAS;EACrB+D,UAAU,EAAE,IAAI;EAChBC,eAAe,EAAE,MAAM;EACvBK,oBAAoB,EAAE,YAAY;EAClCxD,WAAW,EAAE,CAAC,GAAG,CAAC;EAClB+D,QAAQ,EAAE,CAAC;EACXJ,cAAc,EAAE,KAAK;EACrBD,cAAc,EAAE,IAAI;EACpBE,cAAc,EAAE,IAAI;EACpBC,UAAU,EAAE,IAAI;EAChBC,eAAe,EAAE,MAAM;EACvBE,qBAAqB,EAAE,CAACoF,MAAc,EAAEC,eAAuB,KAC9D,GAAGD,MAAM,KAAKC,eAAe,EAAE;EAChClF,gBAAgB,EAAE,CAAC;EAEnBpE,YAAY,EAAE,EAAE;EAChBuE,SAAS,EAAE,CAAC;EACZ9D,eAAe,EAAE,KAAK;EACtBG,eAAe,EAAE,IAAI;EACrBV,eAAe,EAAE,IAAI;EACrBC,WAAW,EAAE,IAAI;EACjBC,gBAAgB,EAAE,MAAM;EACxBM,iBAAiB,EAAE,CAAC;EACpB8D,oBAAoB,EAAE;CACtB;AAOMzF,2BAAiB,GAAGd,iBAAiB;AA0lB7C,eAAec,SAAS","names":["_","omit","React","PropTypes","d3Scale","d3TimeFormat","lucidClassNames","getFirst","minByFields","maxByFields","maxByFieldsStacked","formatDate","nearest","chartConstants","Axis","AxisLabel","Legend","Lines","Points","ToolTipDumb","ToolTip","ContextMenu","EmptyStateWrapper","cx","bind","arrayOf","func","instanceOf","number","object","shape","string","bool","oneOfType","oneOf","nonPassThroughs","LineChart","Component","constructor","isHovering","mouseX","undefined","xPoints","clientX","target","getBoundingClientRect","left","state","setState","xScale","y2Scale","y2AxisFinalFormatter","margin","y2AxisFields","yAxisFields","y2AxisTickCount","y2AxisTitle","y2AxisTitleColor","palette","xAxisField","y2AxisMax","data","y2AxisIsStacked","y2AxisColorOffset","colorMap","y2AxisHasPoints","props","axis","transform","innerWidth","top","orient","scale","tickFormat","tickCount","axisTitle","width","right","height","innerHeight","label","color","isString","length","axisLines","yScale","xField","yFields","yStackedMax","isStacked","colorOffset","axisPoints","title","lines","points","render","className","marginOriginal","legend","isLoading","hasToolTips","hasLegend","xAxisTickCount","xAxisTicks","xAxisTitle","xAxisTitleColor","xAxisFormatter","xAxisTooltipFormatter","xAxisMin","xAxisMax","xAxisTextOrientation","yAxisFormatter","yAxisHasPoints","yAxisIsStacked","yAxisTickCount","yAxisTitle","yAxisTitleColor","yAxisMin","yAxisTooltipFormatter","yAxisTooltipDataFormatter","yAxisMax","yAxisColorOffset","y2AxisFormatter","y2AxisTooltipDataFormatter","y2AxisMin","yAxisTextOrientation","passThroughs","MARGIN","svgClasses","bottom","scaleTime","domain","range","xFinalFormatter","allYFields","compact","concat","xPointMap","reduce","acc","d","point","Math","floor","each","field","set","map","keys","toNumber","scaleLinear","yAxisFinalFormatter","yFinalFormatter","yAxisHasLinesFinal","yAxisHasPointsFinal","y2Axis","y2AxisLegend","y2AxisToolTip","identity","y2FinalFormatter","y2AxisHasPointsFinal","y2AxisHasLinesFinal","renderY2Axis","index","Item","key","hasPoint","hasLine","get","pointKind","isNil","isEmpty","emptyStateWrapper","Title","emptyStateWrapperProps","emptyStateWrapperChildren","isLight","isExpanded","flyOutMaxWidth","alignment","Target","elementType","Body","hasBorders","isReversed","outerTickSize","ticks","textOrientation","direction","directonOffset","HEIGHT","FlyOut","onMouseMove","event","handleToolTipHoverZone","onMouseOut","description","categories","madeFrom","Date","PALETTE_7","timeFormat","yField","yValueFormatted"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/LineChart/LineChart.tsx"],"sourcesContent":["import _, { omit } from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\nimport * as d3TimeFormat from 'd3-time-format';\n\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { StandardProps, getFirst, Overwrite } from '../../util/component-types';\nimport {\n\tminByFields,\n\tmaxByFields,\n\tmaxByFieldsStacked,\n\tformatDate,\n\tnearest,\n\tCollection,\n} from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\nimport Axis from '../Axis/Axis';\nimport AxisLabel from '../AxisLabel/AxisLabel';\nimport Legend from '../Legend/Legend';\nimport Lines from '../Lines/Lines';\nimport Points from '../Points/Points';\nimport { ToolTipDumb as ToolTip } from '../ToolTip/ToolTip';\nimport ContextMenu from '../ContextMenu/ContextMenu';\nimport EmptyStateWrapper from '../EmptyStateWrapper/EmptyStateWrapper';\n\nconst cx = lucidClassNames.bind('&-LineChart');\n\nconst {\n\tarrayOf,\n\tfunc,\n\tinstanceOf,\n\tnumber,\n\tobject,\n\tshape,\n\tstring,\n\tbool,\n\toneOfType,\n\toneOf,\n} = PropTypes;\n\ninterface ILineChartMargin {\n\ttop?: number;\n\tright?: number;\n\tbottom?: number;\n\tleft?: number;\n}\n\ntype yFormatterFunction = (y: number) => string;\n\nexport interface ILineChartPropsRaw extends StandardProps {\n\t/** Child components of LineChart */\n\tEmptyStateWrapper?: React.ReactNode;\n\n\t/** Height of the chart. */\n\theight: number;\n\n\t/** Width of the chart. */\n\twidth: number;\n\n\t/**\n\t * \tMargin is an object defining the margins of the chart. These margins will contain\n\t * \tthe axis and labels.\n\t */\n\tmargin: ILineChartMargin;\n\n\t/**\n\t * Data for the chart. E.g.\n\t *\n\t * \t[\n\t * \t\t{ x: new Date('2015-01-01') , y: 1 } ,\n\t * \t\t{ x: new Date('2015-01-02') , y: 2 } ,\n\t * \t\t{ x: new Date('2015-01-03') , y: 3 } ,\n\t * \t\t{ x: new Date('2015-01-04') , y: 2 } ,\n\t * \t\t{ x: new Date('2015-01-05') , y: 5 } ,\n\t * \t]\n\t */\n\t//data?: Array<{ [key: string]: Date | number | undefined }>;\n\tdata?: Collection;\n\t/**\n\t * Legend is an object with human readable names for fields\n\t * that will be used for legends and tooltips. E.g:\n\t * {\n\t * \tx: 'Date',\n\t * \ty: 'Impressions',\n\t * }\n\t */\n\tlegend?: object;\n\n\t/** Controls the visibility of the \\`LoadingMessage\\`. */\n\tisLoading?: boolean;\n\n\t/** Show tool tips on hover. */\n\thasToolTips: boolean;\n\n\t/**Show a legend at the bottom of the chart. */\n\thasLegend: boolean;\n\n\t/**\n\t * Plaette takes one of the palettes exported from \\`lucid.chartConstants\\`.\n\t * Available palettes:\n\n\t\t- \\`PALETTE_7\\` (default)\n\t\t- \\`PALETTE_30\\`\n\t\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t\t- \\`PALETTE_MONOCHROME_6_5\\`\n\t */\n\tpalette: string[];\n\n\t/** colorMap allows you to pass in an object if you want to map fields to\n\t * \\`lucid.chartConstants\\` or custom colors:\n\t  \t\n\t \t{\n\t\t\t'imps': COLOR_0,\n\t\t\t'rev': COLOR_3,\n\t\t\t'clicks': '#abc123',\n\t\t}\n\t*/\n\tcolorMap?: object;\n\n\t/** The field we should look up your x data by.\n\t * The data must be valid javascript dates.\n\t */\n\txAxisField: string;\n\n\t/** The minimum date the x axis should display.\n\t * Typically this will be the smallest items from your dataset.\n\t * */\n\txAxisMin?: Date;\n\n\t/** The maximum date the x axis should display.\n\t * This should almost always be the largest date from your dataset.\n\t * */\n\txAxisMax?: Date;\n\n\t/** An optional function used to format your x axis data.\n\t * If you don't provide anything, we use the default D3 date variable formatter.\n\t * */\n\txAxisFormatter?: (d: Date) => string;\n\n\t/** An optional function used to format your x axis dates in the tooltips.*/\n\txAxisTooltipFormatter: (x: string | number) => string | number;\n\n\t/** There are some cases where you need to only show a \"sampling\" of ticks on the x axis.\n\t * This number will control that.\n\t * */\n\txAxisTickCount: number | null;\n\n\t/** In some cases xAxisTickCount is not enough and you want to specify\n\t * exactly where the tick marks should appear on the x axis.\n\t * This prop takes an array of dates (currently only dates are supported for the x axis).\n\t * This prop will override the \\`xAxisTickCount\\` prop. */\n\txAxisTicks?: Date[];\n\n\t/** Set a title for the x axis. */\n\txAxisTitle?: string | null;\n\n\t/** Set a color for the x axis title. \n\t * Use the color constants exported off `lucid.chartConstants\\`. \n\t * E.g.:\n\t \t- \\`COLOR_0\\`\n\t\t- \\`COLOR_GOOD\\`\n\t\t- \\`'#123abc'\\` // custom color hex \n\n\t\t\\`number\\` is supported only for backwards compatability.\n\t*/\n\txAxisTitleColor: number | string;\n\n\t/** Determines the orientation of the tick text.\n\t * This may override what the orient prop tries to determine.*/\n\txAxisTextOrientation: 'vertical' | 'horizontal' | 'diagonal';\n\n\t/** An array of your y axis fields. Typically this will just be a single item\n\t * unless you need to display multiple lines.\n\t * The order of the array determines the series order in the chart. */\n\n\tyAxisFields: string[];\n\n\t/** The minimum number the y axis should display.\n\t * Typically this should be \\`0\\`. */\n\tyAxisMin: number;\n\n\t/** The maximum number the y axis should display.\n\t * This should almost always be the largest number from your dataset. */\n\tyAxisMax?: number;\n\n\t/** An optional function used to format your y axis data.\n\t * If you don't provide anything, we use the default D3 formatter. */\n\tyAxisFormatter?: yFormatterFunction;\n\n\t/** Stack the y axis data. This is only useful if you have multiple\t\\`yAxisFields\\`.\n\t * Stacking will cause the chart to be aggregated by sum. */\n\tyAxisIsStacked: boolean;\n\n\t/** Display points along with the y axis lines. */\n\tyAxisHasPoints: boolean;\n\n\t/** There are some cases where you need to only show a \"sampling\" of ticks on the y axis.\n\t * This number will determine the number of ticks. */\n\tyAxisTickCount: number | null;\n\n\t/** Set a title for the y axis. */\n\tyAxisTitle: string | null;\n\n\t// \tSet a color for the y axis title. Use the color constants exported off\n\t// \t\\`lucid.chartConstants\\`. E.g.:\n\n\t// \t- \\`COLOR_0\\`\n\t// \t- \\`COLOR_GOOD\\`\n\t// \t- \\`'#123abc'\\` // custom color hex\n\n\t// \t\\`number\\` is supported only for backwards compatability.\n\tyAxisTitleColor: number | string;\n\n\t// \tAn optional function used to format your y axis titles and data in the\n\t// \ttooltips. The first value is the name of your y field, the second value\n\t// \tis your post-formatted y value, and the third value is your non-formatted\n\t// \ty-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n\tyAxisTooltipFormatter: (\n\t\tyField: string,\n\t\tyValueFormatted: string | number,\n\t\tyValue: number\n\t) => string | number;\n\n\t/** An optional function used to format data in the tooltips. */\n\tyAxisTooltipDataFormatter?: (y: number) => string | number;\n\n\t/** Set the starting index where colors start rotating for points and lines along the y axis. */\n\tyAxisColorOffset: number;\n\n\t/**  An array of your y2 axis fields.\n\t * Typically this will just be a single item unless you need to display multiple lines.\n\t * The order of the array determines the series order in the chart. */\n\ty2AxisFields: string[];\n\n\t/** The minimum number the y2 axis should display.\n\t * Typically this should be \\`0\\`. */\n\ty2AxisMin: number;\n\n\t/** The maximum number the y2 axis should display.\n\t * This should almost always be the largest number from your dataset. */\n\ty2AxisMax?: number;\n\n\t/** An optional function used to format your y2 axis data.\n\t * If you don't provide anything, we use the default D3 formatter. */\n\ty2AxisFormatter?: yFormatterFunction;\n\n\t/**\n\t * An optional function used to format data in the tooltips.\n\t */\n\ty2AxisTooltipDataFormatter?: yFormatterFunction;\n\n\t/** Stack the y2 axis data.\n\t * This is only useful if you have multiple\t\\`y2AxisFields\\`.\n\t * Stacking will cause the chart to be aggregated by sum. */\n\ty2AxisIsStacked: boolean;\n\n\t/** Display points along with the y2 axis lines. */\n\ty2AxisHasPoints: boolean;\n\n\t/** There are some cases where you need to only show a \"sampling\" of ticks on the y2 axis.\n\t * This number will control the \"sampling\". */\n\ty2AxisTickCount: number | null;\n\n\t/** Set a title for the y2 axis. */\n\ty2AxisTitle: string | null;\n\n\t/** Set a color for the y2 axis title. \n\t * Use the color constants exported off\t\\`lucid.chartConstants\\`. E.g.:\n\t \t- \\`COLOR_0\\`\n\t \t- \\`COLOR_GOOD\\`\n\t \t- \\`'#123abc'\\` // custom color hex\n\n\t \t\\`number\\` is supported only for backwards compatability. */\n\ty2AxisTitleColor: number | string;\n\n\t/** Set the starting index where colors start rotating for points and lines along the y2 axis. */\n\ty2AxisColorOffset: number;\n\n\t/** Determines the orientation of the tick text.\n\t * This may override what the orient prop tries to determine.  */\n\tyAxisTextOrientation: 'vertical' | 'horizontal' | 'diagonal';\n}\n\n/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */\nconst nonPassThroughs = [\n\t'className',\n\t'height',\n\t'width',\n\t'margin',\n\t'data',\n\t'legend',\n\t'isLoading',\n\t'hasToolTips',\n\t'hasLegend',\n\t'palette',\n\t'colorMap',\n\t'xAxisField',\n\t'xAxisMin',\n\t'xAxisMax',\n\t'xAxisFormatter',\n\t'xAxisTooltipFormatter',\n\t'xAxisTickCount',\n\t'xAxisTicks',\n\t'xAxisTitle',\n\t'xAxisTitleColor',\n\t'xAxisTextOrientation',\n\t'yAxisFields',\n\t'yAxisMin',\n\t'yAxisMax',\n\t'yAxisFormatter',\n\t'yAxisIsStacked',\n\t'yAxisHasPoints',\n\t'yAxisTickCount',\n\t'yAxisTitle',\n\t'yAxisTitleColor',\n\t'yAxisTooltipFormatter',\n\t'yAxisTooltipDataFormatter',\n\t'yAxisColorOffset',\n\t'y2AxisFields',\n\t'y2AxisMin',\n\t'y2AxisMax',\n\t'y2AxisFormatter',\n\t'y2AxisTooltipDataFormatter',\n\t'y2AxisIsStacked',\n\t'y2AxisHasPoints',\n\t'y2AxisTickCount',\n\t'y2AxisTitle',\n\t'y2AxisTitleColor',\n\t'y2AxisColorOffset',\n\t'yAxisTextOrientation',\n\t'callbackId',\n\t'initialState',\n];\n\nexport type ILineChartProps = Overwrite<\n\tReact.SVGProps<SVGGElement>,\n\tILineChartPropsRaw\n>;\n\nexport interface ILineChartState {\n\tisHovering: boolean;\n\tmouseX?: number | string;\n}\n\nclass LineChart extends React.Component<ILineChartProps, ILineChartState, {}> {\n\tstatic displayName = 'LineChart';\n\n\tstatic peek = {\n\t\tdescription: `The \\`LineChart\\` presents data over time. Currently only dates are supported on the x axis and numeric values on the y. If you need discrete values on the x axis, consider using the \\`BarChart\\` instead.`,\n\t\tcategories: ['visualizations', 'charts'],\n\t\tmadeFrom: ['ContextMenu', 'ToolTip'],\n\t};\n\n\tstatic MARGIN = {\n\t\ttop: 10,\n\t\tright: 80,\n\t\tbottom: 65,\n\t\tleft: 80,\n\t};\n\n\tstatic propTypes = {\n\t\t/**\n\t\t\tAppended to the component-specific class names set on the root element.\n\t\t*/\n\t\tclassName: string,\n\n\t\t/**\n\t\t\tHeight of the chart.\n\t\t*/\n\t\theight: number,\n\n\t\t/**\n\t\t\tWidth of the chart.\n\t\t*/\n\t\twidth: number,\n\n\t\t/**\n\t\t\tAn object defining the margins of the chart. These margins will contain\n\t\t\tthe axis and labels.\n\t\t*/\n\t\tmargin: shape({\n\t\t\ttop: number,\n\t\t\tright: number,\n\t\t\tbottom: number,\n\t\t\tleft: number,\n\t\t}),\n\n\t\t/**\n\t\t\tData for the chart. E.g.\n\t\n\t\t\t\t[\n\t\t\t\t\t{ x: new Date('2015-01-01') , y: 1 } ,\n\t\t\t\t\t{ x: new Date('2015-01-02') , y: 2 } ,\n\t\t\t\t\t{ x: new Date('2015-01-03') , y: 3 } ,\n\t\t\t\t\t{ x: new Date('2015-01-04') , y: 2 } ,\n\t\t\t\t\t{ x: new Date('2015-01-05') , y: 5 } ,\n\t\t\t\t]\n\t\t*/\n\t\tdata: arrayOf(object),\n\n\t\t/**\n\t\t\tAn object with human readable names for fields that will be used for\n\t\t\tlegends and tooltips. E.g:\n\t\n\t\t\t\t{\n\t\t\t\t\tx: 'Date',\n\t\t\t\t\ty: 'Impressions',\n\t\t\t\t}\n\t\t*/\n\t\tlegend: object,\n\n\t\t/**\n\t\t\tControls the visibility of the \\`LoadingMessage\\`.\n\t\t*/\n\t\tisLoading: bool,\n\n\t\t/**\n\t\t\tShow tool tips on hover.\n\t\t*/\n\t\thasToolTips: bool,\n\n\t\t/**\n\t\t\tShow a legend at the bottom of the chart.\n\t\t*/\n\t\thasLegend: bool,\n\n\t\t/**\n\t\t\tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\t\t\tAvailable palettes:\n\t\n\t\t\t- \\`PALETTE_7\\` (default)\n\t\t\t- \\`PALETTE_30\\`\n\t\t\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t\t\t- \\`PALETTE_MONOCHROME_6_5\\`\n\t\t*/\n\t\tpalette: arrayOf(string),\n\n\t\t/**\n\t\t\tYou can pass in an object if you want to map fields to\n\t\t\t\\`lucid.chartConstants\\` or custom colors:\n\t\n\t\t\t\t{\n\t\t\t\t\t'imps': COLOR_0,\n\t\t\t\t\t'rev': COLOR_3,\n\t\t\t\t\t'clicks': '#abc123',\n\t\t\t\t}\n\t\t*/\n\t\tcolorMap: object,\n\n\t\t/**\n\t\t\tThe field we should look up your x data by. The data must be valid\n\t\t\tjavascript dates.\n\t\t*/\n\t\txAxisField: string,\n\n\t\t/**\n\t\t\tThe minimum date the x axis should display. Typically this will be the\n\t\t\tsmallest items from your dataset.\n\t\t*/\n\t\txAxisMin: instanceOf(Date),\n\n\t\t/**\n\t\t\tThe maximum date the x axis should display. This should almost always be\n\t\t\tthe largest date from your dataset.\n\t\t*/\n\t\txAxisMax: instanceOf(Date),\n\n\t\t/**\n\t\t\tAn optional function used to format your x axis data. If you don't\n\t\t\tprovide anything, we use the default D3 date variable formatter.\n\t\t*/\n\t\txAxisFormatter: func,\n\n\t\t/**\n\t\t\tAn optional function used to format your x axis dates in the tooltips.\n\t\t*/\n\t\txAxisTooltipFormatter: func,\n\n\t\t/**\n\t\t\tThere are some cases where you need to only show a \"sampling\" of ticks on\n\t\t\tthe x axis. This number will control that.\n\t\t*/\n\t\txAxisTickCount: number,\n\n\t\t/**\n\t\t\tIn some cases xAxisTickCount is not enough and you want to specify\n\t\t\texactly where the tick marks should appear on the x axis. This prop takes\n\t\t\tan array of dates (currently only dates are supported for the x axis).\n\t\t\tThis prop will override the \\`xAxisTickCount\\` prop.\n\t\t*/\n\t\txAxisTicks: arrayOf(instanceOf(Date)),\n\n\t\t/**\n\t\t\tSet a title for the x axis.\n\t\t*/\n\t\txAxisTitle: string,\n\n\t\t/**\n\t\t\tSet a color for the x axis title. Use the color constants exported off\n\t\t\t\\`lucid.chartConstants\\`. E.g.:\n\t\n\t\t\t- \\`COLOR_0\\`\n\t\t\t- \\`COLOR_GOOD\\`\n\t\t\t- \\`'#123abc'\\` // custom color hex\n\t\n\t\t\t\\`number\\` is supported only for backwards compatability.\n\t\t*/\n\t\txAxisTitleColor: oneOfType([number, string]),\n\n\t\t/**\n\t\t\tDetermines the orientation of the tick text. This may override what the orient prop\n\t\t\ttries to determine.\n\t\t*/\n\t\txAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),\n\n\t\t/**\n\t\t\tAn array of your y axis fields. Typically this will just be a single item\n\t\t\tunless you need to display multiple lines. The order of the array\n\t\t\tdetermines the series order in the chart.\n\t\t*/\n\t\tyAxisFields: arrayOf(string),\n\n\t\t/**\n\t\t\tThe minimum number the y axis should display. Typically this should be\n\t\t\t\\`0\\`.\n\t\t*/\n\t\tyAxisMin: number,\n\n\t\t/**\n\t\t\tThe maximum number the y axis should display. This should almost always\n\t\t\tbe the largest number from your dataset.\n\t\t*/\n\t\tyAxisMax: number,\n\n\t\t/**\n\t\t\tAn optional function used to format your y axis data. If you don't\n\t\t\tprovide anything, we use the default D3 formatter.\n\t\t*/\n\t\tyAxisFormatter: func,\n\n\t\t/**\n\t\t\tStack the y axis data. This is only useful if you have multiple\n\t\t\t\\`yAxisFields\\`. Stacking will cause the chart to be aggregated by sum.\n\t\t*/\n\t\tyAxisIsStacked: bool,\n\n\t\t/**\n\t\t\tDisplay points along with the y axis lines.\n\t\t*/\n\t\tyAxisHasPoints: bool,\n\n\t\t/**\n\t\t\tThere are some cases where you need to only show a \"sampling\" of ticks on\n\t\t\tthe y axis. This number will control that.\n\t\t*/\n\t\tyAxisTickCount: number,\n\n\t\t/**\n\t\t\tSet a title for the y axis.\n\t\t*/\n\t\tyAxisTitle: string,\n\n\t\t/**\n\t\t\tSet a color for the y axis title. Use the color constants exported off\n\t\t\t\\`lucid.chartConstants\\`. E.g.:\n\t\n\t\t\t- \\`COLOR_0\\`\n\t\t\t- \\`COLOR_GOOD\\`\n\t\t\t- \\`'#123abc'\\` // custom color hex\n\t\n\t\t\t\\`number\\` is supported only for backwards compatability.\n\t\t*/\n\t\tyAxisTitleColor: oneOfType([number, string]),\n\n\t\t/**\n\t\t\tAn optional function used to format your y axis titles and data in the\n\t\t\ttooltips. The first value is the name of your y field, the second value\n\t\t\tis your post-formatted y value, and the third value is your non-formatted\n\t\t\ty-value.  Signature: \\`(yField, yValueFormatted, yValue) => {}\\`\n\t\t*/\n\t\tyAxisTooltipFormatter: func,\n\n\t\t/**\n\t\t\tAn optional function used to format data in the tooltips.\n\t\t*/\n\t\tyAxisTooltipDataFormatter: func,\n\n\t\t/**\n\t\t\tSet the starting index where colors start rotating for points and lines\n\t\t\talong the y axis.\n\t\t*/\n\t\tyAxisColorOffset: number,\n\n\t\t/**\n\t\t\tAn array of your y2 axis fields. Typically this will just be a single\n\t\t\titem unless you need to display multiple lines. The order of the array\n\t\t\tdetermines the series order in the chart.\n\t\t*/\n\t\ty2AxisFields: arrayOf(string),\n\n\t\t/**\n\t\t\tThe minimum number the y2 axis should display. Typically this should be\n\t\t\t\\`0\\`.\n\t\t*/\n\t\ty2AxisMin: number,\n\n\t\t/**\n\t\t\tThe maximum number the y2 axis should display. This should almost always\n\t\t\tbe the largest number from your dataset.\n\t\t*/\n\t\ty2AxisMax: number,\n\n\t\t/**\n\t\t\tAn optional function used to format your y2 axis data. If you don't\n\t\t\tprovide anything, we use the default D3 formatter.\n\t\t*/\n\t\ty2AxisFormatter: func,\n\n\t\t/**\n\t\t\tAn optional function used to format data in the tooltips.\n\t\t*/\n\t\ty2AxisTooltipDataFormatter: func,\n\n\t\t/**\n\t\t\tStack the y2 axis data. This is only useful if you have multiple\n\t\t\t\\`y2AxisFields\\`. Stacking will cause the chart to be aggregated by sum.\n\t\t*/\n\t\ty2AxisIsStacked: bool,\n\n\t\t/**\n\t\t\tDisplay points along with the y2 axis lines.\n\t\t*/\n\t\ty2AxisHasPoints: bool,\n\n\t\t/**\n\t\t\tThere are some cases where you need to only show a \"sampling\" of ticks on\n\t\t\tthe y2 axis. This number will control that.\n\t\t*/\n\t\ty2AxisTickCount: number,\n\n\t\t/**\n\t\t\tSet a title for the y2 axis.\n\t\t*/\n\t\ty2AxisTitle: string,\n\n\t\t/**\n\t\t\tSet a color for the y2 axis title. Use the color constants exported off\n\t\t\t\\`lucid.chartConstants\\`. E.g.:\n\t\n\t\t\t- \\`COLOR_0\\`\n\t\t\t- \\`COLOR_GOOD\\`\n\t\t\t- \\`'#123abc'\\` // custom color hex\n\t\n\t\t\t\\`number\\` is supported only for backwards compatability.\n\t\t*/\n\t\ty2AxisTitleColor: oneOfType([number, string]),\n\n\t\t/**\n\t\t\tSet the starting index where colors start rotating for points and lines\n\t\t\talong the y2 axis.\n\t\t*/\n\t\ty2AxisColorOffset: number,\n\n\t\t/**\n\t\t\tDetermines the orientation of the tick text. This may override what the orient prop\n\t\t\ttries to determine.\n\t\t*/\n\t\tyAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),\n\t};\n\n\tstatic defaultProps = {\n\t\theight: 400,\n\t\twidth: 1000,\n\t\tmargin: {\n\t\t\ttop: 10,\n\t\t\tright: 80,\n\t\t\tbottom: 65,\n\t\t\tleft: 80,\n\t\t},\n\t\thasToolTips: true,\n\t\thasLegend: false,\n\t\tpalette: chartConstants.PALETTE_7,\n\t\txAxisField: 'x',\n\t\txAxisFormatter: formatDate,\n\t\t// E.g. \"Mon 06/06/2016 15:46:19\"\n\t\txAxisTooltipFormatter: d3TimeFormat.timeFormat('%a %x %X'),\n\t\txAxisTickCount: null,\n\t\txAxisTicks: undefined, // intentionally undefined so that `Axis` can default it correctly\n\t\txAxisTitle: null,\n\t\txAxisTitleColor: '#000',\n\t\txAxisTextOrientation: 'horizontal',\n\t\tyAxisFields: ['y'],\n\t\tyAxisMin: 0,\n\t\tyAxisIsStacked: false,\n\t\tyAxisHasPoints: true,\n\t\tyAxisTickCount: null,\n\t\tyAxisTitle: null,\n\t\tyAxisTitleColor: '#000',\n\t\tyAxisTooltipFormatter: (yField: string, yValueFormatted: number) =>\n\t\t\t`${yField}: ${yValueFormatted}`,\n\t\tyAxisColorOffset: 0,\n\n\t\ty2AxisFields: [],\n\t\ty2AxisMin: 0,\n\t\ty2AxisIsStacked: false,\n\t\ty2AxisHasPoints: true,\n\t\ty2AxisTickCount: null,\n\t\ty2AxisTitle: null,\n\t\ty2AxisTitleColor: '#000',\n\t\ty2AxisColorOffset: 1,\n\t\tyAxisTextOrientation: 'horizontal',\n\t};\n\n\tstate = {\n\t\tisHovering: false,\n\t\tmouseX: undefined,\n\t};\n\n\tstatic EmptyStateWrapper = EmptyStateWrapper;\n\n\thandleToolTipHoverZone = (\n\t\t{ clientX, target }: { clientX: number; target: SVGRectElement },\n\t\txPoints: number[]\n\t): void => {\n\t\tconst mouseX = nearest(\n\t\t\txPoints,\n\t\t\tclientX - target.getBoundingClientRect().left\n\t\t);\n\t\tif (!this.state.isHovering || this.state.mouseX !== mouseX) {\n\t\t\tthis.setState({\n\t\t\t\tisHovering: true,\n\t\t\t\tmouseX: nearest(xPoints, clientX - target.getBoundingClientRect().left),\n\t\t\t});\n\t\t}\n\t};\n\n\trenderY2Axis = (\n\t\txScale: d3Scale.ScaleTime<number, number>,\n\t\ty2Scale: d3Scale.ScaleLinear<number, number>,\n\t\ty2AxisFinalFormatter: yFormatterFunction,\n\t\tmargin: ILineChartMargin\n\t) => {\n\t\tconst {\n\t\t\ty2AxisFields,\n\t\t\tyAxisFields,\n\t\t\ty2AxisTickCount,\n\t\t\ty2AxisTitle,\n\t\t\ty2AxisTitleColor,\n\t\t\tpalette,\n\t\t\txAxisField,\n\t\t\ty2AxisMax,\n\t\t\tdata,\n\t\t\ty2AxisIsStacked,\n\t\t\ty2AxisColorOffset,\n\t\t\tcolorMap,\n\t\t\ty2AxisHasPoints,\n\t\t} = this.props as ILineChartPropsRaw;\n\n\t\t/* y2 axis */\n\t\tconst axis = y2AxisFields ? (\n\t\t\t<g\n\t\t\t\ttransform={`translate(${(margin.left as number) + innerWidth}, ${\n\t\t\t\t\tmargin.top\n\t\t\t\t})`}\n\t\t\t>\n\t\t\t\t<Axis\n\t\t\t\t\torient='right'\n\t\t\t\t\tscale={y2Scale}\n\t\t\t\t\ttickFormat={y2AxisFinalFormatter as any}\n\t\t\t\t\ttickCount={y2AxisTickCount}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t) : null;\n\n\t\t/* y2 axis title */\n\t\tconst axisTitle = y2AxisTitle ? (\n\t\t\t<g\n\t\t\t\ttransform={`translate(${(margin.left as number) + innerWidth}, ${\n\t\t\t\t\tmargin.top\n\t\t\t\t})`}\n\t\t\t>\n\t\t\t\t<AxisLabel\n\t\t\t\t\torient='right'\n\t\t\t\t\twidth={margin.right as number}\n\t\t\t\t\theight={innerHeight}\n\t\t\t\t\tlabel={y2AxisTitle}\n\t\t\t\t\tcolor={\n\t\t\t\t\t\t_.isString(y2AxisTitleColor)\n\t\t\t\t\t\t\t? y2AxisTitleColor\n\t\t\t\t\t\t\t: palette[y2AxisTitleColor % palette.length]\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t) : null;\n\n\t\tconst axisLines = y2AxisFields ? (\n\t\t\t<g transform={`translate(${margin.left as number}, ${margin.top})`}>\n\t\t\t\t<Lines\n\t\t\t\t\txScale={xScale}\n\t\t\t\t\tyScale={y2Scale}\n\t\t\t\t\txField={xAxisField}\n\t\t\t\t\tyFields={y2AxisFields}\n\t\t\t\t\tyStackedMax={y2AxisMax}\n\t\t\t\t\tdata={data || ({} as any)}\n\t\t\t\t\tisStacked={y2AxisIsStacked}\n\t\t\t\t\tcolorOffset={y2AxisColorOffset + yAxisFields.length}\n\t\t\t\t\tcolorMap={colorMap}\n\t\t\t\t\tpalette={palette}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t) : null;\n\n\t\tconst axisPoints =\n\t\t\ty2AxisFields && y2AxisHasPoints ? (\n\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t<Points\n\t\t\t\t\t\txScale={xScale}\n\t\t\t\t\t\tyScale={y2Scale}\n\t\t\t\t\t\txField={xAxisField}\n\t\t\t\t\t\tyFields={y2AxisFields}\n\t\t\t\t\t\tyStackedMax={y2AxisMax}\n\t\t\t\t\t\tdata={data || ({} as any)}\n\t\t\t\t\t\tisStacked={y2AxisIsStacked}\n\t\t\t\t\t\tcolorOffset={y2AxisColorOffset + yAxisFields.length}\n\t\t\t\t\t\tcolorMap={colorMap}\n\t\t\t\t\t\tpalette={palette}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\t\t\t) : null;\n\n\t\treturn {\n\t\t\ttitle: axisTitle,\n\t\t\tlines: axisLines,\n\t\t\tpoints: axisPoints,\n\t\t\taxis: axis,\n\t\t};\n\t};\n\n\trender(): React.ReactNode {\n\t\tconst {\n\t\t\tclassName,\n\t\t\theight,\n\t\t\twidth,\n\t\t\tmargin: marginOriginal,\n\t\t\tdata,\n\t\t\tlegend,\n\t\t\tisLoading,\n\t\t\thasToolTips,\n\t\t\thasLegend,\n\t\t\tpalette,\n\t\t\tcolorMap,\n\n\t\t\txAxisField,\n\t\t\txAxisTickCount,\n\t\t\txAxisTicks,\n\t\t\txAxisTitle,\n\t\t\txAxisTitleColor,\n\t\t\txAxisFormatter,\n\t\t\txAxisTooltipFormatter,\n\t\t\txAxisMin = minByFields(data as any, xAxisField) as Date,\n\t\t\txAxisMax = maxByFields(data as any, xAxisField) as Date,\n\t\t\txAxisTextOrientation,\n\n\t\t\tyAxisFields,\n\t\t\tyAxisFormatter,\n\t\t\tyAxisHasPoints,\n\t\t\tyAxisIsStacked,\n\t\t\tyAxisTickCount,\n\t\t\tyAxisTitle,\n\t\t\tyAxisTitleColor,\n\t\t\tyAxisMin,\n\t\t\tyAxisTooltipFormatter,\n\t\t\tyAxisTooltipDataFormatter,\n\t\t\tyAxisMax = (yAxisIsStacked\n\t\t\t\t? maxByFieldsStacked(data as any, yAxisFields)\n\t\t\t\t: maxByFields(data as any, yAxisFields)) as number,\n\t\t\tyAxisColorOffset,\n\n\t\t\ty2AxisFields,\n\t\t\ty2AxisFormatter,\n\t\t\ty2AxisTooltipDataFormatter,\n\t\t\ty2AxisHasPoints,\n\t\t\ty2AxisIsStacked,\n\t\t\ty2AxisMin,\n\t\t\ty2AxisMax = (y2AxisFields && y2AxisIsStacked\n\t\t\t\t? maxByFieldsStacked(data as any, y2AxisFields)\n\t\t\t\t: maxByFields(data as any, y2AxisFields)) as number,\n\t\t\ty2AxisColorOffset,\n\t\t\tyAxisTextOrientation,\n\t\t\t...passThroughs\n\t\t} = this.props;\n\n\t\tconst { isHovering, mouseX } = this.state;\n\n\t\tconst margin = {\n\t\t\t...LineChart.MARGIN,\n\t\t\t...marginOriginal,\n\t\t};\n\n\t\tconst svgClasses = cx(className, '&');\n\n\t\tconst innerWidth = width - margin.left - margin.right;\n\t\tconst innerHeight = height - margin.top - margin.bottom;\n\n\t\t/**\n\t\t * x axis\n\t\t */\n\t\tconst xScale = d3Scale\n\t\t\t.scaleTime()\n\t\t\t.domain([xAxisMin, xAxisMax])\n\t\t\t.range([0, innerWidth]);\n\n\t\tconst xFinalFormatter = xAxisFormatter\n\t\t\t? xAxisFormatter\n\t\t\t: xScale.tickFormat();\n\n\t\tconst allYFields = _.compact(yAxisFields.concat(y2AxisFields));\n\n\t\t// This is used to map x mouse values back to data points.\n\t\tconst xPointMap = _.reduce(\n\t\t\tdata,\n\t\t\t(acc, d) => {\n\t\t\t\t// `floor` to avoid rounding errors, it doesn't need to be super precise\n\t\t\t\t// since we're dealing with pixels\n\t\t\t\tconst point = Math.floor(xScale(d[xAxisField] as any) as any);\n\n\t\t\t\t_.each(allYFields, (field) => {\n\t\t\t\t\t_.set(acc, `${point}.y.${field}`, d[field]);\n\t\t\t\t\t_.set(acc, `${point}.x`, d[xAxisField]);\n\t\t\t\t});\n\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{}\n\t\t);\n\t\tconst xPoints = _.map(_.keys(xPointMap), _.toNumber);\n\n\t\t/**\n\t\t * y axis\n\t\t */\n\t\tconst yScale = d3Scale\n\t\t\t.scaleLinear()\n\t\t\t.domain([yAxisMin, yAxisMax])\n\t\t\t.range([innerHeight, 0]);\n\n\t\tconst yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();\n\n\t\tconst yFinalFormatter = yAxisTooltipDataFormatter\n\t\t\t? yAxisTooltipDataFormatter\n\t\t\t: yAxisFinalFormatter;\n\n\t\tconst yAxisHasLinesFinal = !(yAxisIsStacked && !yAxisHasPoints);\n\t\tconst yAxisHasPointsFinal = yAxisHasPoints || yAxisIsStacked;\n\n\t\t/**\n\t\t * y2 axis\n\t\t */\n\t\tlet y2Axis = {};\n\t\tlet y2AxisLegend: JSX.Element[] | null = null;\n\t\tlet y2AxisToolTip: Array<JSX.Element | null> | null = null;\n\t\tif (y2AxisFields) {\n\t\t\tconst y2Scale = d3Scale\n\t\t\t\t.scaleLinear()\n\t\t\t\t.domain([y2AxisMin, y2AxisMax])\n\t\t\t\t.range([innerHeight, 0]);\n\n\t\t\tconst y2AxisFinalFormatter = y2AxisFormatter\n\t\t\t\t? y2AxisFormatter\n\t\t\t\t: y2Scale\n\t\t\t\t? y2Scale.tickFormat()\n\t\t\t\t: (_.identity as yFormatterFunction);\n\n\t\t\tconst y2FinalFormatter = y2AxisTooltipDataFormatter\n\t\t\t\t? y2AxisTooltipDataFormatter\n\t\t\t\t: y2AxisFinalFormatter;\n\n\t\t\tconst y2AxisHasPointsFinal = y2AxisHasPoints || y2AxisIsStacked;\n\t\t\tconst y2AxisHasLinesFinal = !(y2AxisIsStacked && !y2AxisHasPoints);\n\n\t\t\ty2Axis = this.renderY2Axis(xScale, y2Scale, y2AxisFinalFormatter, margin);\n\n\t\t\ty2AxisLegend = _.map(y2AxisFields, (field, index) => (\n\t\t\t\t<Legend.Item\n\t\t\t\t\tkey={index}\n\t\t\t\t\thasPoint={y2AxisHasPointsFinal}\n\t\t\t\t\thasLine={y2AxisHasLinesFinal}\n\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\tfield,\n\t\t\t\t\t\tpalette[\n\t\t\t\t\t\t\ty2AxisColorOffset + index + (yAxisFields.length % palette.length)\n\t\t\t\t\t\t]\n\t\t\t\t\t)}\n\t\t\t\t\tpointKind={\n\t\t\t\t\t\ty2AxisHasPoints ? y2AxisColorOffset + index + yAxisFields.length : 1\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t\t{_.get(legend, field, field)}\n\t\t\t\t</Legend.Item>\n\t\t\t));\n\n\t\t\ty2AxisToolTip = _.map(y2AxisFields, (field, index) =>\n\t\t\t\t!_.isNil(_.get(xPointMap, mouseX + '.y.' + field)) ? (\n\t\t\t\t\t<Legend.Item\n\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\thasPoint={y2AxisHasPointsFinal}\n\t\t\t\t\t\thasLine={y2AxisHasLinesFinal}\n\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t\tpalette[\n\t\t\t\t\t\t\t\ty2AxisColorOffset +\n\t\t\t\t\t\t\t\t\tindex +\n\t\t\t\t\t\t\t\t\t(yAxisFields.length % palette.length)\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t)}\n\t\t\t\t\t\tpointKind={\n\t\t\t\t\t\t\ty2AxisHasPoints\n\t\t\t\t\t\t\t\t? y2AxisColorOffset + index + yAxisFields.length\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\t\t\t\t{yAxisTooltipFormatter(\n\t\t\t\t\t\t\t_.get(legend, field, field),\n\t\t\t\t\t\t\ty2FinalFormatter(_.get(xPointMap, mouseX + '.y.' + field)),\n\t\t\t\t\t\t\t_.get(xPointMap, mouseX + '.y.' + field)\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Legend.Item>\n\t\t\t\t) : null\n\t\t\t);\n\t\t}\n\n\t\tif (_.isEmpty(data) || width < 1 || height < 1 || isLoading) {\n\t\t\tconst emptyStateWrapper = getFirst(\n\t\t\t\tthis.props,\n\t\t\t\tLineChart.EmptyStateWrapper\n\t\t\t) || <LineChart.EmptyStateWrapper Title='You have no data.' />;\n\t\t\tconst emptyStateWrapperProps = _.get(emptyStateWrapper, 'props', {});\n\t\t\tconst emptyStateWrapperChildren = _.get(\n\t\t\t\temptyStateWrapperProps,\n\t\t\t\t'children',\n\t\t\t\t[]\n\t\t\t);\n\n\t\t\treturn (\n\t\t\t\t<EmptyStateWrapper\n\t\t\t\t\t{...emptyStateWrapperProps}\n\t\t\t\t\tisEmpty={_.isEmpty(data)}\n\t\t\t\t\tisLoading={isLoading}\n\t\t\t\t>\n\t\t\t\t\t{emptyStateWrapperChildren}\n\t\t\t\t\t<svg\n\t\t\t\t\t\t{...(omit(passThroughs, nonPassThroughs) as any)}\n\t\t\t\t\t\tclassName={svgClasses}\n\t\t\t\t\t\twidth={width}\n\t\t\t\t\t\theight={height}\n\t\t\t\t\t>\n\t\t\t\t\t\t{/* y axis */}\n\t\t\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t\t\t<Axis\n\t\t\t\t\t\t\t\torient='left'\n\t\t\t\t\t\t\t\tscale={yScale}\n\t\t\t\t\t\t\t\ttickFormat={yAxisFormatter as any}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</g>\n\t\t\t\t\t\t{/* x axis */}\n\t\t\t\t\t\t<g\n\t\t\t\t\t\t\ttransform={`translate(${margin.left}, ${\n\t\t\t\t\t\t\t\tinnerHeight + margin.top\n\t\t\t\t\t\t\t})`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Axis\n\t\t\t\t\t\t\t\torient='bottom'\n\t\t\t\t\t\t\t\tscale={xScale}\n\t\t\t\t\t\t\t\ttickFormat={xFinalFormatter as any}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</g>\n\t\t\t\t\t</svg>\n\t\t\t\t</EmptyStateWrapper>\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\t<svg\n\t\t\t\t{...(omit(passThroughs, nonPassThroughs) as any)}\n\t\t\t\tclassName={svgClasses}\n\t\t\t\twidth={width}\n\t\t\t\theight={height}\n\t\t\t>\n\t\t\t\t{/* tooltips */}\n\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t{hasToolTips && isHovering && !_.isNil(mouseX) ? (\n\t\t\t\t\t\t<ToolTip\n\t\t\t\t\t\t\tisLight={true}\n\t\t\t\t\t\t\tisExpanded={true}\n\t\t\t\t\t\t\tflyOutMaxWidth='none'\n\t\t\t\t\t\t\talignment={\n\t\t\t\t\t\t\t\t(mouseX as unknown as number) < innerWidth * 0.15\n\t\t\t\t\t\t\t\t\t? 'start'\n\t\t\t\t\t\t\t\t\t: (mouseX as unknown as number) > innerWidth * 0.85\n\t\t\t\t\t\t\t\t\t? 'end'\n\t\t\t\t\t\t\t\t\t: 'center'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ToolTip.Target elementType='g'>\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\tclassName={cx('&-tooltip-line')}\n\t\t\t\t\t\t\t\t\td={`M${mouseX},0 L${mouseX},${innerHeight}`}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</ToolTip.Target>\n\t\t\t\t\t\t\t<ToolTip.Title>\n\t\t\t\t\t\t\t\t{xAxisTooltipFormatter(_.get(xPointMap, `${mouseX}.x`))}\n\t\t\t\t\t\t\t</ToolTip.Title>\n\t\t\t\t\t\t\t<ToolTip.Body>\n\t\t\t\t\t\t\t\t<Legend hasBorders={false} isReversed={yAxisIsStacked}>\n\t\t\t\t\t\t\t\t\t{_.map(yAxisFields, (field, index) =>\n\t\t\t\t\t\t\t\t\t\t!_.isNil(_.get(xPointMap, mouseX + '.y.' + field)) ? (\n\t\t\t\t\t\t\t\t\t\t\t<Legend.Item\n\t\t\t\t\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\t\t\t\t\thasPoint={yAxisHasPointsFinal}\n\t\t\t\t\t\t\t\t\t\t\t\thasLine={yAxisHasLinesFinal}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpalette[(index + yAxisColorOffset) % palette.length]\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\tpointKind={\n\t\t\t\t\t\t\t\t\t\t\t\t\tyAxisHasPoints ? index + yAxisColorOffset : 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{yAxisTooltipFormatter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t_.get(legend, field, field),\n\t\t\t\t\t\t\t\t\t\t\t\t\tyFinalFormatter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t_.get(xPointMap, mouseX + '.y.' + field)\n\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t_.get(xPointMap, mouseX + '.y.' + field)\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</Legend.Item>\n\t\t\t\t\t\t\t\t\t\t) : null\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t{y2AxisToolTip}\n\t\t\t\t\t\t\t\t</Legend>\n\t\t\t\t\t\t\t</ToolTip.Body>\n\t\t\t\t\t\t</ToolTip>\n\t\t\t\t\t) : null}\n\t\t\t\t</g>\n\n\t\t\t\t{/* x axis */}\n\t\t\t\t<g transform={`translate(${margin.left}, ${innerHeight + margin.top})`}>\n\t\t\t\t\t<Axis\n\t\t\t\t\t\torient='bottom'\n\t\t\t\t\t\tscale={xScale}\n\t\t\t\t\t\touterTickSize={0}\n\t\t\t\t\t\ttickFormat={xFinalFormatter as any}\n\t\t\t\t\t\ttickCount={xAxisTickCount}\n\t\t\t\t\t\tticks={xAxisTicks}\n\t\t\t\t\t\ttextOrientation={xAxisTextOrientation}\n\t\t\t\t\t/>\n\n\t\t\t\t\t{/* legend */}\n\t\t\t\t\t{hasLegend ? (\n\t\t\t\t\t\t<ContextMenu\n\t\t\t\t\t\t\tdirection='down'\n\t\t\t\t\t\t\talignment='center'\n\t\t\t\t\t\t\tdirectonOffset={\n\t\t\t\t\t\t\t\t(margin.bottom / 2 + Legend.HEIGHT / 2) *\n\t\t\t\t\t\t\t\t-1 /* should center the legend in the bottom margin */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<ContextMenu.Target elementType='g'>\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tclassName={cx('&-invisible')}\n\t\t\t\t\t\t\t\t\twidth={innerWidth}\n\t\t\t\t\t\t\t\t\theight={margin.bottom}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</ContextMenu.Target>\n\t\t\t\t\t\t\t<ContextMenu.FlyOut className={cx('&-legend-container')}>\n\t\t\t\t\t\t\t\t<Legend orient='horizontal'>\n\t\t\t\t\t\t\t\t\t{_.map(yAxisFields, (field, index) => (\n\t\t\t\t\t\t\t\t\t\t<Legend.Item\n\t\t\t\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\t\t\t\thasPoint={yAxisHasPointsFinal}\n\t\t\t\t\t\t\t\t\t\t\thasLine={yAxisHasLinesFinal}\n\t\t\t\t\t\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t\t\t\t\t\t\tpalette[index + (yAxisColorOffset % palette.length)]\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\tpointKind={yAxisHasPoints ? index + yAxisColorOffset : 1}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{_.get(legend, field, field)}\n\t\t\t\t\t\t\t\t\t\t</Legend.Item>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t{y2AxisLegend}\n\t\t\t\t\t\t\t\t</Legend>\n\t\t\t\t\t\t\t</ContextMenu.FlyOut>\n\t\t\t\t\t\t</ContextMenu>\n\t\t\t\t\t) : null}\n\t\t\t\t</g>\n\n\t\t\t\t{/* x axis title */}\n\t\t\t\t{xAxisTitle ? (\n\t\t\t\t\t<g\n\t\t\t\t\t\ttransform={`translate(${margin.left}, ${margin.top + innerHeight})`}\n\t\t\t\t\t>\n\t\t\t\t\t\t<AxisLabel\n\t\t\t\t\t\t\torient='bottom'\n\t\t\t\t\t\t\twidth={innerWidth}\n\t\t\t\t\t\t\theight={margin.bottom}\n\t\t\t\t\t\t\tlabel={xAxisTitle}\n\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t_.isString(xAxisTitleColor)\n\t\t\t\t\t\t\t\t\t? xAxisTitleColor\n\t\t\t\t\t\t\t\t\t: palette[xAxisTitleColor % palette.length]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t) : null}\n\n\t\t\t\t{/* y axis */}\n\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t<Axis\n\t\t\t\t\t\torient='left'\n\t\t\t\t\t\tscale={yScale}\n\t\t\t\t\t\ttickFormat={yAxisFinalFormatter as any}\n\t\t\t\t\t\ttickCount={yAxisTickCount}\n\t\t\t\t\t\ttextOrientation={yAxisTextOrientation}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\n\t\t\t\t{/* y axis title */}\n\t\t\t\t{yAxisTitle ? (\n\t\t\t\t\t<g transform={`translate(0, ${margin.top})`}>\n\t\t\t\t\t\t<AxisLabel\n\t\t\t\t\t\t\torient='left'\n\t\t\t\t\t\t\twidth={margin.left}\n\t\t\t\t\t\t\theight={innerHeight}\n\t\t\t\t\t\t\tlabel={yAxisTitle}\n\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t_.isString(yAxisTitleColor)\n\t\t\t\t\t\t\t\t\t? yAxisTitleColor\n\t\t\t\t\t\t\t\t\t: palette[yAxisTitleColor % palette.length]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t) : null}\n\n\t\t\t\t{/* y2 axis */}\n\t\t\t\t{_.get(y2Axis, 'axis', null)}\n\n\t\t\t\t{/* y2 axis title */}\n\t\t\t\t{_.get(y2Axis, 'title', null)}\n\n\t\t\t\t{/* y axis lines */}\n\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t<Lines\n\t\t\t\t\t\txScale={xScale}\n\t\t\t\t\t\tyScale={yScale}\n\t\t\t\t\t\txField={xAxisField}\n\t\t\t\t\t\tyFields={yAxisFields}\n\t\t\t\t\t\tyStackedMax={yAxisMax}\n\t\t\t\t\t\tdata={data || ({} as any)}\n\t\t\t\t\t\tisStacked={yAxisIsStacked}\n\t\t\t\t\t\tcolorMap={colorMap}\n\t\t\t\t\t\tpalette={palette}\n\t\t\t\t\t\tcolorOffset={yAxisColorOffset}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\n\t\t\t\t{/* y axis points */}\n\t\t\t\t{yAxisHasPoints ? (\n\t\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t\t<Points\n\t\t\t\t\t\t\txScale={xScale}\n\t\t\t\t\t\t\tyScale={yScale}\n\t\t\t\t\t\t\txField={xAxisField}\n\t\t\t\t\t\t\tyFields={yAxisFields}\n\t\t\t\t\t\t\tyStackedMax={yAxisMax}\n\t\t\t\t\t\t\tdata={data as any}\n\t\t\t\t\t\t\tisStacked={yAxisIsStacked}\n\t\t\t\t\t\t\tcolorMap={colorMap}\n\t\t\t\t\t\t\tpalette={palette}\n\t\t\t\t\t\t\tcolorOffset={yAxisColorOffset}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t) : null}\n\n\t\t\t\t{/* y2 axis lines */}\n\t\t\t\t{_.get(y2Axis, 'lines', null)}\n\n\t\t\t\t{/* y2 axis points */}\n\t\t\t\t{_.get(y2Axis, 'points', null)}\n\n\t\t\t\t{/* hover capture zone */}\n\t\t\t\t{hasToolTips ? (\n\t\t\t\t\t<g transform={`translate(${margin.left}, ${margin.top})`}>\n\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\tclassName={cx('&-invisible')}\n\t\t\t\t\t\t\twidth={innerWidth}\n\t\t\t\t\t\t\theight={innerHeight}\n\t\t\t\t\t\t\tonMouseMove={(event) => {\n\t\t\t\t\t\t\t\tthis.handleToolTipHoverZone(\n\t\t\t\t\t\t\t\t\tevent as unknown as {\n\t\t\t\t\t\t\t\t\t\tclientX: number;\n\t\t\t\t\t\t\t\t\t\ttarget: SVGRectElement;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\txPoints\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tonMouseOut={() => {\n\t\t\t\t\t\t\t\tthis.setState({ isHovering: false });\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t) : null}\n\t\t\t</svg>\n\t\t);\n\t}\n}\n\nexport default LineChart;\n"]},"metadata":{},"sourceType":"module"}