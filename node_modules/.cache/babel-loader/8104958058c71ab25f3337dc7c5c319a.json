{"ast":null,"code":"import React from 'react';\nimport createReactClass from 'create-react-class';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\nimport { isPlainObjectOrEsModule, omitFunctionPropsDeep } from './state-management';\n/**\n * creates a React component\n */\nexport function createClass(spec) {\n  const {\n    _isPrivate = false,\n    getDefaultProps,\n    statics = {},\n    components = {},\n    reducers = {},\n    selectors = {},\n    initialState = getDefaultProps && omitFunctionPropsDeep(getDefaultProps.apply(spec)),\n    propName = null,\n    propTypes = {},\n    render = () => null,\n    ...restDefinition\n  } = spec;\n  const propTypeValidators = {\n    ...propTypes,\n    ..._.mapValues(spec.components, (componentValue, componentKey) => PropTypes.any /* Props for ${componentValue.displayName || componentKey} */)\n  };\n  // Intentionally keep this object type inferred so it can be passed to\n  // `createReactClass`\n  const newDefinition = {\n    getDefaultProps,\n    ...restDefinition,\n    statics: {\n      ...statics,\n      ...components,\n      _isPrivate,\n      reducers,\n      selectors,\n      initialState,\n      propName\n    },\n    propTypes: propTypeValidators,\n    render\n  };\n  if (!_.isUndefined(newDefinition.statics)) {\n    newDefinition.statics.definition = newDefinition;\n  }\n  const newClass = createReactClass(newDefinition);\n  // This conditional (and breaking change) was introduced to help us move from\n  // legacy React classes to functional components & es6 classes which lack\n  // `getDefaultProps`.\n  if (newClass.getDefaultProps) {\n    newClass.defaultProps = newClass.getDefaultProps();\n    delete newClass.getDefaultProps;\n  }\n  return newClass;\n}\n/**\n * Return all elements matching the specified types\n */\nexport function filterTypes(children, types) {\n  if (types === undefined) return [];\n  return _.filter(React.Children.toArray(children), element => React.isValidElement(element) && _.includes(_.castArray(types), element.type));\n}\n/**\n * Return all elements found in props and children of the specified types\n */\nexport function findTypes(props, types) {\n  if (types === undefined) {\n    return [];\n  }\n  // get elements from props (using types.propName)\n  const elementsFromProps = _.reduce(_.castArray(types), (acc, type) => {\n    return _.isNil(type.propName) ? [] : createElements(type, _.flatten(_.values(_.pick(props, type.propName))));\n  }, []);\n  if (props.children === undefined) {\n    return elementsFromProps;\n  }\n  // return elements from props and elements from children\n  return elementsFromProps.concat(filterTypes(props.children, types));\n}\n// return all elements found in props and children of the specified types\n// export function findTypes<P2>(\n// \tprops: { children?: React.ReactNode },\n// \ttypes?: TypesType<P2>\n// ): React.ReactNode[] {\n// \tif (types === undefined) {\n// \t\treturn [];\n// \t}\n// \t// get elements from props (using types.propName)\n// \tconst elementsFromProps: React.ReactNode[] = _.reduce(\n// \t\t_.castArray<any>(types),\n// \t\t(acc: React.ReactNode[], type): React.ReactNode[] => {\n// \t\t\treturn _.isNil(type.propName)\n// \t\t\t\t? []\n// \t\t\t\t: createElements(\n// \t\t\t\t\t\ttype,\n// \t\t\t\t\t\t_.flatten(_.values(_.pick(props, type.propName)))\n// \t\t\t\t  );\n// \t\t},\n// \t\t[]\n// \t);\n// \tif (props.children === undefined) {\n// \t\treturn elementsFromProps;\n// \t}\n// \t// return elements from props and elements from children\n// \treturn elementsFromProps.concat(filterTypes<P2>(props.children, types));\n// }\n/**\n * Return all elements not matching the specified types\n */\nexport function rejectTypes(children, types) {\n  types = [].concat(types); // coerce to Array\n  return _.reject(React.Children.toArray(children), element => React.isValidElement(element) && _.includes(types, element.type));\n}\n/**\n * Return an array of elements (of the given type) for each of the values\n */\nexport function createElements(type) {\n  let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return _.reduce(values, (elements, typeValue) => {\n    if (React.isValidElement(typeValue) && typeValue.type === type) {\n      return elements.concat(typeValue);\n    } else if (isPlainObjectOrEsModule(typeValue) && !React.isValidElement(typeValue)) {\n      return elements.concat(React.createElement(type, typeValue));\n    } else if (_.isUndefined(typeValue)) {\n      return elements;\n    } else {\n      return elements.concat(React.createElement(type, null, typeValue));\n    }\n  }, []);\n}\n/**\n * Return the first element found in props and children of the specificed type(s)\n */\nexport function getFirst(props, types, defaultValue) {\n  return _.first(findTypes(props, types)) || defaultValue;\n}\n/**\n *  Adds any speicial omitted props to an array\n * @param {string[]} componentProps - an array of the component's props\n * @param {boolean} targetIsDOMElement - true by default; specifies if the top-level element of the component is a plain DOM Element or a React Component Element\n * @return {string[]} the array of component props plus the additional omitted keys\n * */\nexport function addSpecialOmittedProps() {\n  let componentProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let targetIsDOMElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  // We only want to exclude the `callbackId` key when we're omitting props\n  // destined for a DOM element.\n  // We always want to add the `initialState` key\n  // to the list of excluded props.\n  const additionalOmittedKeys = targetIsDOMElement ? ['initialState', 'callbackId'] : ['initialState'];\n  return componentProps.concat(additionalOmittedKeys);\n}\n/**\n * Deprecated from lucid-ui  May 25, 2022 by Noah Yasskin\n * Do not use this method because\n * the import PropTypes from 'prop-types' stopped working as desired\n * component.propTypes does not compile correctly\n * and props in the passThroughs object leak through\n * because they are not being omitted.\n */\n// Omit props defined in propTypes of the given type and any extra keys given\n// in third argument\n//\n// We also have a \"magic\" prop called `callbackId`.\n// It can be used to identify a component in a list\n// without having to create extra closures.\n//\n// It is always excluded from a DOM elements\n//\n// Note: The Partial<P> type is referring to the props passed into the omitProps,\n// not the props defined on the component.\nexport function omitProps(props, component) {\n  let keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let targetIsDOMElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  // We only want to exclude the `callbackId` key when we're omitting props\n  // destined for a DOM element.\n  // We always want to exclude the `initialState` key.\n  const additionalOmittedKeys = targetIsDOMElement ? ['initialState', 'callbackId'] : ['initialState'];\n  // this is to support non-createClass components that we've converted to TypeScript\n  if (component === undefined) {\n    return _.omit(props, keys.concat(additionalOmittedKeys));\n  }\n  return _.omit(props, _.keys(component.propTypes).concat(keys).concat(additionalOmittedKeys));\n}","map":{"version":3,"mappings":"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","names":["React","createReactClass","PropTypes","_","isPlainObjectOrEsModule","omitFunctionPropsDeep","createClass","spec","_isPrivate","getDefaultProps","statics","components","reducers","selectors","initialState","apply","propName","propTypes","render","restDefinition","propTypeValidators","mapValues","componentValue","componentKey","any","newDefinition","isUndefined","definition","newClass","defaultProps","filterTypes","children","types","undefined","filter","Children","toArray","element","isValidElement","includes","castArray","type","findTypes","props","elementsFromProps","reduce","acc","isNil","createElements","flatten","values","pick","concat","rejectTypes","reject","elements","typeValue","createElement","getFirst","defaultValue","first","addSpecialOmittedProps","componentProps","targetIsDOMElement","additionalOmittedKeys","omitProps","component","keys","omit"],"sources":["/home/skanda/node_modules/lucid-ui/src/util/component-types.ts"],"sourcesContent":["import React from 'react';\nimport createReactClass from 'create-react-class';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\nimport {\n\tisPlainObjectOrEsModule,\n\tomitFunctionPropsDeep,\n} from './state-management';\nimport { ValidationMap } from 'prop-types';\n\nexport interface StandardProps {\n\t/** Appended to the component-specific class names set on the root element.\n\t * Value is run through the `classnames` library. */\n\tclassName?: string;\n\n\t/** Any valid React children. */\n\tchildren?: React.ReactNode;\n\n\t/** Styles that are passed through to native control. */\n\tstyle?: React.CSSProperties;\n\n\t/** A \"magic\" prop that's always excluded from DOM elements.\n\t * `callbackId` can be used to identify a component in a list\n\t *  without having to create extra closures. */\n\tcallbackId?: string | number;\n}\n\n// Like `T & U`, but where there are overlapping properties using the type from U only.\n// From https://github.com/pelotom/type-zoo/blob/1a08384d77967ed322356005636fbb8db3c16702/types/index.d.ts#L43\nexport type Overwrite<T, U> = Omit<T, keyof T & keyof U> & U;\n\n// `D`: default props (should be provided when a functional component supports\n// default props)\nexport interface FC<P> extends React.FC<P> {\n\tpeek?: {\n\t\tdescription: string;\n\t\tnotes?: {\n\t\t\toverview: string;\n\t\t\tintendedUse: string;\n\t\t\ttechnicalRecommendations: string;\n\t\t};\n\t\tcategories?: string[];\n\t\textend?: string;\n\t\tmadeFrom?: string[];\n\t};\n\tcategories?: string[];\n\tdescription?: string;\n\tpropTypes?: object;\n\tpropName?: string | string[];\n\t_isPrivate?: boolean;\n}\n\ntype TypesType<P> =\n\t| ICreateClassComponentClass<P>\n\t| Array<ICreateClassComponentClass<P>>\n\t| FC<P>\n\t| Array<FC<P>>\n\t| { propName?: string | string[] }\n\t| any; // TODO: figure out a type that works with inferred functional components\n\ninterface ICreateClassComponentSpec<P, S> extends React.Mixin<P, S> {\n\t_isPrivate?: boolean;\n\tinitialState?: S;\n\tpropName?: string | string[];\n\tpropTypes?: Required<{ [key in keyof P]: any }>;\n\tcomponents?: {\n\t\t[key: string]: ICreateClassComponentClass<{}>;\n\t};\n\tstatics?: {\n\t\tdefinition?: ICreateClassComponentSpec<P, S>;\n\t\t[key: string]: any;\n\t};\n\t// TODO: improve these with a stricter type https://stackoverflow.com/a/54775885/895558\n\treducers?: { [K in keyof P]?: (arg0: S, ...args: any[]) => S };\n\tselectors?: { [K in keyof P]?: (arg0: S) => any };\n\trender?(\n\t\tthis: { props: P } & {\n\t\t\t[k: string]: any;\n\t\t} /* allow for extra properties on `this` to be backward compatible */\n\t): React.ReactNode;\n\n\t// TODO: could this be better handled by adding a third type parameter that\n\t// allows the components to define what the extra class properties would\n\t// be?\n\t[key: string]: any;\n}\n\nexport interface ICreateClassComponentClass<P>\n\textends React.ClassicComponentClass<P> {\n\tpropName?: string | string[];\n}\n\n/**\n * creates a React component\n */\nexport function createClass<P, S = {}>(\n\tspec: ICreateClassComponentSpec<P, S>\n): ICreateClassComponentClass<P> {\n\tconst {\n\t\t_isPrivate = false,\n\t\tgetDefaultProps,\n\t\tstatics = {},\n\t\tcomponents = {},\n\t\treducers = {},\n\t\tselectors = {},\n\t\tinitialState = getDefaultProps &&\n\t\t\tomitFunctionPropsDeep(getDefaultProps.apply(spec)),\n\t\tpropName = null,\n\t\tpropTypes = {},\n\t\trender = (): null => null,\n\t\t...restDefinition\n\t} = spec;\n\n\tconst propTypeValidators: ValidationMap<any> = {\n\t\t...propTypes,\n\t\t..._.mapValues(\n\t\t\tspec.components,\n\t\t\t(componentValue, componentKey): {} =>\n\t\t\t\tPropTypes.any /* Props for ${componentValue.displayName || componentKey} */\n\t\t),\n\t};\n\n\t// Intentionally keep this object type inferred so it can be passed to\n\t// `createReactClass`\n\tconst newDefinition: React.ComponentSpec<P, S> = {\n\t\tgetDefaultProps,\n\t\t...restDefinition,\n\t\tstatics: {\n\t\t\t...statics,\n\t\t\t...components,\n\t\t\t_isPrivate,\n\t\t\treducers,\n\t\t\tselectors,\n\t\t\tinitialState,\n\t\t\tpropName,\n\t\t},\n\t\tpropTypes: propTypeValidators,\n\t\trender,\n\t};\n\n\tif (!_.isUndefined(newDefinition.statics)) {\n\t\tnewDefinition.statics.definition = newDefinition;\n\t}\n\n\tconst newClass = createReactClass(newDefinition);\n\n\t// This conditional (and breaking change) was introduced to help us move from\n\t// legacy React classes to functional components & es6 classes which lack\n\t// `getDefaultProps`.\n\tif (newClass.getDefaultProps) {\n\t\tnewClass.defaultProps = newClass.getDefaultProps();\n\t\tdelete newClass.getDefaultProps;\n\t}\n\n\treturn newClass;\n}\n\n/**\n * Return all elements matching the specified types\n */\nexport function filterTypes<P>(\n\tchildren: React.ReactNode,\n\ttypes?: TypesType<P>\n): React.ReactElement[] {\n\tif (types === undefined) return [];\n\n\treturn _.filter(\n\t\tReact.Children.toArray(children),\n\t\t(element): boolean =>\n\t\t\tReact.isValidElement(element) &&\n\t\t\t_.includes(_.castArray<any>(types), element.type)\n\t) as React.ReactElement[];\n}\n\n/**\n * Return all elements found in props and children of the specified types\n */\nexport function findTypes<P extends { children?: React.ReactNode }>(\n\tprops: P,\n\ttypes?: TypesType<P>\n): React.ReactNode[] {\n\tif (types === undefined) {\n\t\treturn [];\n\t}\n\n\t// get elements from props (using types.propName)\n\tconst elementsFromProps: React.ReactNode[] = _.reduce(\n\t\t_.castArray<any>(types),\n\t\t(acc: React.ReactNode[], type): React.ReactNode[] => {\n\t\t\treturn _.isNil(type.propName)\n\t\t\t\t? []\n\t\t\t\t: createElements(\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\t_.flatten(_.values(_.pick(props, type.propName)))\n\t\t\t\t  );\n\t\t},\n\t\t[]\n\t);\n\n\tif (props.children === undefined) {\n\t\treturn elementsFromProps;\n\t}\n\n\t// return elements from props and elements from children\n\treturn elementsFromProps.concat(filterTypes<P>(props.children, types));\n}\n\n// return all elements found in props and children of the specified types\n// export function findTypes<P2>(\n// \tprops: { children?: React.ReactNode },\n// \ttypes?: TypesType<P2>\n// ): React.ReactNode[] {\n// \tif (types === undefined) {\n// \t\treturn [];\n// \t}\n\n// \t// get elements from props (using types.propName)\n// \tconst elementsFromProps: React.ReactNode[] = _.reduce(\n// \t\t_.castArray<any>(types),\n// \t\t(acc: React.ReactNode[], type): React.ReactNode[] => {\n// \t\t\treturn _.isNil(type.propName)\n// \t\t\t\t? []\n// \t\t\t\t: createElements(\n// \t\t\t\t\t\ttype,\n// \t\t\t\t\t\t_.flatten(_.values(_.pick(props, type.propName)))\n// \t\t\t\t  );\n// \t\t},\n// \t\t[]\n// \t);\n\n// \tif (props.children === undefined) {\n// \t\treturn elementsFromProps;\n// \t}\n\n// \t// return elements from props and elements from children\n// \treturn elementsFromProps.concat(filterTypes<P2>(props.children, types));\n// }\n\n/**\n * Return all elements not matching the specified types\n */\nexport function rejectTypes<P>(\n\tchildren: React.ReactNode,\n\ttypes: TypesType<P> | Array<TypesType<P>>\n): React.ReactNode[] {\n\ttypes = ([] as Array<TypesType<P>>).concat(types); // coerce to Array\n\n\treturn _.reject(\n\t\tReact.Children.toArray(children),\n\t\t(element): boolean =>\n\t\t\tReact.isValidElement(element) && _.includes<any>(types, element.type)\n\t);\n}\n\n/**\n * Return an array of elements (of the given type) for each of the values\n */\nexport function createElements<P>(\n\ttype: ICreateClassComponentClass<P>,\n\tvalues: Array<React.ReactElement<P> | P> = []\n): React.ReactElement[] {\n\treturn _.reduce(\n\t\tvalues,\n\t\t(\n\t\t\telements: Array<React.ReactElement<P>>,\n\t\t\ttypeValue\n\t\t): React.ReactElement[] => {\n\t\t\tif (React.isValidElement(typeValue) && typeValue.type === type) {\n\t\t\t\treturn elements.concat(typeValue);\n\t\t\t} else if (\n\t\t\t\tisPlainObjectOrEsModule(typeValue) &&\n\t\t\t\t!React.isValidElement(typeValue)\n\t\t\t) {\n\t\t\t\treturn elements.concat(React.createElement(type, typeValue));\n\t\t\t} else if (_.isUndefined(typeValue)) {\n\t\t\t\treturn elements;\n\t\t\t} else {\n\t\t\t\treturn elements.concat(React.createElement(type, null, typeValue));\n\t\t\t}\n\t\t},\n\t\t[]\n\t);\n}\n\n/**\n * Return the first element found in props and children of the specificed type(s)\n */\nexport function getFirst<P>(\n\tprops: P,\n\ttypes: TypesType<P> | undefined,\n\tdefaultValue?: React.ReactNode\n): React.ReactNode | null | undefined {\n\treturn _.first(findTypes<P>(props, types)) || defaultValue;\n}\n\n/**\n *  Adds any speicial omitted props to an array\n * @param {string[]} componentProps - an array of the component's props\n * @param {boolean} targetIsDOMElement - true by default; specifies if the top-level element of the component is a plain DOM Element or a React Component Element\n * @return {string[]} the array of component props plus the additional omitted keys\n * */\n\nexport function addSpecialOmittedProps<P>(\n\tcomponentProps: string[] = [],\n\ttargetIsDOMElement: boolean = true\n): { [key: string]: any } {\n\t// We only want to exclude the `callbackId` key when we're omitting props\n\t// destined for a DOM element.\n\t// We always want to add the `initialState` key\n\t// to the list of excluded props.\n\tconst additionalOmittedKeys = targetIsDOMElement\n\t\t? ['initialState', 'callbackId']\n\t\t: ['initialState'];\n\n\treturn componentProps.concat(additionalOmittedKeys);\n}\n\n/**\n * Deprecated from lucid-ui  May 25, 2022 by Noah Yasskin\n * Do not use this method because\n * the import PropTypes from 'prop-types' stopped working as desired\n * component.propTypes does not compile correctly\n * and props in the passThroughs object leak through\n * because they are not being omitted.\n */\n// Omit props defined in propTypes of the given type and any extra keys given\n// in third argument\n//\n// We also have a \"magic\" prop called `callbackId`.\n// It can be used to identify a component in a list\n// without having to create extra closures.\n//\n// It is always excluded from a DOM elements\n//\n// Note: The Partial<P> type is referring to the props passed into the omitProps,\n// not the props defined on the component.\nexport function omitProps<P extends object>(\n\tprops: Partial<P>,\n\tcomponent: ICreateClassComponentClass<P> | undefined,\n\tkeys: string[] = [],\n\ttargetIsDOMElement: boolean = true\n): { [key: string]: any } {\n\t// We only want to exclude the `callbackId` key when we're omitting props\n\t// destined for a DOM element.\n\t// We always want to exclude the `initialState` key.\n\tconst additionalOmittedKeys = targetIsDOMElement\n\t\t? ['initialState', 'callbackId']\n\t\t: ['initialState'];\n\n\t// this is to support non-createClass components that we've converted to TypeScript\n\tif (component === undefined) {\n\t\treturn _.omit(props, keys.concat(additionalOmittedKeys));\n\t}\n\n\treturn _.omit(\n\t\tprops,\n\t\t_.keys(component.propTypes).concat(keys).concat(additionalOmittedKeys)\n\t);\n}\n"]},"metadata":{},"sourceType":"module"}