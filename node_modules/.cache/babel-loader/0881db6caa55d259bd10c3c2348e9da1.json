{"ast":null,"code":"import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { lucidClassNames, uniqueName } from '../../util/style-helpers';\nimport { getFirst, findTypes, rejectTypes } from '../../util/component-types';\nimport reducers from './RadioGroup.reducers';\nimport { buildModernHybridComponent } from '../../util/state-management';\nimport RadioButtonLabeled from '../RadioButtonLabeled/RadioButtonLabeled';\nimport RadioButton from '../RadioButton/RadioButton';\nconst cx = lucidClassNames.bind('&-RadioGroup');\nconst {\n  func,\n  node,\n  number,\n  string,\n  bool\n} = PropTypes;\n/** RadioGroup Label */\nconst RadioGroupLabel = props => null;\nRadioGroupLabel.peek = {\n  description: `Support radio button labels as \\`RadioGroup.Label\\` component which can be provided as a child of a \\`RadioGroup.RadioButton\\` component.`\n};\nRadioGroupLabel.propTypes = {\n  children: node\n};\nRadioGroupLabel.displayName = 'RadioGroup.Label';\nconst defaultProps = {\n  name: uniqueName(`${cx('&')}-`),\n  onSelect: _.noop,\n  selectedIndex: 0,\n  isDisabled: false\n};\n/** TODO: Remove this constant when the component is converted to a functional component */\nconst nonPassThroughs = ['children', 'className', 'name', 'onSelect', 'selectedIndex', 'isDisabled'];\nconst RadioGroup = props => {\n  const {\n    children,\n    className,\n    name,\n    selectedIndex,\n    isDisabled,\n    ...passThroughs\n  } = props;\n  const handleSelected = (event, childProps, isSelected, selectedIndex) => {\n    if (selectedIndex !== undefined) {\n      const clickedRadioButtonProps = _.get(_.map(findTypes(props, RadioGroup.RadioButton), 'props'), selectedIndex);\n      // If the `RadioGroup.RadioButton` child has an `onSelect` prop that is\n      // a function, call that prior to calling the group's `onSelect` prop.\n      if (_.isFunction(clickedRadioButtonProps.onSelect)) {\n        clickedRadioButtonProps.onSelect(isSelected, {\n          event,\n          props: childProps\n        });\n      }\n      props.onSelect(selectedIndex, {\n        event,\n        props: childProps\n      });\n    }\n  };\n  const radioButtonChildProps = _.map(findTypes(props, RadioGroup.RadioButton), 'props');\n  const selectedIndexFromChildren = _.findLastIndex(radioButtonChildProps, {\n    isSelected: true\n  });\n  // If there are any `RadioGroup.RadioButton` children with `isSelected`\n  // equal to true, then the index of the last one should override the\n  // value of the `selectedIndex` prop.\n  const actualSelectedIndex = selectedIndexFromChildren !== -1 ? selectedIndexFromChildren : selectedIndex;\n  return React.createElement(\"span\", {\n    ..._.omit(passThroughs, nonPassThroughs),\n    className: cx('&', className)\n  }, _.map(radioButtonChildProps, (radioButtonChildProp, index) => {\n    const isSelected = actualSelectedIndex === index;\n    return React.createElement(RadioButtonLabeled, {\n      ...radioButtonChildProp,\n      isDisabled: isDisabled || radioButtonChildProp.isDisabled,\n      isSelected: isSelected,\n      key: index,\n      callbackId: index,\n      name: name,\n      onSelect: (isSelected, _ref) => {\n        let {\n          event,\n          props\n        } = _ref;\n        handleSelected(event, props, isSelected, index);\n      },\n      Label: _.get(getFirst(radioButtonChildProp, RadioGroup.Label), 'props', null)\n    });\n  }), rejectTypes(children, RadioGroup.RadioButton));\n};\nRadioGroup.displayName = 'RadioGroup';\nRadioGroup.propTypes = {\n  /**\n              Should be instances of \\`RadioGroup.RadioButton\\` which supports the same\n              props as \\`RadioButton\\`.\n          */\n  children: node,\n  /**\n              Appended to the component-specific class names set on the root element.\n          */\n  className: string,\n  /**\n              Passed along to the \\`RadioGroup.RadioButton\\` children whose \\`name\\`\n              props are ignored.\n          */\n  name: string,\n  /**\n              Called when the user clicks on one of the child radio buttons or when\n              they press the space key while one is in focus, and only called when the\n              component is in the unselected state. \\`props\\` refers to the child\n              \\`RadioButton\\` props.  Signature: \\`(selectedIndex, { event, props }) => {}\\`\n          */\n  onSelect: func,\n  /**\n              Indicates which of the \\`RadioGroup.RadioButton\\` children is currently\n              selected. The index of the last \\`RadioGroup.RadioButton\\` child with\n              \\`isSelected\\` equal to true takes precedence over this prop.\n          */\n  selectedIndex: number,\n  /**\n              Indicates whether all \\`RadioGroup.RadioButton\\` children should appear\n              and act disabled by having a \"greyed out\" palette and ignoring user\n              interactions.\n          */\n  isDisabled: bool\n};\nRadioGroup.peek = {\n  description: `A composite of the \\`RadioButton\\` component and the native \\`label\\` element.`,\n  notes: {\n    overview: `\n\t\t\tA round two-state toggle with a label that explains the action or selection. This is a composite of \\`RadioButton\\` and the native\n\t\t\t\\`label\\` element.\t\t`,\n    intendedUse: `\n\t\t\t- Use radio button to allow users to select one item. Commonly used to select filters or settings. For interactions where users can select mutiple options, use \\`CheckboxLabeled\\`. \n\t\t\t- Use radio buttons for 2-3 options where you want to expose all options.\n\t\t\t- Use \\`SingleSelect\\` for 3-10 options where it is not a priority to expose all options.\n\t\t\t- Use \\`RadioGroup\\` for horizontal lists of options. Use \\`RadioButtonLabeled\\` for vertical lists of options.\n\t`,\n    technicalRecommendations: `\n\t\t\t- Use the styles on the parent container of \\`RadioGroup\\` to ensure only the radio buttons and their labels are clickable.\n\t\t\t- Any props that are not explicitly defined in \\`propTypes\\` are passed to the native radio button control.\n\t\t`\n  },\n  categories: ['controls', 'toggles'],\n  madeFrom: ['RadioButton']\n};\nRadioGroup.defaultProps = defaultProps;\nRadioGroup.reducers = reducers;\nRadioGroup.RadioButton = RadioButton;\nRadioGroup.Label = RadioGroupLabel;\nexport default buildModernHybridComponent(RadioGroup, {\n  reducers\n});\nexport { RadioGroup as RadioGroupDumb };","map":{"version":3,"mappings":"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","names":["_","React","PropTypes","lucidClassNames","uniqueName","getFirst","findTypes","rejectTypes","reducers","buildModernHybridComponent","RadioButtonLabeled","RadioButton","cx","bind","func","node","number","string","bool","RadioGroupLabel","props","peek","description","propTypes","children","displayName","defaultProps","name","onSelect","noop","selectedIndex","isDisabled","nonPassThroughs","RadioGroup","className","passThroughs","handleSelected","event","childProps","isSelected","undefined","clickedRadioButtonProps","get","map","isFunction","radioButtonChildProps","selectedIndexFromChildren","findLastIndex","actualSelectedIndex","omit","radioButtonChildProp","index","key","callbackId","Label","notes","overview","intendedUse","technicalRecommendations","categories","madeFrom","RadioGroupDumb"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/RadioGroup/RadioGroup.tsx"],"sourcesContent":["import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport { lucidClassNames, uniqueName } from '../../util/style-helpers';\nimport {\n\tgetFirst,\n\tfindTypes,\n\trejectTypes,\n\tStandardProps,\n\tOverwrite,\n} from '../../util/component-types';\nimport reducers, { IRadioGroupState } from './RadioGroup.reducers';\nimport { buildModernHybridComponent } from '../../util/state-management';\nimport RadioButtonLabeled, {\n\tIRadioButtonLabeledLabelProps,\n} from '../RadioButtonLabeled/RadioButtonLabeled';\nimport RadioButton, { IRadioButtonProps } from '../RadioButton/RadioButton';\n\nconst cx = lucidClassNames.bind('&-RadioGroup');\n\nconst { func, node, number, string, bool } = PropTypes;\n\n/** RadioGroup Label */\nconst RadioGroupLabel = (props: IRadioButtonLabeledLabelProps) => null;\nRadioGroupLabel.peek = {\n\tdescription: `Support radio button labels as \\`RadioGroup.Label\\` component which can be provided as a child of a \\`RadioGroup.RadioButton\\` component.`,\n};\nRadioGroupLabel.propTypes = {\n\tchildren: node,\n};\nRadioGroupLabel.displayName = 'RadioGroup.Label';\n\n/** RadioGroup */\nexport interface IRadioGroupPropsRaw extends StandardProps {\n\t/**\n\t * Passed along to the \\`RadioGroup.RadioButton\\' children whose \\'name\\'\n\t * props are ignored.\n\t */\n\tname: string;\n\n\t/**\n\t * Called when the user clicks on one of the child radio buttons or when\n\t * they press the space key while one is in focus, and only called when the\n\t * component is in the unselected state. \\`props\\` refers to the child\n\t * \\`RadioButton\\` props.  Signature: \\`(selectedIndex, { event, props }) => {}\\`\n\t */\n\tonSelect: (\n\t\tselectedIndex: string | number,\n\t\t{\n\t\t\tevent,\n\t\t\tprops,\n\t\t}: {\n\t\t\tevent: React.MouseEvent;\n\t\t\tprops: IRadioButtonProps;\n\t\t}\n\t) => void;\n\n\t/**\n\t * Indicates which \\`RadioGroup.RadioButton\\' child is currently\n\t * selected. The index of the last \\`RadioGroup.RadioButton\\` child with\n\t * \\'isSelected\\' equal to true takes precedence over this prop.\n\t */\n\tselectedIndex: number;\n\n\t/**\n\t * Indicates whether all \\`RadioGroup.RadioButton\\' children should appear\n\t * and act disabled by having a \"greyed out\" palette and ignoring user\n\t * interactions.\n\t */\n\tisDisabled: boolean;\n}\n\nexport type IRadioGroupProps = Overwrite<\n\tReact.DetailedHTMLProps<\n\t\tReact.HTMLAttributes<HTMLSpanElement>,\n\t\tHTMLSpanElement\n\t>,\n\tIRadioGroupPropsRaw\n>;\n\nconst defaultProps = {\n\tname: uniqueName(`${cx('&')}-`),\n\tonSelect: _.noop,\n\tselectedIndex: 0,\n\tisDisabled: false,\n};\n\n/** TODO: Remove this constant when the component is converted to a functional component */\nconst nonPassThroughs = [\n\t'children',\n\t'className',\n\t'name',\n\t'onSelect',\n\t'selectedIndex',\n\t'isDisabled',\n];\n\nconst RadioGroup = (props: IRadioGroupProps) => {\n\tconst {\n\t\tchildren,\n\t\tclassName,\n\t\tname,\n\t\tselectedIndex,\n\t\tisDisabled,\n\t\t...passThroughs\n\t} = props;\n\n\tconst handleSelected = (\n\t\tevent: React.MouseEvent<Element, MouseEvent>,\n\t\tchildProps: IRadioButtonProps,\n\t\tisSelected: boolean,\n\t\tselectedIndex: number\n\t) => {\n\t\tif (selectedIndex !== undefined) {\n\t\t\tconst clickedRadioButtonProps = _.get(\n\t\t\t\t_.map(findTypes(props, RadioGroup.RadioButton), 'props'),\n\t\t\t\tselectedIndex\n\t\t\t);\n\t\t\t// If the `RadioGroup.RadioButton` child has an `onSelect` prop that is\n\t\t\t// a function, call that prior to calling the group's `onSelect` prop.\n\n\t\t\tif (_.isFunction(clickedRadioButtonProps.onSelect)) {\n\t\t\t\tclickedRadioButtonProps.onSelect(isSelected, {\n\t\t\t\t\tevent,\n\t\t\t\t\tprops: childProps,\n\t\t\t\t});\n\t\t\t}\n\t\t\tprops.onSelect(selectedIndex, { event, props: childProps });\n\t\t}\n\t};\n\n\tconst radioButtonChildProps = _.map(\n\t\tfindTypes(props, RadioGroup.RadioButton),\n\t\t'props'\n\t);\n\n\tconst selectedIndexFromChildren = _.findLastIndex(radioButtonChildProps, {\n\t\tisSelected: true,\n\t});\n\n\t// If there are any `RadioGroup.RadioButton` children with `isSelected`\n\t// equal to true, then the index of the last one should override the\n\t// value of the `selectedIndex` prop.\n\tconst actualSelectedIndex =\n\t\tselectedIndexFromChildren !== -1\n\t\t\t? selectedIndexFromChildren\n\t\t\t: selectedIndex;\n\n\treturn (\n\t\t<span\n\t\t\t{..._.omit(passThroughs as any, nonPassThroughs)}\n\t\t\tclassName={cx('&', className)}\n\t\t>\n\t\t\t{_.map(radioButtonChildProps, (radioButtonChildProp, index) => {\n\t\t\t\tconst isSelected = actualSelectedIndex === index;\n\n\t\t\t\treturn (\n\t\t\t\t\t<RadioButtonLabeled\n\t\t\t\t\t\t{...radioButtonChildProp}\n\t\t\t\t\t\tisDisabled={isDisabled || radioButtonChildProp.isDisabled}\n\t\t\t\t\t\tisSelected={isSelected}\n\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\tcallbackId={index}\n\t\t\t\t\t\tname={name}\n\t\t\t\t\t\tonSelect={(isSelected, { event, props }) => {\n\t\t\t\t\t\t\thandleSelected(event, props, isSelected, index);\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tLabel={_.get(\n\t\t\t\t\t\t\tgetFirst(radioButtonChildProp, RadioGroup.Label),\n\t\t\t\t\t\t\t'props',\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t)}\n\t\t\t\t\t/>\n\t\t\t\t);\n\t\t\t})}\n\t\t\t{rejectTypes(children, RadioGroup.RadioButton)}\n\t\t</span>\n\t);\n};\n\nRadioGroup.displayName = 'RadioGroup';\n\nRadioGroup.propTypes = {\n\t/**\n    \t\t\tShould be instances of \\`RadioGroup.RadioButton\\` which supports the same\n    \t\t\tprops as \\`RadioButton\\`.\n    \t\t*/\n\tchildren: node,\n\n\t/**\n    \t\t\tAppended to the component-specific class names set on the root element.\n    \t\t*/\n\tclassName: string,\n\n\t/**\n    \t\t\tPassed along to the \\`RadioGroup.RadioButton\\` children whose \\`name\\`\n    \t\t\tprops are ignored.\n    \t\t*/\n\tname: string,\n\n\t/**\n    \t\t\tCalled when the user clicks on one of the child radio buttons or when\n    \t\t\tthey press the space key while one is in focus, and only called when the\n    \t\t\tcomponent is in the unselected state. \\`props\\` refers to the child\n    \t\t\t\\`RadioButton\\` props.  Signature: \\`(selectedIndex, { event, props }) => {}\\`\n    \t\t*/\n\tonSelect: func,\n\n\t/**\n    \t\t\tIndicates which of the \\`RadioGroup.RadioButton\\` children is currently\n    \t\t\tselected. The index of the last \\`RadioGroup.RadioButton\\` child with\n    \t\t\t\\`isSelected\\` equal to true takes precedence over this prop.\n    \t\t*/\n\tselectedIndex: number,\n\n\t/**\n    \t\t\tIndicates whether all \\`RadioGroup.RadioButton\\` children should appear\n    \t\t\tand act disabled by having a \"greyed out\" palette and ignoring user\n    \t\t\tinteractions.\n    \t\t*/\n\tisDisabled: bool,\n};\n\nRadioGroup.peek = {\n\tdescription: `A composite of the \\`RadioButton\\` component and the native \\`label\\` element.`,\n\tnotes: {\n\t\toverview: `\n\t\t\tA round two-state toggle with a label that explains the action or selection. This is a composite of \\`RadioButton\\` and the native\n\t\t\t\\`label\\` element.\t\t`,\n\t\tintendedUse: `\n\t\t\t- Use radio button to allow users to select one item. Commonly used to select filters or settings. For interactions where users can select mutiple options, use \\`CheckboxLabeled\\`. \n\t\t\t- Use radio buttons for 2-3 options where you want to expose all options.\n\t\t\t- Use \\`SingleSelect\\` for 3-10 options where it is not a priority to expose all options.\n\t\t\t- Use \\`RadioGroup\\` for horizontal lists of options. Use \\`RadioButtonLabeled\\` for vertical lists of options.\n\t`,\n\t\ttechnicalRecommendations: `\n\t\t\t- Use the styles on the parent container of \\`RadioGroup\\` to ensure only the radio buttons and their labels are clickable.\n\t\t\t- Any props that are not explicitly defined in \\`propTypes\\` are passed to the native radio button control.\n\t\t`,\n\t},\n\tcategories: ['controls', 'toggles'],\n\tmadeFrom: ['RadioButton'],\n};\n\nRadioGroup.defaultProps = defaultProps;\n\nRadioGroup.reducers = reducers;\n\nRadioGroup.RadioButton = RadioButton;\n\nRadioGroup.Label = RadioGroupLabel;\n\nexport default buildModernHybridComponent<\n\tIRadioGroupProps,\n\tIRadioGroupState,\n\ttypeof RadioGroup\n>(RadioGroup as any, { reducers });\nexport { RadioGroup as RadioGroupDumb };\n"]},"metadata":{},"sourceType":"module"}