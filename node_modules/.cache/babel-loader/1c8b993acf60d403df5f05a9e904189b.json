{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport reducers from './TextField.reducers';\nimport * as KEYCODE from '../../constants/key-code';\nconst cx = lucidClassNames.bind('&-TextField');\nconst {\n  bool,\n  string,\n  func,\n  number,\n  object,\n  oneOfType\n} = PropTypes;\n/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */\nconst nonPassThroughs = ['style', 'isMultiLine', 'isDisabled', 'rows', 'className', 'onChange', 'onBlur', 'onChangeDebounced', 'onKeyDown', 'onSubmit', 'value', 'debounceLevel', 'lazyLevel', 'initialState', 'callbackId', 'children'];\nclass TextField extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      value: this.props.value,\n      isHolding: false,\n      isMounted: false\n    };\n    this.textareaElement = React.createRef();\n    this.inputElement = React.createRef();\n    this.nativeElement = this.props.isMultiLine ? this.textareaElement : this.inputElement;\n    this.handleChangeDebounced = _.debounce((value, _ref) => {\n      let {\n        event,\n        props\n      } = _ref;\n      this.props.onChangeDebounced && this.props.onChangeDebounced(value, {\n        event,\n        props\n      });\n    }, this.props.debounceLevel);\n    this.releaseHold = _.debounce(() => {\n      if (!this.state.isMounted) {\n        return;\n      }\n      this.setState({\n        isHolding: false\n      });\n    }, this.props.lazyLevel);\n    this.updateWhenReady = _.debounce(newValue => {\n      if (!this.state.isMounted) {\n        return;\n      }\n      if (this.state.isHolding) {\n        this.updateWhenReady(newValue);\n      } else if (newValue !== this.state.value) {\n        this.setState({\n          value: newValue\n        });\n      }\n    }, this.props.lazyLevel);\n    this.handleChange = event => {\n      const {\n        onChange,\n        onChangeDebounced\n      } = this.props;\n      const value = _.get(event, 'target.value', '');\n      this.setState({\n        value,\n        isHolding: true\n      });\n      this.releaseHold();\n      onChange && onChange(value, {\n        event,\n        props: this.props\n      });\n      // Also call the debounced handler in case the user wants debounced change\n      // events.\n      if (onChangeDebounced !== _.noop) {\n        event.persist(); // https://facebook.github.io/react/docs/events.html#event-pooling\n        this.handleChangeDebounced(value, {\n          event,\n          props: this.props\n        });\n      }\n    };\n    this.handleBlur = event => {\n      const {\n        onBlur,\n        onChangeDebounced\n      } = this.props;\n      const value = _.get(event, 'target.value', '');\n      if (onChangeDebounced !== _.noop) {\n        this.handleChangeDebounced.flush();\n      }\n      onBlur && onBlur(value, {\n        event,\n        props: this.props\n      });\n    };\n    this.handleKeyDown = event => {\n      const {\n        props,\n        props: {\n          onSubmit,\n          onKeyDown,\n          onChangeDebounced\n        }\n      } = this;\n      const value = _.get(event, 'target.value', '');\n      // If the consumer passed an onKeyDown, we call it\n      if (onKeyDown) {\n        onKeyDown({\n          event,\n          props\n        });\n      }\n      if (event.keyCode === KEYCODE.Enter) {\n        if (onChangeDebounced !== _.noop) {\n          this.handleChangeDebounced.flush();\n        }\n        onSubmit && onSubmit(value, {\n          event,\n          props: this.props\n        });\n      }\n    };\n    this.focus = options => {\n      /* istanbul ignore next */\n      this.nativeElement.current.focus(options);\n    };\n  }\n  UNSAFE_componentWillMount() {\n    this.setState({\n      isMounted: true\n    });\n  }\n  componentWillUnmount() {\n    this.setState({\n      isMounted: false\n    });\n  }\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // Allow consumer to optionally control state\n    if (_.has(nextProps, 'value')) {\n      if (this.state.isHolding) {\n        this.updateWhenReady(nextProps.value);\n      } else {\n        this.setState({\n          value: nextProps.value\n        });\n      }\n    }\n  }\n  render() {\n    const {\n      className,\n      isDisabled,\n      isMultiLine,\n      rows,\n      style,\n      ...passThroughs\n    } = this.props;\n    const {\n      value\n    } = this.state;\n    const finalProps = {\n      ..._.omit(passThroughs, nonPassThroughs),\n      className: cx('&', {\n        '&-is-disabled': isDisabled,\n        '&-is-multi-line': isMultiLine,\n        '&-is-single-line': !isMultiLine\n      }, className),\n      disabled: isDisabled,\n      onChange: this.handleChange,\n      onBlur: this.handleBlur,\n      onKeyDown: this.handleKeyDown,\n      style,\n      rows,\n      value\n    };\n    return isMultiLine ? React.createElement(\"textarea\", {\n      ref: this.textareaElement,\n      ...finalProps\n    }) : React.createElement(\"input\", {\n      type: 'text',\n      ref: this.inputElement,\n      ...finalProps\n    });\n  }\n}\nTextField.displayName = 'TextField';\nTextField.peek = {\n  description: `\\`TextField\\` should cover all your text input needs. It is able to handle single- and multi-line inputs.`,\n  categories: ['controls', 'text']\n};\nTextField.propTypes = {\n  /**\n      Styles that are passed through to native control.\n  */\n  style: object,\n  /**\n      Set the TextField to multi line mode. Under the hood this will use a\n      \\`textarea\\` instead of an \\`input\\` if set to \\`true\\`.\n  */\n  isMultiLine: bool,\n  /**\n      Disables the TextField by greying it out.\n  */\n  isDisabled: bool,\n  /**\n      Initial number of rows a multi line TextField should have. Ignored when\n      not in multi-line mode.\n  */\n  rows: number,\n  /**\n      Class names that are appended to the defaults.\n  */\n  className: string,\n  /**\n      Fires an event every time the user types text into the TextField.\n      Signature: \\`(value, { event, props }) => {}\\`\n  */\n  onChange: func,\n  /**\n      Fires an on the \\`input\\`'s onBlur.  Signature:\n      \\`(currentValue, { event, props }) => {}\\`\n  */\n  onBlur: func,\n  /**\n      Fires an event, debounced by \\`debounceLevel\\`, when the user types text\n      into the TextField.  Signature: \\`(value, { event, props }) => {}\\`\n  */\n  onChangeDebounced: func,\n  /**\n      Fires an event on every keydown Signature: \\`({ event, props }) => {}\\`\n  */\n  onKeyDown: func,\n  /**\n      Fires an event when the user hits \"enter\" from the TextField. You\n      shouldn't use it if you're using \\`isMultiLine\\`.  Signature:\n      \\`(value, { event, props }) => {}\\`\n  */\n  onSubmit: func,\n  /**\n      Set the value of the input.\n  */\n  value: oneOfType([number, string]),\n  /**\n      Number of milliseconds to debounce the \\`onChangeDebounced\\` callback.\n      Only useful if you provide an \\`onChangeDebounced\\` handler.\n  */\n  debounceLevel: number,\n  /**\n      Set the holding time, in milliseconds, that the component will wait if\n      the user is typing and the component gets a new \\`value\\` prop.  Any time\n      the user hits a key, it starts a timer that prevents state changes from\n      flowing in to the component until the timer has elapsed.  This was\n      heavily inspired by the\n      [lazy-input](https:/docs.npmjs.com/package/lazy-input) component.\n  */\n  lazyLevel: number\n};\nTextField.defaultProps = {\n  style: undefined,\n  isDisabled: false,\n  isMultiLine: false,\n  onBlur: _.noop,\n  onChange: _.noop,\n  onChangeDebounced: _.noop,\n  onSubmit: _.noop,\n  onKeyDown: _.noop,\n  rows: 5,\n  debounceLevel: 500,\n  lazyLevel: 1000,\n  value: ''\n};\nTextField.reducers = reducers;\nexport default TextField;","map":{"version":3,"mappings":"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","names":["React","PropTypes","_","lucidClassNames","reducers","KEYCODE","cx","bind","bool","string","func","number","object","oneOfType","nonPassThroughs","TextField","Component","constructor","value","props","isHolding","isMounted","createRef","isMultiLine","textareaElement","inputElement","debounce","event","onChangeDebounced","debounceLevel","state","setState","lazyLevel","newValue","updateWhenReady","onChange","get","releaseHold","noop","persist","handleChangeDebounced","onBlur","flush","onSubmit","onKeyDown","keyCode","Enter","options","nativeElement","current","focus","UNSAFE_componentWillMount","componentWillUnmount","UNSAFE_componentWillReceiveProps","nextProps","has","render","className","isDisabled","rows","style","passThroughs","finalProps","omit","disabled","handleChange","handleBlur","handleKeyDown","ref","type","description","categories","undefined"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/TextField/TextField.tsx"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { StandardProps, Overwrite } from '../../util/component-types';\nimport reducers from './TextField.reducers';\nimport * as KEYCODE from '../../constants/key-code';\n\nconst cx = lucidClassNames.bind('&-TextField');\n\nconst { bool, string, func, number, object, oneOfType } = PropTypes;\n\nexport interface ITextFieldProps extends StandardProps {\n\t/** Set the TextField to multi line mode. Under the hood this will use a `textarea` instead of an `input` if set to `true`. */\n\tisMultiLine?: boolean;\n\n\t/** Disables the TextField by greying it out. */\n\tisDisabled?: boolean;\n\n\t/** Initial number of rows a multi line TextField should have. Ignored when\n\t\tnot in multi-line mode. */\n\trows?: number;\n\n\t/** Fires an event every time the user types text into the TextField. */\n\tonChange?: (\n\t\tvalue: string,\n\t\t{\n\t\t\tevent,\n\t\t\tprops,\n\t\t}: {\n\t\t\tevent: React.FormEvent;\n\t\t\tprops: ITextFieldProps;\n\t\t}\n\t) => void;\n\n\t/** Fires an on the `input`'s onBlur. */\n\tonBlur?: (\n\t\tcurrentValue: string,\n\t\t{\n\t\t\tevent,\n\t\t\tprops,\n\t\t}: {\n\t\t\tevent: React.FocusEvent;\n\t\t\tprops: ITextFieldProps;\n\t\t}\n\t) => void;\n\n\t/** Fires an event, debounced by `debounceLevel` when the user types text\n\t\tinto the TextField. */\n\tonChangeDebounced?: (\n\t\tvalue: string,\n\t\t{\n\t\t\tevent,\n\t\t\tprops,\n\t\t}: {\n\t\t\tevent: React.FormEvent;\n\t\t\tprops: ITextFieldProps;\n\t\t}\n\t) => void;\n\n\t/** Fires an event on every keydown */\n\tonKeyDown?: ({\n\t\tevent,\n\t\tprops,\n\t}: {\n\t\tevent: React.KeyboardEvent;\n\t\tprops: ITextFieldProps;\n\t}) => void;\n\n\t/** Fires an event when the user hits \"enter\" from the TextField. You shouldn't use it if you're using `isMultiLine`. */\n\tonSubmit?: (\n\t\tvalue: string,\n\t\t{\n\t\t\tevent,\n\t\t\tprops,\n\t\t}: {\n\t\t\tevent: React.FormEvent;\n\t\t\tprops: ITextFieldProps;\n\t\t}\n\t) => void;\n\n\t/** Set the value of the input. */\n\tvalue: string | number;\n\n\t/** Number of milliseconds to debounce the `onChangeDebounced` callback. Only useful if you provide an `onChangeDebounced` handler. */\n\tdebounceLevel?: number;\n\n\t/** Set the holding time, in milliseconds, that the component will wait if\n\t\tthe user is typing and the component gets a new `value` prop.  Any time\n\t\tthe user hits a key, it starts a timer that prevents state changes from\n\t\tflowing in to the component until the timer has elapsed.  This was\n\t\theavily inspired by the [lazy-input](https:/docs.npmjs.com/package/lazy-input) component. */\n\tlazyLevel?: number;\n}\n\nexport type ITextFieldPropsWithPassThroughs = Overwrite<\n\tReact.InputHTMLAttributes<HTMLInputElement>,\n\tITextFieldProps\n>;\n\nexport interface ITextFieldState {\n\tvalue: number | string;\n\tisHolding: boolean;\n\tisMounted: boolean;\n}\n\n/** TODO: Remove the nonPassThroughs when the component is converted to a functional component */\nconst nonPassThroughs = [\n\t'style',\n\t'isMultiLine',\n\t'isDisabled',\n\t'rows',\n\t'className',\n\t'onChange',\n\t'onBlur',\n\t'onChangeDebounced',\n\t'onKeyDown',\n\t'onSubmit',\n\t'value',\n\t'debounceLevel',\n\t'lazyLevel',\n\t'initialState',\n\t'callbackId',\n\t'children',\n];\n\nclass TextField extends React.Component<\n\tITextFieldPropsWithPassThroughs,\n\tITextFieldState,\n\t{}\n> {\n\tstatic displayName = 'TextField';\n\tstatic peek = {\n\t\tdescription: `\\`TextField\\` should cover all your text input needs. It is able to handle single- and multi-line inputs.`,\n\t\tcategories: ['controls', 'text'],\n\t};\n\tstatic propTypes = {\n\t\t/**\n\t\t\tStyles that are passed through to native control.\n\t\t*/\n\t\tstyle: object,\n\n\t\t/**\n\t\t\tSet the TextField to multi line mode. Under the hood this will use a\n\t\t\t\\`textarea\\` instead of an \\`input\\` if set to \\`true\\`.\n\t\t*/\n\t\tisMultiLine: bool,\n\n\t\t/**\n\t\t\tDisables the TextField by greying it out.\n\t\t*/\n\t\tisDisabled: bool,\n\n\t\t/**\n\t\t\tInitial number of rows a multi line TextField should have. Ignored when\n\t\t\tnot in multi-line mode.\n\t\t*/\n\t\trows: number,\n\n\t\t/**\n\t\t\tClass names that are appended to the defaults.\n\t\t*/\n\t\tclassName: string,\n\n\t\t/**\n\t\t\tFires an event every time the user types text into the TextField.\n\t\t\tSignature: \\`(value, { event, props }) => {}\\`\n\t\t*/\n\t\tonChange: func,\n\n\t\t/**\n\t\t\tFires an on the \\`input\\`'s onBlur.  Signature:\n\t\t\t\\`(currentValue, { event, props }) => {}\\`\n\t\t*/\n\t\tonBlur: func,\n\n\t\t/**\n\t\t\tFires an event, debounced by \\`debounceLevel\\`, when the user types text\n\t\t\tinto the TextField.  Signature: \\`(value, { event, props }) => {}\\`\n\t\t*/\n\t\tonChangeDebounced: func,\n\n\t\t/**\n\t\t\tFires an event on every keydown Signature: \\`({ event, props }) => {}\\`\n\t\t*/\n\t\tonKeyDown: func,\n\n\t\t/**\n\t\t\tFires an event when the user hits \"enter\" from the TextField. You\n\t\t\tshouldn't use it if you're using \\`isMultiLine\\`.  Signature:\n\t\t\t\\`(value, { event, props }) => {}\\`\n\t\t*/\n\t\tonSubmit: func,\n\n\t\t/**\n\t\t\tSet the value of the input.\n\t\t*/\n\t\tvalue: oneOfType([number, string]),\n\n\t\t/**\n\t\t\tNumber of milliseconds to debounce the \\`onChangeDebounced\\` callback.\n\t\t\tOnly useful if you provide an \\`onChangeDebounced\\` handler.\n\t\t*/\n\t\tdebounceLevel: number,\n\n\t\t/**\n\t\t\tSet the holding time, in milliseconds, that the component will wait if\n\t\t\tthe user is typing and the component gets a new \\`value\\` prop.  Any time\n\t\t\tthe user hits a key, it starts a timer that prevents state changes from\n\t\t\tflowing in to the component until the timer has elapsed.  This was\n\t\t\theavily inspired by the\n\t\t\t[lazy-input](https:/docs.npmjs.com/package/lazy-input) component.\n\t\t*/\n\t\tlazyLevel: number,\n\t};\n\n\tstate = {\n\t\tvalue: this.props.value,\n\t\tisHolding: false,\n\t\tisMounted: false,\n\t};\n\n\tstatic defaultProps = {\n\t\tstyle: undefined,\n\t\tisDisabled: false,\n\t\tisMultiLine: false,\n\t\tonBlur: _.noop,\n\t\tonChange: _.noop,\n\t\tonChangeDebounced: _.noop,\n\t\tonSubmit: _.noop,\n\t\tonKeyDown: _.noop,\n\t\trows: 5,\n\t\tdebounceLevel: 500,\n\t\tlazyLevel: 1000,\n\t\tvalue: '',\n\t};\n\n\tstatic reducers = reducers;\n\n\tprivate textareaElement = React.createRef<HTMLTextAreaElement>();\n\tprivate inputElement = React.createRef<HTMLInputElement>();\n\tprivate nativeElement = this.props.isMultiLine\n\t\t? this.textareaElement\n\t\t: this.inputElement;\n\n\tprivate handleChangeDebounced = _.debounce(\n\t\t(\n\t\t\tvalue: string,\n\t\t\t{\n\t\t\t\tevent,\n\t\t\t\tprops,\n\t\t\t}: {\n\t\t\t\tevent: React.FormEvent;\n\t\t\t\tprops: ITextFieldProps;\n\t\t\t}\n\t\t): void => {\n\t\t\tthis.props.onChangeDebounced &&\n\t\t\t\tthis.props.onChangeDebounced(value, { event, props });\n\t\t},\n\t\tthis.props.debounceLevel\n\t);\n\n\tprivate releaseHold = _.debounce((): void => {\n\t\tif (!this.state.isMounted) {\n\t\t\treturn;\n\t\t}\n\t\tthis.setState({ isHolding: false });\n\t}, this.props.lazyLevel);\n\n\tprivate updateWhenReady = _.debounce((newValue): void => {\n\t\tif (!this.state.isMounted) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.state.isHolding) {\n\t\t\tthis.updateWhenReady(newValue);\n\t\t} else if (newValue !== this.state.value) {\n\t\t\tthis.setState({ value: newValue });\n\t\t}\n\t}, this.props.lazyLevel);\n\n\thandleChange = (event: React.FormEvent): void => {\n\t\tconst { onChange, onChangeDebounced } = this.props;\n\n\t\tconst value = _.get(event, 'target.value', '');\n\n\t\tthis.setState({ value, isHolding: true });\n\t\tthis.releaseHold();\n\n\t\tonChange && onChange(value, { event, props: this.props });\n\n\t\t// Also call the debounced handler in case the user wants debounced change\n\t\t// events.\n\t\tif (onChangeDebounced !== _.noop) {\n\t\t\tevent.persist(); // https://facebook.github.io/react/docs/events.html#event-pooling\n\t\t\tthis.handleChangeDebounced(value, { event, props: this.props });\n\t\t}\n\t};\n\n\thandleBlur = (event: React.FocusEvent): void => {\n\t\tconst { onBlur, onChangeDebounced } = this.props;\n\n\t\tconst value = _.get(event, 'target.value', '');\n\n\t\tif (onChangeDebounced !== _.noop) {\n\t\t\tthis.handleChangeDebounced.flush();\n\t\t}\n\t\tonBlur && onBlur(value, { event, props: this.props });\n\t};\n\n\thandleKeyDown = (event: React.KeyboardEvent): void => {\n\t\tconst {\n\t\t\tprops,\n\t\t\tprops: { onSubmit, onKeyDown, onChangeDebounced },\n\t\t} = this;\n\t\tconst value = _.get(event, 'target.value', '');\n\n\t\t// If the consumer passed an onKeyDown, we call it\n\t\tif (onKeyDown) {\n\t\t\tonKeyDown({ event, props });\n\t\t}\n\n\t\tif (event.keyCode === KEYCODE.Enter) {\n\t\t\tif (onChangeDebounced !== _.noop) {\n\t\t\t\tthis.handleChangeDebounced.flush();\n\t\t\t}\n\n\t\t\tonSubmit && onSubmit(value, { event, props: this.props });\n\t\t}\n\t};\n\n\tfocus = (options?: FocusOptions): void => {\n\t\t/* istanbul ignore next */\n\t\t(this.nativeElement.current as HTMLElement).focus(options);\n\t};\n\n\tUNSAFE_componentWillMount(): void {\n\t\tthis.setState({ isMounted: true });\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.setState({ isMounted: false });\n\t}\n\n\tUNSAFE_componentWillReceiveProps(nextProps: ITextFieldProps): void {\n\t\t// Allow consumer to optionally control state\n\t\tif (_.has(nextProps, 'value')) {\n\t\t\tif (this.state.isHolding) {\n\t\t\t\tthis.updateWhenReady(nextProps.value);\n\t\t\t} else {\n\t\t\t\tthis.setState({ value: nextProps.value });\n\t\t\t}\n\t\t}\n\t}\n\n\trender(): React.ReactNode {\n\t\tconst { className, isDisabled, isMultiLine, rows, style, ...passThroughs } =\n\t\t\tthis.props;\n\n\t\tconst { value } = this.state;\n\n\t\tconst finalProps = {\n\t\t\t...(_.omit(passThroughs, nonPassThroughs) as any),\n\t\t\tclassName: cx(\n\t\t\t\t'&',\n\t\t\t\t{\n\t\t\t\t\t'&-is-disabled': isDisabled,\n\t\t\t\t\t'&-is-multi-line': isMultiLine,\n\t\t\t\t\t'&-is-single-line': !isMultiLine,\n\t\t\t\t},\n\t\t\t\tclassName\n\t\t\t),\n\t\t\tdisabled: isDisabled,\n\t\t\tonChange: this.handleChange,\n\t\t\tonBlur: this.handleBlur,\n\t\t\tonKeyDown: this.handleKeyDown,\n\t\t\tstyle,\n\t\t\trows,\n\t\t\tvalue,\n\t\t};\n\n\t\treturn isMultiLine ? (\n\t\t\t<textarea ref={this.textareaElement} {...finalProps} />\n\t\t) : (\n\t\t\t<input type='text' ref={this.inputElement} {...finalProps} />\n\t\t);\n\t}\n}\n\nexport default TextField;\n"]},"metadata":{},"sourceType":"module"}