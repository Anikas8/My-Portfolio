{"ast":null,"code":"import _, { omit } from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Shape from 'd3-shape';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { groupByFields } from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\nimport Point from '../Point/Point';\nconst cx = lucidClassNames.bind('&-Points');\nconst {\n  arrayOf,\n  func,\n  number,\n  object,\n  bool,\n  string\n} = PropTypes;\nfunction isValidSeries(series) {\n  if (_.isArray(series)) {\n    const last = _.last(series);\n    return _.isFinite(last) || _.isDate(last);\n  }\n  return _.isFinite(series) || _.isDate(series);\n}\nconst nonPassThroughs = ['className', 'palette', 'colorMap', 'data', 'xScale', 'yScale', 'xField', 'yFields', 'yStackedMax', 'colorOffset', 'hasStroke', 'isStacked', 'initialState', 'callbackId'];\nconst defaultProps = {\n  xField: 'x',\n  yFields: ['y'],\n  colorOffset: 0,\n  hasStroke: true,\n  isStacked: false,\n  palette: chartConstants.PALETTE_7\n};\nexport const Points = props => {\n  const {\n    className,\n    data,\n    palette,\n    colorMap,\n    colorOffset,\n    xField,\n    hasStroke,\n    xScale,\n    yFields,\n    yStackedMax,\n    isStacked,\n    yScale: yScaleOriginal,\n    ...passThroughs\n  } = props;\n  // Copy the original so we can mutate it\n  const yScale = yScaleOriginal.copy();\n  // If we are stacked, we need to calculate a new domain based on the sum of\n  // the various series' y data. One row per series.\n  const transformedData = isStacked ? d3Shape.stack().keys(yFields)(data) : groupByFields(data, yFields);\n  // If we are stacked, we need to calculate a new domain based on the sum of\n  // the various group's y data\n  if (isStacked) {\n    yScale.domain([yScale.domain()[0], yStackedMax || _.max(_.flatten(_.last(transformedData)))]);\n  }\n  return React.createElement(\"g\", {\n    ...omit(passThroughs, nonPassThroughs),\n    className: cx(className, '&')\n  }, _.map(transformedData, (d, dIndex) => _.map(d, (series, seriesIndex) => {\n    if (isValidSeries(series)) {\n      return React.createElement(Point, {\n        key: `${seriesIndex}${dIndex}`,\n        /* Since data contains x and y values, data values may not have a uniform type that always matches\n                    the expected input of the xScale */\n        //@ts-ignore\n        x: xScale(data[seriesIndex][xField]),\n        y: yScale(_.isArray(series) ? _.last(series) : series),\n        hasStroke: hasStroke,\n        kind: dIndex + colorOffset,\n        color: _.get(colorMap, yFields[dIndex], palette[(dIndex + colorOffset) % palette.length])\n      });\n    }\n  })));\n};\nPoints.defaultProps = defaultProps;\nPoints.displayName = 'Points';\nPoints.peek = {\n  description: `For use within an \\`svg\\`. Put some points on that data.`,\n  categories: ['visualizations', 'chart primitives'],\n  madeFrom: ['Point']\n};\nPoints.propTypes = {\n  /**\n      Appended to the component-specific class names set on the root element.\n  */\n  className: string,\n  /**\n      Takes one of the palettes exported from \\`lucid.chartConstants\\`.\n      Available palettes:\n       - \\`PALETTE_7\\` (default)\n      - \\`PALETTE_30\\`\n      - \\`PALETTE_MONOCHROME_0_5\\`\n      - \\`PALETTE_MONOCHROME_1_5\\`\n      - \\`PALETTE_MONOCHROME_2_5\\`\n      - \\`PALETTE_MONOCHROME_3_5\\`\n      - \\`PALETTE_MONOCHROME_4_5\\`\n      - \\`PALETTE_MONOCHROME_5_5\\`\n      - \\`PALETTE_MONOCHROME_6_5\\`\n  */\n  palette: arrayOf(string),\n  /**\n      You can pass in an object if you want to map fields to\n      \\`lucid.chartConstants\\` or custom colors:\n       {\n          'imps': COLOR_0,\n          'rev': COLOR_3,\n          'clicks': '#abc123',\n      }\n  */\n  colorMap: object,\n  /**\n      De-normalized data, e.g.\n           [\n              { x: 'one'   , y: 1 },\n              { x: 'two'   , y: 2 },\n              { x: 'three' , y: 2 },\n              { x: 'four'  , y: 3 },\n              { x: 'five'  , y: 4 },\n          ]\n       Or (be sure to set \\`yFields\\` to \\`['y0', 'y1', 'y2', 'y3']\\`)\n           [\n              { x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },\n              { x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },\n              { x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },\n              { x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },\n              { x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },\n              { x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },\n          ]\n  */\n  data: arrayOf(object).isRequired,\n  /**\n      The scale for the x axis. Must be a d3 scale. Lucid exposes the\n      \\`lucid.d3Scale\\` library for use here.\n  */\n  xScale: func.isRequired,\n  /**\n      The scale for the y axis. Must be a d3 scale. Lucid exposes the\n      \\`lucid.d3Scale\\` library for use here.\n  */\n  yScale: func.isRequired,\n  /**\n      The field we should look up your x data by.\n  */\n  xField: string,\n  /**\n      The field(s) we should look up your y data by. Each entry represents a\n      series. Your actual y data should be numeric.\n  */\n  yFields: arrayOf(string),\n  /**\n      Typically this number can be derived from the yScale. However when we're\n      \\`isStacked\\` we need to calculate a new domain for the yScale based on\n      the sum of the data. If you need explicit control of the y max when\n      stacking, pass it in here.\n  */\n  yStackedMax: number,\n  /**\n      Sometimes you might not want the colors to start rotating at the blue\n      color, this number will be added the line index in determining which\n      color the lines are.\n  */\n  colorOffset: number,\n  /**\n      Display a stroke around each of the points.\n  */\n  hasStroke: bool,\n  /**\n      This will stack the data. In order to stack the data we have to calculate\n      a new domain for the y scale that is based on the \\`sum\\` of the data.\n  */\n  isStacked: bool\n};\nexport default Points;","map":{"version":3,"mappings":"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","names":["_","omit","React","PropTypes","d3Shape","lucidClassNames","groupByFields","chartConstants","Point","cx","bind","arrayOf","func","number","object","bool","string","isValidSeries","series","isArray","last","isFinite","isDate","nonPassThroughs","defaultProps","xField","yFields","colorOffset","hasStroke","isStacked","palette","PALETTE_7","Points","props","className","data","colorMap","xScale","yStackedMax","yScale","yScaleOriginal","passThroughs","copy","transformedData","stack","keys","domain","max","flatten","map","d","dIndex","seriesIndex","key","x","y","kind","color","get","length","displayName","peek","description","categories","madeFrom","propTypes","isRequired"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/Points/Points.tsx"],"sourcesContent":["import _, { omit } from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Scale from 'd3-scale';\nimport * as d3Shape from 'd3-shape';\n\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { StandardProps } from '../../util/component-types';\nimport { groupByFields } from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\n\nimport Point from '../Point/Point';\n\nconst cx = lucidClassNames.bind('&-Points');\n\nconst { arrayOf, func, number, object, bool, string } = PropTypes;\n\nfunction isValidSeries(series: any): boolean {\n\tif (_.isArray(series)) {\n\t\tconst last = _.last(series);\n\t\treturn _.isFinite(last) || _.isDate(last);\n\t}\n\n\treturn _.isFinite(series) || _.isDate(series);\n}\n\nexport interface IPointsProps\n\textends StandardProps,\n\t\tReact.SVGProps<SVGGElement> {\n\t/** \tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\tAvailable palettes:\n\n\t- \\`PALETTE_7\\` (default)\n\t- \\`PALETTE_30\\`\n\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t- \\`PALETTE_MONOCHROME_6_5\\` */\n\tpalette: string[];\n\n\t/** You can pass in an object if you want to map fields to\n\t\\`lucid.chartConstants\\` or custom colors:\n\n\t\t{\n\t\t\t'imps': COLOR_0,\n\t\t\t'rev': COLOR_3,\n\t\t\t'clicks': '#abc123',\n\t\t} */\n\tcolorMap?: object;\n\n\t/** De-normalized data, e.g.\n\n\t\t[\n\t\t\t{ x: 'one'   , y: 1 },\n\t\t\t{ x: 'two'   , y: 2 },\n\t\t\t{ x: 'three' , y: 2 },\n\t\t\t{ x: 'four'  , y: 3 },\n\t\t\t{ x: 'five'  , y: 4 },\n\t\t]\n\n\tOr (be sure to set \\`yFields\\` to \\`['y0', 'y1', 'y2', 'y3']\\`)\n\n\t\t[\n\t\t\t{ x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },\n\t\t\t{ x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },\n\t\t\t{ x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },\n\t\t\t{ x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },\n\t\t\t{ x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },\n\t\t\t{ x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },\n\t\t] */\n\tdata: Array<{ [key: string]: string | number | Date }>;\n\n\t/** The scale for the x axis. Must be a d3 scale. Lucid exposes the\n\t\t`lucid.d3Scale` library for use here. */\n\txScale:\n\t\t| d3Scale.ScaleBand<number | string>\n\t\t| d3Scale.ScalePoint<number | string>\n\t\t| d3Scale.ScaleTime<number, number>;\n\n\t/** The scale for the y axis. Must be a d3 scale. Lucid exposes the\n\t\t`lucid.d3Scale` library for use here. */\n\tyScale:\n\t\t| d3Scale.ScaleContinuousNumeric<number, number>\n\t\t| d3Scale.ScaleBand<number>\n\t\t| d3Scale.ScalePoint<number>\n\t\t| d3Scale.ScaleLinear<number, number>;\n\n\t/** Typically this number can be derived from the yScale. However when we're\n\t\t\\`isStacked\\` we need to calculate a new domain for the yScale based on\n\t\tthe sum of the data. If you need explicit control of the y max when\n\t\tstacking, pass it in here. */\n\tyStackedMax?: number | object;\n\n\t/** The field we should look up your x data by. */\n\txField: string;\n\n\t/** The field(s) we should look up your y data by. Each entry represents a\n\t\tseries. Your actual y data should be numeric. */\n\tyFields: string[];\n\n\t/** This will stack the data instead of grouping it. In order to stack the\n\t\tdata we have to calculate a new domain for the y scale that is based on\n\t\tthe \\`sum\\` of the data. */\n\tisStacked: boolean;\n\n\t/** Sometimes you might not want the colors to start rotating at the blue\n\t\tcolor, this number will be added the line index in determining which\n\t\tcolor the lines are. */\n\tcolorOffset: number;\n\n\t/** Display a stroke around each of the points. */\n\thasStroke: boolean;\n}\n\nconst nonPassThroughs = [\n\t'className',\n\t'palette',\n\t'colorMap',\n\t'data',\n\t'xScale',\n\t'yScale',\n\t'xField',\n\t'yFields',\n\t'yStackedMax',\n\t'colorOffset',\n\t'hasStroke',\n\t'isStacked',\n\t'initialState',\n\t'callbackId',\n];\n\nconst defaultProps = {\n\txField: 'x',\n\tyFields: ['y'],\n\tcolorOffset: 0,\n\thasStroke: true,\n\tisStacked: false,\n\tpalette: chartConstants.PALETTE_7,\n};\n\nexport const Points = (props: IPointsProps): React.ReactElement => {\n\tconst {\n\t\tclassName,\n\t\tdata,\n\t\tpalette,\n\t\tcolorMap,\n\t\tcolorOffset,\n\t\txField,\n\t\thasStroke,\n\t\txScale,\n\t\tyFields,\n\t\tyStackedMax,\n\t\tisStacked,\n\t\tyScale: yScaleOriginal,\n\t\t...passThroughs\n\t} = props;\n\t// Copy the original so we can mutate it\n\tconst yScale = yScaleOriginal.copy();\n\n\t// If we are stacked, we need to calculate a new domain based on the sum of\n\t// the various series' y data. One row per series.\n\tconst transformedData = isStacked\n\t\t? d3Shape.stack().keys(yFields)(data as Array<{ [key: string]: number }>)\n\t\t: groupByFields(data, yFields);\n\n\t// If we are stacked, we need to calculate a new domain based on the sum of\n\t// the various group's y data\n\tif (isStacked) {\n\t\tyScale.domain([\n\t\t\tyScale.domain()[0],\n\t\t\tyStackedMax || _.max(_.flatten(_.last(transformedData))),\n\t\t]);\n\t}\n\n\treturn (\n\t\t<g {...omit(passThroughs, nonPassThroughs)} className={cx(className, '&')}>\n\t\t\t{_.map(transformedData, (d, dIndex): any[] =>\n\t\t\t\t_.map(d, (series, seriesIndex): JSX.Element | undefined => {\n\t\t\t\t\tif (isValidSeries(series)) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Point\n\t\t\t\t\t\t\t\tkey={`${seriesIndex}${dIndex}`}\n\t\t\t\t\t\t\t\t/* Since data contains x and y values, data values may not have a uniform type that always matches\n\t\t\t\t\t\t\t\t\t\t\tthe expected input of the xScale */\n\t\t\t\t\t\t\t\t//@ts-ignore\n\t\t\t\t\t\t\t\tx={xScale(data[seriesIndex][xField])}\n\t\t\t\t\t\t\t\ty={yScale(_.isArray(series) ? _.last(series) : series)}\n\t\t\t\t\t\t\t\thasStroke={hasStroke}\n\t\t\t\t\t\t\t\tkind={dIndex + colorOffset}\n\t\t\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\t\t\tyFields[dIndex],\n\t\t\t\t\t\t\t\t\tpalette[(dIndex + colorOffset) % palette.length]\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t)}\n\t\t</g>\n\t);\n};\n\nPoints.defaultProps = defaultProps;\n\nPoints.displayName = 'Points';\n\nPoints.peek = {\n\tdescription: `For use within an \\`svg\\`. Put some points on that data.`,\n\tcategories: ['visualizations', 'chart primitives'],\n\tmadeFrom: ['Point'],\n};\n\nPoints.propTypes = {\n\t/**\n\t\tAppended to the component-specific class names set on the root element.\n\t*/\n\tclassName: string,\n\n\t/**\n\t\tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\t\tAvailable palettes:\n\n\t\t- \\`PALETTE_7\\` (default)\n\t\t- \\`PALETTE_30\\`\n\t\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t\t- \\`PALETTE_MONOCHROME_6_5\\`\n\t*/\n\tpalette: arrayOf(string),\n\n\t/**\n\t\tYou can pass in an object if you want to map fields to\n\t\t\\`lucid.chartConstants\\` or custom colors:\n\n\t\t{\n\t\t\t'imps': COLOR_0,\n\t\t\t'rev': COLOR_3,\n\t\t\t'clicks': '#abc123',\n\t\t}\n\t*/\n\tcolorMap: object,\n\n\t/**\n\t\tDe-normalized data, e.g.\n\n\t\t\t[\n\t\t\t\t{ x: 'one'   , y: 1 },\n\t\t\t\t{ x: 'two'   , y: 2 },\n\t\t\t\t{ x: 'three' , y: 2 },\n\t\t\t\t{ x: 'four'  , y: 3 },\n\t\t\t\t{ x: 'five'  , y: 4 },\n\t\t\t]\n\n\t\tOr (be sure to set \\`yFields\\` to \\`['y0', 'y1', 'y2', 'y3']\\`)\n\n\t\t\t[\n\t\t\t\t{ x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },\n\t\t\t\t{ x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },\n\t\t\t\t{ x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },\n\t\t\t\t{ x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },\n\t\t\t\t{ x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },\n\t\t\t\t{ x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },\n\t\t\t]\n\t*/\n\tdata: arrayOf(object).isRequired,\n\n\t/**\n\t\tThe scale for the x axis. Must be a d3 scale. Lucid exposes the\n\t\t\\`lucid.d3Scale\\` library for use here.\n\t*/\n\txScale: func.isRequired,\n\n\t/**\n\t\tThe scale for the y axis. Must be a d3 scale. Lucid exposes the\n\t\t\\`lucid.d3Scale\\` library for use here.\n\t*/\n\tyScale: func.isRequired,\n\n\t/**\n\t\tThe field we should look up your x data by.\n\t*/\n\txField: string,\n\n\t/**\n\t\tThe field(s) we should look up your y data by. Each entry represents a\n\t\tseries. Your actual y data should be numeric.\n\t*/\n\tyFields: arrayOf(string),\n\n\t/**\n\t\tTypically this number can be derived from the yScale. However when we're\n\t\t\\`isStacked\\` we need to calculate a new domain for the yScale based on\n\t\tthe sum of the data. If you need explicit control of the y max when\n\t\tstacking, pass it in here.\n\t*/\n\tyStackedMax: number,\n\n\t/**\n\t\tSometimes you might not want the colors to start rotating at the blue\n\t\tcolor, this number will be added the line index in determining which\n\t\tcolor the lines are.\n\t*/\n\tcolorOffset: number,\n\n\t/**\n\t\tDisplay a stroke around each of the points.\n\t*/\n\thasStroke: bool,\n\n\t/**\n\t\tThis will stack the data. In order to stack the data we have to calculate\n\t\ta new domain for the y scale that is based on the \\`sum\\` of the data.\n\t*/\n\tisStacked: bool,\n};\n\nexport default Points;\n"]},"metadata":{},"sourceType":"module"}