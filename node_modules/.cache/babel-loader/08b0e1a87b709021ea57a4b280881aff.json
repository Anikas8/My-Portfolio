{"ast":null,"code":"import _ from 'lodash';\nimport { createSelector } from 'reselect';\nimport { reduceSelectors, safeMerge } from './state-management';\nimport { logger, isDevMode } from './logger';\n/**\n * Marks a function on the reducer tree as a thunk action creator so it doesn't\n * get incorporated into the redux reducer\n *\n * @return {function} with `isThunk` set to `true`\n */\nexport function thunk(fn) {\n  fn.isThunk = true;\n  return fn;\n}\nexport function getReduxPrimitives(_ref) {\n  let {\n    initialState,\n    reducers,\n    rootPath = [],\n    rootSelector = _.identity,\n    selectors\n  } = _ref;\n  /* istanbul ignore if */\n  if (isDevMode && _.isEmpty(rootPath)) {\n    logger.warn(`\\`getReduxPrimitives\\` warning:\n\\`rootPath\\` is empty`);\n  }\n  /* istanbul ignore if */\n  if (isDevMode && !initialState) {\n    logger.warn(`\\`getReduxPrimitives\\` warning:\nMissing \\`initialState\\` for component at \\`rootPath\\` ${_.isArray(rootPath) ? rootPath.join(',') : rootPath}\nComponents should have an \\`initialState\\` property or a \\`getDefaultProps\\` defined.\n`);\n  }\n  // we need this in scope so actionCreators can refer to it\n  let dispatchTree;\n  const reducer = createReduxReducer(reducers, initialState, rootPath);\n  const selector = selectors ? reduceSelectors(selectors) : _.identity;\n  const rootPathSelector = state => _.isEmpty(rootPath) ? state : _.get(state, rootPath);\n  const mapStateToProps = createSelector([rootPathSelector], rootState => rootSelector(selector(rootState)));\n  // dispatch could be store.dispatch's return value or an async lib's return value?\n  const mapDispatchToProps = dispatch => getDispatchTree(reducers, rootPath, dispatch);\n  const devModeMapStateToProps = rootState => {\n    /* istanbul ignore if */\n    if (isDevMode && !_.has(rootState, rootPath)) {\n      logger.warn(`\\`getReduxPrimitives\\` warning:\n\\`rootPath\\` ${rootPath} does not exist in the redux store.\nMake sure your \\`rootPath\\` is correct.\n`);\n    }\n    return mapStateToProps(rootState);\n  };\n  return {\n    reducer,\n    connectors: [isDevMode ? devModeMapStateToProps : mapStateToProps, mapDispatchToProps, mergeProps]\n  };\n  /**\n   * @param {function} node - a node in the the reducer tree, either a reducer or a thunk\n   * @param {string[]} path - the path to the reducer in the reducer tree\n   * @param {string[]} rootPath - array of strings representing the path to local state in global state\n   * @return {function} action creator that returns either an action or a thunk\n   */\n  function createActionCreator(node, rootPath, path) {\n    if (node.isThunk) {\n      return function thunk() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return function thunkInner(dispatch, getState) {\n          const pathToLocalDispatchTree = _.slice(path, rootPath.length, -1);\n          const pathToLocalState = _.dropRight(path);\n          const localDispatchTree = _.isEmpty(pathToLocalDispatchTree) ? dispatchTree : _.get(dispatchTree, pathToLocalDispatchTree);\n          const getLocalState = _.isEmpty(pathToLocalState) ? getState : () => _.get(getState(), pathToLocalState);\n          for (var _len2 = arguments.length, rest = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            rest[_key2 - 2] = arguments[_key2];\n          }\n          return node(...args)(localDispatchTree, getLocalState, dispatch, getState, ...rest);\n        };\n      };\n    }\n    return function actionCreator() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      const [payload, ...meta] = isDevMode ? cleanArgs(args) : args;\n      return {\n        type: path.join('.'),\n        payload,\n        meta\n      };\n    };\n  }\n  /**\n   * Walks the reducer tree and generates a tree of action creators that correspond to each reducer\n   * @param {Object} reducers - a tree of lucid reducers\n   * @param {string[]} rootPath - array of strings representing the path to local state in global state\n   * @returns {Object} action creator tree\n   */\n  function createActionCreatorTree(reducers, rootPath) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rootPath;\n    return _.reduce(reducers, (memo, node, key) => {\n      const currentPath = path.concat(key);\n      return {\n        ...memo,\n        [key]: _.isFunction(node) ? createActionCreator(node, rootPath, currentPath) : createActionCreatorTree(node, rootPath, currentPath)\n      };\n    }, {});\n  }\n  /**\n   * Walks the reducer tree and generates an action creator tree, then binds dispatch to each node\n   * @param {Object} reducers - a tree of lucid reducers\n   * @param {string[]} rootPath - array of strings representing the path to local state in global state\n   * @param {function} dispatch - the redux store's `dispatch` function\n   */\n  function getDispatchTree(reducers, rootPath, dispatch) {\n    const actionCreatorTree = createActionCreatorTree(reducers, rootPath);\n    dispatchTree = bindActionCreatorTree(actionCreatorTree, dispatch);\n    /* istanbul ignore if */\n    if (isDevMode) {\n      //@ts-ignore\n      window.lucidReduxUtil = window.lucidReduxUtil || {};\n      //@ts-ignore\n      window.lucidReduxUtil[rootPath] = {\n        actionCreatorTree,\n        dispatchTree\n      };\n    }\n    return dispatchTree;\n  }\n}\nfunction createReduxReducerTree(reducers) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return _.reduce(reducers, (memo, node, key) => {\n    // filter out thunks from the reducer tree\n    if (node.isThunk) {\n      return memo;\n    }\n    const currentPath = path.concat(key);\n    return {\n      ...memo,\n      [key]: _.isFunction(node) ? function reduxReducer(state, action) {\n        const {\n          type,\n          payload,\n          meta = []\n        } = action;\n        if (_.isUndefined(state) || type !== currentPath.join('.')) {\n          return state;\n        }\n        return node(state, payload, ...meta);\n      } : createReduxReducerTree(node, currentPath)\n    };\n  }, {});\n}\n/**\n * Returns a function that calls every reducer in the reducer tree with the reducer's local state and action\n * @param {Object} reduxReducerTree - tree of redux reducers with signature `(state, action) => state`\n * @param {Object} initialState - the initial state object that the reducer will return\n * @return {function} the redux reducer\n */\nfunction createReducerFromReducerTree(reduxReducerTree, initialState) {\n  return function reduxReducer(state, action) {\n    if (_.isUndefined(state)) {\n      return initialState;\n    }\n    return _.reduce(reduxReducerTree, (state, node, key) => {\n      return {\n        ...state,\n        ...(_.isFunction(node) ? node(state, action) : {\n          [key]: createReducerFromReducerTree(node, {})(state[key], action)\n        })\n      };\n    }, state);\n  };\n}\n/**\n * Generates a redux reducer from a tree of lucid reducers\n * @param {Object} reducers - a tree of lucid reducers\n * @param {Object} initialState - the initial state object that the reducer will return\n * @param {string[]} rootPath - array of strings representing the path to part of global state this reducer applies to\n * @return {function} the redux reducer\n */\nfunction createReduxReducer(reducers, initialState, rootPath) {\n  const reducerTree = createReduxReducerTree(reducers, rootPath);\n  return createReducerFromReducerTree(reducerTree, initialState);\n}\n/**\n * Binds redux store.dispatch to actionCreators in a tree\n * @param {Object} actionCreatorTree - a tree of redux action creator functions\n * @param {function} dispatch - the redux store's `dispatch` function\n * @param {string[]} path - array of strings representing the path to the action creator\n */\nfunction bindActionCreatorTree(actionCreatorTree, dispatch) {\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return _.reduce(actionCreatorTree, (memo, node, key) => ({\n    ...memo,\n    [key]: _.isFunction(node) ? function boundActionCreator() {\n      const action = actionCreatorTree[key](...arguments);\n      return dispatch(action);\n    } : bindActionCreatorTree(node, dispatch, path.concat(key))\n  }),\n  // @ts-ignore\n  {});\n}\n/**\n * Merges state, dispatchTree, and ownProps into a single props object\n * @param {Object} state\n * @param {Object} dispatchTree\n * @param {Object} ownProps\n * @return {Object}\n */\nconst mergeProps = _.memoize((state, dispatchTree, ownProps) => {\n  return _.mergeWith({}, state, dispatchTree, ownProps, safeMerge);\n});\n/**\n * Checks the last element of the array and\n * if it is an 'event' object, it removes it\n * Otherwise it just returns the array\n * @param {any[]} - an array of args\n */\nexport function cleanArgs(args) {\n  return _.has(_.last(args), 'event') ? _.dropRight(args) : args;\n}","map":{"version":3,"mappings":"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","names":["_","createSelector","reduceSelectors","safeMerge","logger","isDevMode","thunk","fn","isThunk","getReduxPrimitives","initialState","reducers","rootPath","rootSelector","identity","selectors","isEmpty","warn","isArray","join","dispatchTree","reducer","createReduxReducer","selector","rootPathSelector","state","get","mapStateToProps","rootState","mapDispatchToProps","dispatch","getDispatchTree","devModeMapStateToProps","has","connectors","mergeProps","createActionCreator","node","path","args","thunkInner","getState","pathToLocalDispatchTree","slice","length","pathToLocalState","dropRight","localDispatchTree","getLocalState","rest","actionCreator","payload","meta","cleanArgs","type","createActionCreatorTree","reduce","memo","key","currentPath","concat","isFunction","actionCreatorTree","bindActionCreatorTree","window","lucidReduxUtil","createReduxReducerTree","reduxReducer","action","isUndefined","createReducerFromReducerTree","reduxReducerTree","reducerTree","boundActionCreator","memoize","ownProps","mergeWith","last"],"sources":["/home/skanda/node_modules/lucid-ui/src/util/redux.ts"],"sourcesContent":["import _ from 'lodash';\nimport { createSelector } from 'reselect';\nimport { reduceSelectors, safeMerge } from './state-management';\nimport { logger, isDevMode } from './logger';\n\nexport type Funk = (...args: any) => any;\nexport interface IThunk {\n\tisThunk?: boolean;\n}\nexport type FunkThunk = Funk & IThunk;\n\n/**\n * Marks a function on the reducer tree as a thunk action creator so it doesn't\n * get incorporated into the redux reducer\n *\n * @return {function} with `isThunk` set to `true`\n */\n\nexport function thunk(fn: FunkThunk) {\n\tfn.isThunk = true;\n\treturn fn;\n}\n\n/**\n * Creates a redux reducer and connectors (inputs to redux-react's `connect`)\n *\n * @param {Object} param\n * @param {Object} param.initialState - the initial state object that the reducer will return\n * @param {Object} param.reducers - a tree of lucid reducers\n * @param {string[]} param.rootPath - array of strings representing the path to local state in global state\n * @param {function} param.rootSelector - a top-level selector which takes as input state that has run through every selector in param.selectors\n * @param {Object} param.selectors - a tree of lucid selectors\n * @return {Object} redux reducer and connectors\n */\n\ninterface IGetReduxPrimitives {\n\tinitialState: object;\n\treducers: object;\n\trootPath?: string[];\n\trootSelector?: (arg0: any) => any;\n\tselectors?: object;\n}\nexport function getReduxPrimitives({\n\tinitialState,\n\treducers,\n\trootPath = [],\n\trootSelector = _.identity,\n\tselectors,\n}: IGetReduxPrimitives) {\n\t/* istanbul ignore if */\n\tif (isDevMode && _.isEmpty(rootPath)) {\n\t\tlogger.warn(\n\t\t\t`\\`getReduxPrimitives\\` warning:\n\\`rootPath\\` is empty`\n\t\t);\n\t}\n\n\t/* istanbul ignore if */\n\tif (isDevMode && !initialState) {\n\t\tlogger.warn(\n\t\t\t`\\`getReduxPrimitives\\` warning:\nMissing \\`initialState\\` for component at \\`rootPath\\` ${\n\t\t\t\t_.isArray(rootPath) ? rootPath.join(',') : rootPath\n\t\t\t}\nComponents should have an \\`initialState\\` property or a \\`getDefaultProps\\` defined.\n`\n\t\t);\n\t}\n\n\t// we need this in scope so actionCreators can refer to it\n\tlet dispatchTree: object;\n\n\tconst reducer = createReduxReducer(reducers, initialState, rootPath);\n\tconst selector = selectors ? reduceSelectors(selectors) : _.identity;\n\tconst rootPathSelector = (state: object) =>\n\t\t_.isEmpty(rootPath) ? state : _.get(state, rootPath);\n\n\tconst mapStateToProps = createSelector([rootPathSelector], (rootState) =>\n\t\trootSelector(selector(rootState))\n\t);\n\t// dispatch could be store.dispatch's return value or an async lib's return value?\n\tconst mapDispatchToProps = (dispatch: Funk) =>\n\t\tgetDispatchTree(reducers, rootPath, dispatch);\n\tconst devModeMapStateToProps = (rootState: object) => {\n\t\t/* istanbul ignore if */\n\t\tif (isDevMode && !_.has(rootState, rootPath)) {\n\t\t\tlogger.warn(\n\t\t\t\t`\\`getReduxPrimitives\\` warning:\n\\`rootPath\\` ${rootPath} does not exist in the redux store.\nMake sure your \\`rootPath\\` is correct.\n`\n\t\t\t);\n\t\t}\n\t\treturn mapStateToProps(rootState);\n\t};\n\n\treturn {\n\t\treducer,\n\t\tconnectors: [\n\t\t\tisDevMode ? devModeMapStateToProps : mapStateToProps,\n\t\t\tmapDispatchToProps,\n\t\t\tmergeProps,\n\t\t],\n\t};\n\n\t/**\n\t * @param {function} node - a node in the the reducer tree, either a reducer or a thunk\n\t * @param {string[]} path - the path to the reducer in the reducer tree\n\t * @param {string[]} rootPath - array of strings representing the path to local state in global state\n\t * @return {function} action creator that returns either an action or a thunk\n\t */\n\tfunction createActionCreator(\n\t\tnode: Funk | FunkThunk,\n\t\trootPath: string[],\n\t\tpath: string[]\n\t) {\n\t\tif ((node as FunkThunk).isThunk) {\n\t\t\treturn function thunk(...args: any[]) {\n\t\t\t\treturn function thunkInner(\n\t\t\t\t\tdispatch: Funk,\n\t\t\t\t\tgetState: Funk,\n\t\t\t\t\t...rest: any[]\n\t\t\t\t) {\n\t\t\t\t\tconst pathToLocalDispatchTree = _.slice(path, rootPath.length, -1);\n\t\t\t\t\tconst pathToLocalState = _.dropRight(path);\n\t\t\t\t\tconst localDispatchTree = _.isEmpty(pathToLocalDispatchTree)\n\t\t\t\t\t\t? dispatchTree\n\t\t\t\t\t\t: _.get(dispatchTree, pathToLocalDispatchTree);\n\t\t\t\t\tconst getLocalState = _.isEmpty(pathToLocalState)\n\t\t\t\t\t\t? getState\n\t\t\t\t\t\t: () => _.get(getState(), pathToLocalState);\n\t\t\t\t\treturn node(...args)(\n\t\t\t\t\t\tlocalDispatchTree,\n\t\t\t\t\t\tgetLocalState,\n\t\t\t\t\t\tdispatch,\n\t\t\t\t\t\tgetState,\n\t\t\t\t\t\t...rest\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t\treturn function actionCreator(...args: any[]) {\n\t\t\tconst [payload, ...meta] = isDevMode ? cleanArgs(args) : args;\n\n\t\t\treturn {\n\t\t\t\ttype: path.join('.'),\n\t\t\t\tpayload,\n\t\t\t\tmeta,\n\t\t\t};\n\t\t};\n\t}\n\n\t/**\n\t * Walks the reducer tree and generates a tree of action creators that correspond to each reducer\n\t * @param {Object} reducers - a tree of lucid reducers\n\t * @param {string[]} rootPath - array of strings representing the path to local state in global state\n\t * @returns {Object} action creator tree\n\t */\n\tfunction createActionCreatorTree(\n\t\treducers: object,\n\t\trootPath: string[],\n\t\tpath: string[] = rootPath\n\t): object {\n\t\treturn _.reduce(\n\t\t\treducers,\n\t\t\t(memo, node, key) => {\n\t\t\t\tconst currentPath = path.concat(key);\n\t\t\t\treturn {\n\t\t\t\t\t...memo,\n\t\t\t\t\t[key]: _.isFunction(node)\n\t\t\t\t\t\t? createActionCreator(node, rootPath, currentPath)\n\t\t\t\t\t\t: createActionCreatorTree(node, rootPath, currentPath),\n\t\t\t\t};\n\t\t\t},\n\t\t\t{}\n\t\t);\n\t}\n\n\t/**\n\t * Walks the reducer tree and generates an action creator tree, then binds dispatch to each node\n\t * @param {Object} reducers - a tree of lucid reducers\n\t * @param {string[]} rootPath - array of strings representing the path to local state in global state\n\t * @param {function} dispatch - the redux store's `dispatch` function\n\t */\n\tfunction getDispatchTree(\n\t\treducers: object,\n\t\trootPath: string[],\n\t\tdispatch: Funk\n\t) {\n\t\tconst actionCreatorTree = createActionCreatorTree(reducers, rootPath);\n\t\tdispatchTree = bindActionCreatorTree(actionCreatorTree, dispatch);\n\t\t/* istanbul ignore if */\n\t\tif (isDevMode) {\n\t\t\t//@ts-ignore\n\t\t\twindow.lucidReduxUtil = window.lucidReduxUtil || {};\n\t\t\t//@ts-ignore\n\t\t\twindow.lucidReduxUtil[rootPath] = {\n\t\t\t\tactionCreatorTree,\n\t\t\t\tdispatchTree,\n\t\t\t};\n\t\t}\n\t\treturn dispatchTree;\n\t}\n}\n\n/**\n * Walks the reducer tree and generates a tree of redux reducers, converting the\n * signature from `(state, payload) => state` to `(state, action) => state`\n * @param {Object} reducers - a tree of lucid reducers\n * @param {string[]} path - array of strings representing the path to the reducer\n * @return {Object} redux reducer tree\n */\n\ntype PayloadReducer = (state: object, payload: any, ...args: any) => any;\ntype ActionReducer = (state: object, action: object, ...args: any) => any;\n\nfunction createReduxReducerTree(reducers: object, path: string[] = []): object {\n\treturn _.reduce(\n\t\treducers,\n\t\t(memo, node, key) => {\n\t\t\t// filter out thunks from the reducer tree\n\t\t\tif ((node as FunkThunk).isThunk) {\n\t\t\t\treturn memo;\n\t\t\t}\n\t\t\tconst currentPath = path.concat(key);\n\t\t\treturn {\n\t\t\t\t...memo,\n\t\t\t\t[key]: _.isFunction(node)\n\t\t\t\t\t? function reduxReducer(\n\t\t\t\t\t\t\tstate: object,\n\t\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\t\ttype: any;\n\t\t\t\t\t\t\t\tpayload: any;\n\t\t\t\t\t\t\t\tmeta: [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t  ) {\n\t\t\t\t\t\t\tconst { type, payload, meta = [] } = action;\n\t\t\t\t\t\t\tif (_.isUndefined(state) || type !== currentPath.join('.')) {\n\t\t\t\t\t\t\t\treturn state;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn (node as PayloadReducer)(state, payload, ...meta);\n\t\t\t\t\t  }\n\t\t\t\t\t: createReduxReducerTree(node, currentPath),\n\t\t\t};\n\t\t},\n\t\t{}\n\t);\n}\n\n/**\n * Returns a function that calls every reducer in the reducer tree with the reducer's local state and action\n * @param {Object} reduxReducerTree - tree of redux reducers with signature `(state, action) => state`\n * @param {Object} initialState - the initial state object that the reducer will return\n * @return {function} the redux reducer\n */\nfunction createReducerFromReducerTree(\n\treduxReducerTree: object,\n\tinitialState: object\n) {\n\treturn function reduxReducer(state: any, action: object): object | Funk {\n\t\tif (_.isUndefined(state)) {\n\t\t\treturn initialState;\n\t\t}\n\t\treturn _.reduce(\n\t\t\treduxReducerTree,\n\t\t\t(state, node, key) => {\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\t...(_.isFunction(node)\n\t\t\t\t\t\t? (node as ActionReducer)(state, action)\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t[key]: createReducerFromReducerTree(node, {})(\n\t\t\t\t\t\t\t\t\tstate[key],\n\t\t\t\t\t\t\t\t\taction\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t  }),\n\t\t\t\t};\n\t\t\t},\n\t\t\tstate\n\t\t);\n\t};\n}\n\n/**\n * Generates a redux reducer from a tree of lucid reducers\n * @param {Object} reducers - a tree of lucid reducers\n * @param {Object} initialState - the initial state object that the reducer will return\n * @param {string[]} rootPath - array of strings representing the path to part of global state this reducer applies to\n * @return {function} the redux reducer\n */\nfunction createReduxReducer(\n\treducers: object,\n\tinitialState: object,\n\trootPath: string[]\n) {\n\tconst reducerTree = createReduxReducerTree(reducers, rootPath);\n\treturn createReducerFromReducerTree(reducerTree, initialState);\n}\n\n/**\n * Binds redux store.dispatch to actionCreators in a tree\n * @param {Object} actionCreatorTree - a tree of redux action creator functions\n * @param {function} dispatch - the redux store's `dispatch` function\n * @param {string[]} path - array of strings representing the path to the action creator\n */\nfunction bindActionCreatorTree(\n\tactionCreatorTree: any,\n\tdispatch: Funk,\n\tpath: string[] = []\n): object {\n\treturn _.reduce(\n\t\tactionCreatorTree,\n\t\t(memo, node, key: string) => ({\n\t\t\t...memo,\n\t\t\t[key]: _.isFunction(node)\n\t\t\t\t? function boundActionCreator(...args: any) {\n\t\t\t\t\t\tconst action = actionCreatorTree[key](...args);\n\t\t\t\t\t\treturn dispatch(action);\n\t\t\t\t  }\n\t\t\t\t: bindActionCreatorTree(node, dispatch, path.concat(key)),\n\t\t}),\n\t\t// @ts-ignore\n\t\t{}\n\t);\n}\n\n/**\n * Merges state, dispatchTree, and ownProps into a single props object\n * @param {Object} state\n * @param {Object} dispatchTree\n * @param {Object} ownProps\n * @return {Object}\n */\nconst mergeProps = _.memoize((state, dispatchTree, ownProps) => {\n\treturn _.mergeWith({}, state, dispatchTree, ownProps, safeMerge);\n});\n\n/**\n * Checks the last element of the array and\n * if it is an 'event' object, it removes it\n * Otherwise it just returns the array\n * @param {any[]} - an array of args\n */\nexport function cleanArgs(args: any[]) {\n\treturn _.has(_.last(args), 'event') ? _.dropRight(args) : args;\n}\n"]},"metadata":{},"sourceType":"module"}