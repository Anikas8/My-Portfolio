{"ast":null,"code":"import _ from 'lodash';\nimport * as d3TimeFormat from 'd3-time-format';\nimport * as d3Time from 'd3-time';\n/**\n * stackByFields\n *\n * D3's `stack` groups each series' data together but we sometimes we want the\n * stacked groups to remain grouped as in the original normalized data. This\n * function helps achieve that.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for row in the original `collection`\n */\nexport function stackByFields(collection, fields) {\n  const fieldsArray = _.castArray(fields);\n  return _.map(collection, d => {\n    return _.reduce(fieldsArray, (acc, field) => {\n      const dataPoint = _.get(d, field, 0);\n      if (_.isEmpty(acc)) {\n        return acc.concat([[0, dataPoint]]);\n      }\n      const maybeLast = _.last(_.last(acc));\n      const last = maybeLast === undefined ? 0 : maybeLast;\n      return acc.concat([[last, last + dataPoint]]);\n    }, []);\n  });\n}\n/**\n * extractFields\n *\n * This will return the data in a similar format to stackByFields but without\n * the stacking.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for each field\n */\nexport function extractFields(collection, fields) {\n  let minDomainValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const fieldsArray = _.castArray(fields);\n  return _.map(collection, d => {\n    return _.map(fieldsArray, field => [minDomainValue, _.get(d, field, 0)]);\n  });\n}\n/**\n * groupByFields\n *\n * This will return the data in a similar format to d3Shape.stack\n * but without the stacking of the data.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for each field\n */\nexport function groupByFields(collection, fields) {\n  const fieldsArray = _.castArray(fields);\n  return _.map(fieldsArray, field => {\n    return _.map(collection, field);\n  });\n}\n/**\n * byFields\n *\n * Takes a collection of data and returns an array of all the fields off that\n * collection.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {array}\n */\nexport function byFields(collection, fields) {\n  const fieldArray = _.castArray(fields);\n  return _.reduce(fieldArray, (acc, field) => {\n    return acc.concat(_.map(collection, field));\n  }, []);\n}\n/**\n * nearest\n *\n * Divide and conquer algorithm that helps find the nearest element to `value`\n * in `nums`\n *\n * @param {number[]} nums - sorted array of numbers to search through\n * @param {number} value - value you're trying to locate the nearest array element for\n * @return {number} - the nearest array element to the value\n */\nexport function nearest(nums, value) {\n  if (nums.length < 2) {\n    return _.first(nums);\n  }\n  if (nums.length === 2) {\n    return value > (nums[0] + nums[1]) / 2 ? nums[1] : nums[0];\n  }\n  const mid = nums.length >>> 1;\n  return nums[mid] > value ? nearest(nums.slice(0, mid + 1), value) : nearest(nums.slice(mid), value);\n}\n/**\n * minByFields\n *\n * Returns the minimum element from a collection by a set of fields.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\nexport function minByFields(collection, fields) {\n  return _.min(byFields(collection, fields));\n}\n/**\n * maxByFields\n *\n * Returns the maximum element from a collection by a set of fields.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\nexport function maxByFields(collection, fields) {\n  return _.max(byFields(collection, fields));\n}\n/**\n * maxByFieldsStacked\n *\n * Returns the max sum of a set of fields from a collection\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\nexport function maxByFieldsStacked(collection, fields) {\n  const fieldArray = _.castArray(fields);\n  const sums = _.reduce(collection, (acc, item) => {\n    return acc.concat(_.sum(_.toArray(_.pick(item, fieldArray))));\n  }, []);\n  return _.max(sums);\n}\n/**\n * discreteTicks\n *\n * Returns `count` evenly spaced, representative values from the `array`.\n *\n * @param {array} array\n * @param {number} size - should be greater than 1\n * @return {array}\n */\nexport function discreteTicks(array) {\n  let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!array || _.isNil(count) || array.length <= count) {\n    return array;\n  }\n  const step = (array.length - 1) / Math.max(1, count - 1);\n  return _.reduce(_.times(count), (acc, n) => {\n    return acc.concat(array[Math.round(n * step)]);\n  }, []);\n}\n/**\n * transformFromCenter\n *\n * Scaling paths from their center is tricky. This function\n * helps do that be generating a translate/scale transform\n * string with the correct numbers.\n *\n * @param {number} x - the x data point where you want the path to be centered at\n * @param {number} y - the y data point where you want the path to be centered at\n * @param {number} xCenter - the x coordinate of the center of the path you're trying to transform\n * @param {number} yCenter - the x coordinate of the center of the path you're trying to transform\n * @param {number} scale - number to scale to, 2 would be 2x bigger\n * @return {string} - transform string\n */\nexport function transformFromCenter(x, y, xCenter, yCenter, scale) {\n  return `translate(${(1 - scale) * xCenter + (x - xCenter)}, ${(1 - scale) * yCenter + (y - yCenter)}) scale(${scale})`;\n}\nconst FORMAT_MILLISECOND = d3TimeFormat.timeFormat('.%L');\nconst FORMAT_SECOND = d3TimeFormat.timeFormat(':%S');\nconst FORMAT_MINUTE = d3TimeFormat.timeFormat('%I:%M');\nconst FORMAT_HOUR = d3TimeFormat.timeFormat('%I %p');\nconst FORMAT_DAY = d3TimeFormat.timeFormat('%a %d');\nconst FORMAT_WEEK = d3TimeFormat.timeFormat('%b %d');\nconst FORMAT_MONTH = d3TimeFormat.timeFormat('%b');\nconst FORMAT_YEAR = d3TimeFormat.timeFormat('%Y');\n/**\n * formatDate\n *\n * This function was written to be used for tick formatting with d3 time\n * scales.\n *\n * @param {date} date - input date\n * @return {string} - formatted date\n */\nexport function formatDate(date) {\n  return (d3Time.timeSecond(date) < date ? FORMAT_MILLISECOND : d3Time.timeMinute(date) < date ? FORMAT_SECOND : d3Time.timeHour(date) < date ? FORMAT_MINUTE : d3Time.timeDay(date) < date ? FORMAT_HOUR : d3Time.timeMonth(date) < date ? d3Time.timeWeek(date) < date ? FORMAT_DAY : FORMAT_WEEK : d3Time.timeYear(date) < date ? FORMAT_MONTH : FORMAT_YEAR)(date);\n}","map":{"version":3,"mappings":"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","names":["_","d3TimeFormat","d3Time","stackByFields","collection","fields","fieldsArray","castArray","map","d","reduce","acc","field","dataPoint","get","isEmpty","concat","maybeLast","last","undefined","extractFields","minDomainValue","groupByFields","byFields","fieldArray","nearest","nums","value","length","first","mid","slice","minByFields","min","maxByFields","max","maxByFieldsStacked","sums","item","sum","toArray","pick","discreteTicks","array","count","isNil","step","Math","times","n","round","transformFromCenter","x","y","xCenter","yCenter","scale","FORMAT_MILLISECOND","timeFormat","FORMAT_SECOND","FORMAT_MINUTE","FORMAT_HOUR","FORMAT_DAY","FORMAT_WEEK","FORMAT_MONTH","FORMAT_YEAR","formatDate","date","timeSecond","timeMinute","timeHour","timeDay","timeMonth","timeWeek","timeYear"],"sources":["/home/skanda/node_modules/lucid-ui/src/util/chart-helpers.ts"],"sourcesContent":["import _ from 'lodash';\nimport * as d3TimeFormat from 'd3-time-format';\nimport * as d3Time from 'd3-time';\n\nexport type Collection = Array<{ [key: string]: any }>;\ntype Fields = string[] | string;\n\n/**\n * stackByFields\n *\n * D3's `stack` groups each series' data together but we sometimes we want the\n * stacked groups to remain grouped as in the original normalized data. This\n * function helps achieve that.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for row in the original `collection`\n */\nexport function stackByFields(\n\tcollection: Collection,\n\tfields: Fields\n): Array<Array<[number, number]>> {\n\tconst fieldsArray = _.castArray(fields);\n\n\treturn _.map(collection, (d) => {\n\t\treturn _.reduce<Fields, Array<[number, number]>>(\n\t\t\tfieldsArray,\n\t\t\t(acc, field) => {\n\t\t\t\tconst dataPoint: number = _.get(d, field, 0);\n\n\t\t\t\tif (_.isEmpty(acc)) {\n\t\t\t\t\treturn acc.concat([[0, dataPoint]]);\n\t\t\t\t}\n\n\t\t\t\tconst maybeLast = _.last(_.last(acc));\n\t\t\t\tconst last = maybeLast === undefined ? 0 : maybeLast;\n\n\t\t\t\treturn acc.concat([[last, last + dataPoint]]);\n\t\t\t},\n\t\t\t[]\n\t\t);\n\t});\n}\n\n/**\n * extractFields\n *\n * This will return the data in a similar format to stackByFields but without\n * the stacking.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for each field\n */\nexport function extractFields(\n\tcollection: Collection,\n\tfields: Fields,\n\tminDomainValue: number = 0\n): Array<Array<[number, number]>> {\n\tconst fieldsArray = _.castArray(fields);\n\n\treturn _.map(collection, (d) => {\n\t\treturn _.map(fieldsArray, (field) => [minDomainValue, _.get(d, field, 0)]);\n\t});\n}\n\n/**\n * groupByFields\n *\n * This will return the data in a similar format to d3Shape.stack\n * but without the stacking of the data.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for each field\n */\nexport function groupByFields(collection: Collection, fields: Fields) {\n\tconst fieldsArray = _.castArray(fields);\n\n\treturn _.map(fieldsArray, (field) => {\n\t\treturn _.map(collection, field);\n\t});\n}\n\n/**\n * byFields\n *\n * Takes a collection of data and returns an array of all the fields off that\n * collection.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {array}\n */\nexport function byFields(collection: Collection, fields: Fields) {\n\tconst fieldArray = _.castArray(fields);\n\n\treturn _.reduce(\n\t\tfieldArray,\n\t\t(acc: object[], field) => {\n\t\t\treturn acc.concat(_.map(collection, field));\n\t\t},\n\t\t[]\n\t);\n}\n\n/**\n * nearest\n *\n * Divide and conquer algorithm that helps find the nearest element to `value`\n * in `nums`\n *\n * @param {number[]} nums - sorted array of numbers to search through\n * @param {number} value - value you're trying to locate the nearest array element for\n * @return {number} - the nearest array element to the value\n */\nexport function nearest(nums: number[], value: number): number | undefined {\n\tif (nums.length < 2) {\n\t\treturn _.first(nums);\n\t}\n\n\tif (nums.length === 2) {\n\t\treturn value > (nums[0] + nums[1]) / 2 ? nums[1] : nums[0];\n\t}\n\n\tconst mid = nums.length >>> 1;\n\n\treturn nums[mid] > value\n\t\t? nearest(nums.slice(0, mid + 1), value)\n\t\t: nearest(nums.slice(mid), value);\n}\n\n/**\n * minByFields\n *\n * Returns the minimum element from a collection by a set of fields.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\nexport function minByFields(collection: Collection, fields: Fields) {\n\treturn _.min(byFields(collection, fields));\n}\n\n/**\n * maxByFields\n *\n * Returns the maximum element from a collection by a set of fields.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\nexport function maxByFields(collection: Collection, fields: Fields) {\n\treturn _.max(byFields(collection, fields));\n}\n\n/**\n * maxByFieldsStacked\n *\n * Returns the max sum of a set of fields from a collection\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\nexport function maxByFieldsStacked(collection: Collection, fields: Fields) {\n\tconst fieldArray = _.castArray(fields);\n\n\tconst sums = _.reduce(\n\t\tcollection,\n\t\t(acc: number[], item) => {\n\t\t\treturn acc.concat(_.sum(_.toArray(_.pick(item, fieldArray))));\n\t\t},\n\t\t[]\n\t);\n\n\treturn _.max(sums);\n}\n\n/**\n * discreteTicks\n *\n * Returns `count` evenly spaced, representative values from the `array`.\n *\n * @param {array} array\n * @param {number} size - should be greater than 1\n * @return {array}\n */\nexport function discreteTicks<T>(\n\tarray: T[],\n\tcount: number | undefined | null = null\n) {\n\tif (!array || _.isNil(count) || array.length <= count) {\n\t\treturn array;\n\t}\n\n\tconst step = (array.length - 1) / Math.max(1, count - 1);\n\n\treturn _.reduce(\n\t\t_.times(count),\n\t\t(acc: T[], n) => {\n\t\t\treturn acc.concat(array[Math.round(n * step)]);\n\t\t},\n\t\t[]\n\t);\n}\n\n/**\n * transformFromCenter\n *\n * Scaling paths from their center is tricky. This function\n * helps do that be generating a translate/scale transform\n * string with the correct numbers.\n *\n * @param {number} x - the x data point where you want the path to be centered at\n * @param {number} y - the y data point where you want the path to be centered at\n * @param {number} xCenter - the x coordinate of the center of the path you're trying to transform\n * @param {number} yCenter - the x coordinate of the center of the path you're trying to transform\n * @param {number} scale - number to scale to, 2 would be 2x bigger\n * @return {string} - transform string\n */\nexport function transformFromCenter(\n\tx: number,\n\ty: number,\n\txCenter: number,\n\tyCenter: number,\n\tscale: number\n) {\n\treturn `translate(${(1 - scale) * xCenter + (x - xCenter)}, ${\n\t\t(1 - scale) * yCenter + (y - yCenter)\n\t}) scale(${scale})`;\n}\n\nconst FORMAT_MILLISECOND = d3TimeFormat.timeFormat('.%L');\nconst FORMAT_SECOND = d3TimeFormat.timeFormat(':%S');\nconst FORMAT_MINUTE = d3TimeFormat.timeFormat('%I:%M');\nconst FORMAT_HOUR = d3TimeFormat.timeFormat('%I %p');\nconst FORMAT_DAY = d3TimeFormat.timeFormat('%a %d');\nconst FORMAT_WEEK = d3TimeFormat.timeFormat('%b %d');\nconst FORMAT_MONTH = d3TimeFormat.timeFormat('%b');\nconst FORMAT_YEAR = d3TimeFormat.timeFormat('%Y');\n\n/**\n * formatDate\n *\n * This function was written to be used for tick formatting with d3 time\n * scales.\n *\n * @param {date} date - input date\n * @return {string} - formatted date\n */\nexport function formatDate(date: Date): string {\n\treturn (\n\t\td3Time.timeSecond(date) < date\n\t\t\t? FORMAT_MILLISECOND\n\t\t\t: d3Time.timeMinute(date) < date\n\t\t\t? FORMAT_SECOND\n\t\t\t: d3Time.timeHour(date) < date\n\t\t\t? FORMAT_MINUTE\n\t\t\t: d3Time.timeDay(date) < date\n\t\t\t? FORMAT_HOUR\n\t\t\t: d3Time.timeMonth(date) < date\n\t\t\t? d3Time.timeWeek(date) < date\n\t\t\t\t? FORMAT_DAY\n\t\t\t\t: FORMAT_WEEK\n\t\t\t: d3Time.timeYear(date) < date\n\t\t\t? FORMAT_MONTH\n\t\t\t: FORMAT_YEAR\n\t)(date);\n}\n"]},"metadata":{},"sourceType":"module"}