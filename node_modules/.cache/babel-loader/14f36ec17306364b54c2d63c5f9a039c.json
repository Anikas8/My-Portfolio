{"ast":null,"code":"import _ from 'lodash';\nexport function getAbsoluteBoundingClientRect(domNode) {\n  if (!domNode) {\n    throw new Error('getAbsoluteBoundingClientRect called without a domNode');\n  }\n  const elementRect = domNode && domNode.getBoundingClientRect();\n  return {\n    bottom: elementRect.bottom + window.pageYOffset,\n    top: elementRect.top + window.pageYOffset,\n    left: elementRect.left + window.pageXOffset,\n    right: elementRect.right + window.pageXOffset,\n    height: elementRect.height,\n    width: elementRect.width\n  };\n}\nexport function scrollParentTo(domNode) {\n  let additionalOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (domNode) {\n    const parentElement = domNode.parentElement;\n    if (parentElement) {\n      if (parentElement.scrollTop > domNode.offsetTop - additionalOffset) {\n        // if the top of the node is above the scroll line,\n        // align to top\n        parentElement.scrollTop = domNode.offsetTop - additionalOffset;\n      } else if (parentElement.scrollTop + parentElement.clientHeight < domNode.offsetTop + domNode.offsetHeight) {\n        // else if the bottom of the node is below the fold,\n        // align to bottom\n        parentElement.scrollTop = domNode.offsetHeight - (parentElement.clientHeight - domNode.offsetTop);\n      } // else don't need to align anything\n    }\n  }\n}\n\nexport function dispatchDOMEvent(node, eventName, assignedEventProps) {\n  const event = document.createEvent('Event');\n  event.initEvent(eventName, true, true);\n  node.dispatchEvent(_.assign(event, assignedEventProps));\n  return event;\n}\n/**\n * sharesAncestor\n *\n * Recursively looks at `node` and its parents for `nodeName` and makes\n * sure it contains `siblingNode`.\n *\n * @param {Node} node - dom node to check if any of its ancestors are a `<label>`\n * @param {Node} siblingNode - dom node to see if it shares an ancestor\n * @param {string} nodeName - dom node name, should be uppercased, e.g. `LABEL` or `SPAN`\n * @returns {boolean}\n */\nexport function sharesAncestor(node, siblingNode, nodeName) {\n  const currentNodeName = _.get(node, 'nodeName');\n  const parentElement = _.get(node, 'parentElement');\n  if (currentNodeName === nodeName) {\n    return node.contains(siblingNode);\n  }\n  if (parentElement) {\n    return sharesAncestor(parentElement, siblingNode, nodeName);\n  }\n  return false;\n}\nexport function shiftChildren(parent) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (n < 0) {\n    _.times(Math.abs(n), () => {\n      parent.appendChild(parent.children[0]);\n    });\n  } else if (n > 0) {\n    _.times(n, () => {\n      parent.insertBefore(parent.children[parent.children.length - 1], parent.children[0]);\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["_","getAbsoluteBoundingClientRect","domNode","Error","elementRect","getBoundingClientRect","bottom","window","pageYOffset","top","left","pageXOffset","right","height","width","scrollParentTo","additionalOffset","parentElement","scrollTop","offsetTop","clientHeight","offsetHeight","dispatchDOMEvent","node","eventName","assignedEventProps","event","document","createEvent","initEvent","dispatchEvent","assign","sharesAncestor","siblingNode","nodeName","currentNodeName","get","contains","shiftChildren","parent","n","times","Math","abs","appendChild","children","insertBefore","length"],"sources":["/home/skanda/node_modules/lucid-ui/src/util/dom-helpers.ts"],"sourcesContent":["import _ from 'lodash';\n\ntype IClientRect = Omit<ClientRect, 'x' | 'y' | 'toJSON'>;\n\nexport function getAbsoluteBoundingClientRect(\n\tdomNode: HTMLElement | null\n): IClientRect {\n\tif (!domNode) {\n\t\tthrow new Error('getAbsoluteBoundingClientRect called without a domNode');\n\t}\n\n\tconst elementRect: ClientRect = domNode && domNode.getBoundingClientRect();\n\n\treturn {\n\t\tbottom: elementRect.bottom + window.pageYOffset,\n\t\ttop: elementRect.top + window.pageYOffset,\n\t\tleft: elementRect.left + window.pageXOffset,\n\t\tright: elementRect.right + window.pageXOffset,\n\t\theight: elementRect.height,\n\t\twidth: elementRect.width,\n\t};\n}\n\nexport function scrollParentTo(\n\tdomNode: HTMLElement | null,\n\tadditionalOffset: number = 0\n): void {\n\tif (domNode) {\n\t\tconst parentElement = domNode.parentElement;\n\n\t\tif (parentElement) {\n\t\t\tif (parentElement.scrollTop > domNode.offsetTop - additionalOffset) {\n\t\t\t\t// if the top of the node is above the scroll line,\n\t\t\t\t// align to top\n\t\t\t\tparentElement.scrollTop = domNode.offsetTop - additionalOffset;\n\t\t\t} else if (\n\t\t\t\tparentElement.scrollTop + parentElement.clientHeight <\n\t\t\t\tdomNode.offsetTop + domNode.offsetHeight\n\t\t\t) {\n\t\t\t\t// else if the bottom of the node is below the fold,\n\t\t\t\t// align to bottom\n\t\t\t\tparentElement.scrollTop =\n\t\t\t\t\tdomNode.offsetHeight -\n\t\t\t\t\t(parentElement.clientHeight - domNode.offsetTop);\n\t\t\t} // else don't need to align anything\n\t\t}\n\t}\n}\n\nexport function dispatchDOMEvent(\n\tnode: EventTarget,\n\teventName: string,\n\tassignedEventProps?: any\n) {\n\tconst event = document.createEvent('Event');\n\tevent.initEvent(eventName, true, true);\n\tnode.dispatchEvent(_.assign(event, assignedEventProps));\n\treturn event;\n}\n\n/**\n * sharesAncestor\n *\n * Recursively looks at `node` and its parents for `nodeName` and makes\n * sure it contains `siblingNode`.\n *\n * @param {Node} node - dom node to check if any of its ancestors are a `<label>`\n * @param {Node} siblingNode - dom node to see if it shares an ancestor\n * @param {string} nodeName - dom node name, should be uppercased, e.g. `LABEL` or `SPAN`\n * @returns {boolean}\n */\nexport function sharesAncestor(\n\tnode: Node,\n\tsiblingNode: Node | null,\n\tnodeName: string\n): boolean {\n\tconst currentNodeName = _.get(node, 'nodeName');\n\tconst parentElement = _.get(node, 'parentElement');\n\n\tif (currentNodeName === nodeName) {\n\t\treturn node.contains(siblingNode);\n\t}\n\n\tif (parentElement) {\n\t\treturn sharesAncestor(parentElement, siblingNode, nodeName);\n\t}\n\n\treturn false;\n}\n\nexport function shiftChildren(parent: HTMLElement, n: number = 1): void {\n\tif (n < 0) {\n\t\t_.times(Math.abs(n), () => {\n\t\t\tparent.appendChild(parent.children[0]);\n\t\t});\n\t} else if (n > 0) {\n\t\t_.times(n, () => {\n\t\t\tparent.insertBefore(\n\t\t\t\tparent.children[parent.children.length - 1],\n\t\t\t\tparent.children[0]\n\t\t\t);\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}