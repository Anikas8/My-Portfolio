{"ast":null,"code":"import _ from 'lodash';\nimport React from 'react';\n/**\n * Performs a regex search and returns a partitioning around the matching substring: [pre, match, post]\n *\n * @param text: string to search\n * @param pattern: RegExp patten\n * @param length (optional): provide a max length for the matching substring\n *\n * @return string[]\n */\nexport function partitionText(text, pattern, length) {\n  let index;\n  if (length) {\n    index = text.search(pattern);\n  } else {\n    const result = pattern.exec(text);\n    if (result) {\n      length = result[0].length;\n      index = result.index;\n    } else {\n      length = 0;\n      index = -1;\n    }\n  }\n  if (index === -1) {\n    return ['', '', text];\n  } else if (index === 0) {\n    return ['', text.substr(0, length), text.substring(length)];\n  } else {\n    return [text.substring(0, index), text.substr(index, length), text.substring(index + length)];\n  }\n}\n/**\n * Returns the combined text of all descendant strings\n *\n * @param node: a component props object\n *\n * @return string\n */\nexport function getCombinedChildText(node) {\n  if (!node || !node.children) {\n    return '';\n  }\n  if (_.isString(node.children)) {\n    return node.children;\n  }\n  return React.Children.toArray(node.children).filter(child => _.has(child, 'props')) // filter out primitive types\n  .map(child => getCombinedChildText(child.props)).reduce((combinedText, childText) => combinedText + childText, _.find(React.Children.toArray(node.children), _.isString) || '');\n}\n/**\n * Perform a regex search on all text found in a component's descendants\n *\n * @param text\n * @param node\n *\n * @return boolean\n */\nexport function propsSearch() {\n  let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!text) {\n    return true;\n  }\n  return new RegExp(_.escapeRegExp(text), 'i').test(getCombinedChildText(node));\n}","map":{"version":3,"mappings":"AAAA,OAAOA,CAAC,MAAM,QAAQ;AACtB,OAAOC,KAAK,MAAM,OAAO;AAEzB;;;;;;;;;AASA,OAAM,SAAUC,aAAa,CAC5BC,IAAY,EACZC,OAAe,EACfC,MAAe;EAEf,IAAIC,KAAa;EAEjB,IAAID,MAAM,EAAE;IACXC,KAAK,GAAGH,IAAI,CAACI,MAAM,CAACH,OAAO,CAAC;GAC5B,MAAM;IACN,MAAMI,MAAM,GAAGJ,OAAO,CAACK,IAAI,CAACN,IAAI,CAAC;IACjC,IAAIK,MAAM,EAAE;MACXH,MAAM,GAAGG,MAAM,CAAC,CAAC,CAAC,CAACH,MAAM;MACzBC,KAAK,GAAGE,MAAM,CAACF,KAAK;KACpB,MAAM;MACND,MAAM,GAAG,CAAC;MACVC,KAAK,GAAG,CAAC,CAAC;;;EAIZ,IAAIA,KAAK,KAAK,CAAC,CAAC,EAAE;IACjB,OAAO,CAAC,EAAE,EAAE,EAAE,EAAEH,IAAI,CAAC;GACrB,MAAM,IAAIG,KAAK,KAAK,CAAC,EAAE;IACvB,OAAO,CAAC,EAAE,EAAEH,IAAI,CAACO,MAAM,CAAC,CAAC,EAAEL,MAAM,CAAC,EAAEF,IAAI,CAACQ,SAAS,CAACN,MAAM,CAAC,CAAC;GAC3D,MAAM;IACN,OAAO,CACNF,IAAI,CAACQ,SAAS,CAAC,CAAC,EAAEL,KAAK,CAAC,EACxBH,IAAI,CAACO,MAAM,CAACJ,KAAK,EAAED,MAAM,CAAC,EAC1BF,IAAI,CAACQ,SAAS,CAACL,KAAK,GAAGD,MAAM,CAAC,CAC9B;;AAEH;AAEA;;;;;;;AAOA,OAAM,SAAUO,oBAAoB,CAACC,IAAI;EACxC,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACC,QAAQ,EAAE;IAC5B,OAAO,EAAE;;EAGV,IAAId,CAAC,CAACe,QAAQ,CAACF,IAAI,CAACC,QAAQ,CAAC,EAAE;IAC9B,OAAOD,IAAI,CAACC,QAAQ;;EAGrB,OAAOb,KAAK,CAACe,QAAQ,CAACC,OAAO,CAACJ,IAAI,CAACC,QAAQ,CAAC,CAC1CI,MAAM,CAAEC,KAAK,IAAkCnB,CAAC,CAACoB,GAAG,CAACD,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;EAAA,CACtEE,GAAG,CAAEF,KAAK,IAAKP,oBAAoB,CAACO,KAAK,CAACG,KAAK,CAAC,CAAC,CACjDC,MAAM,CACN,CAACC,YAAY,EAAEC,SAAS,KAAKD,YAAY,GAAGC,SAAS,EACrDzB,CAAC,CAAC0B,IAAI,CAACzB,KAAK,CAACe,QAAQ,CAACC,OAAO,CAACJ,IAAI,CAACC,QAAQ,CAAC,EAAEd,CAAC,CAACe,QAAQ,CAAC,IAAI,EAAE,CAC/D;AACH;AAEA;;;;;;;;AAQA,OAAM,SAAUY,WAAW,GAAwC;EAAA,IAAvCxB,2EAAsB,IAAI;EAAA,IAAEU,IAAI,uEAAG,IAAI;EAClE,IAAI,CAACV,IAAI,EAAE;IACV,OAAO,IAAI;;EAGZ,OAAO,IAAIyB,MAAM,CAAC5B,CAAC,CAAC6B,YAAY,CAAC1B,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC2B,IAAI,CAAClB,oBAAoB,CAACC,IAAI,CAAC,CAAC;AAC9E","names":["_","React","partitionText","text","pattern","length","index","search","result","exec","substr","substring","getCombinedChildText","node","children","isString","Children","toArray","filter","child","has","map","props","reduce","combinedText","childText","find","propsSearch","RegExp","escapeRegExp","test"],"sources":["/home/skanda/node_modules/lucid-ui/src/util/text-manipulation.ts"],"sourcesContent":["import _ from 'lodash';\nimport React from 'react';\n\n/**\n * Performs a regex search and returns a partitioning around the matching substring: [pre, match, post]\n *\n * @param text: string to search\n * @param pattern: RegExp patten\n * @param length (optional): provide a max length for the matching substring\n *\n * @return string[]\n */\nexport function partitionText(\n\ttext: string,\n\tpattern: RegExp,\n\tlength?: number\n): string[] {\n\tlet index: number;\n\n\tif (length) {\n\t\tindex = text.search(pattern);\n\t} else {\n\t\tconst result = pattern.exec(text);\n\t\tif (result) {\n\t\t\tlength = result[0].length;\n\t\t\tindex = result.index;\n\t\t} else {\n\t\t\tlength = 0;\n\t\t\tindex = -1;\n\t\t}\n\t}\n\n\tif (index === -1) {\n\t\treturn ['', '', text];\n\t} else if (index === 0) {\n\t\treturn ['', text.substr(0, length), text.substring(length)];\n\t} else {\n\t\treturn [\n\t\t\ttext.substring(0, index),\n\t\t\ttext.substr(index, length),\n\t\t\ttext.substring(index + length),\n\t\t];\n\t}\n}\n\n/**\n * Returns the combined text of all descendant strings\n *\n * @param node: a component props object\n *\n * @return string\n */\nexport function getCombinedChildText(node): string {\n\tif (!node || !node.children) {\n\t\treturn '';\n\t}\n\n\tif (_.isString(node.children)) {\n\t\treturn node.children;\n\t}\n\n\treturn React.Children.toArray(node.children)\n\t\t.filter((child): child is React.ReactElement => _.has(child, 'props')) // filter out primitive types\n\t\t.map((child) => getCombinedChildText(child.props))\n\t\t.reduce(\n\t\t\t(combinedText, childText) => combinedText + childText,\n\t\t\t_.find(React.Children.toArray(node.children), _.isString) || ''\n\t\t);\n}\n\n/**\n * Perform a regex search on all text found in a component's descendants\n *\n * @param text\n * @param node\n *\n * @return boolean\n */\nexport function propsSearch(text: string | null = null, node = null) {\n\tif (!text) {\n\t\treturn true;\n\t}\n\n\treturn new RegExp(_.escapeRegExp(text), 'i').test(getCombinedChildText(node));\n}\n"]},"metadata":{},"sourceType":"module"}