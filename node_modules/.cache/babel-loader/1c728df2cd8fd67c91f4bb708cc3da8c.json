{"ast":null,"code":"import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { partitionText } from '../../util/text-manipulation';\nimport { lucidClassNames } from '../../util/style-helpers';\nconst cx = lucidClassNames.bind('&-Underline');\nconst {\n  node,\n  string,\n  instanceOf,\n  oneOfType\n} = PropTypes;\nconst matchAllRegexp = /^.*$/;\nexport const Underline = _ref => {\n  let {\n    className,\n    children,\n    match,\n    ...passThroughs\n  } = _ref;\n  if (!_.isRegExp(match)) {\n    if (_.isString(match)) {\n      match = new RegExp(_.escapeRegExp(match), 'i');\n    } else {\n      match = matchAllRegexp;\n    }\n  }\n  if (!_.isString(children)) {\n    return React.createElement(\"span\", {\n      className: cx('&', className),\n      ...passThroughs\n    }, React.createElement(\"span\", {\n      style: match === matchAllRegexp ? {\n        textDecoration: 'underline'\n      } : undefined\n    }, children));\n  }\n  const [pre, matchText, post] = partitionText(children, match);\n  return React.createElement(\"span\", {\n    className: cx('&', className),\n    ...passThroughs\n  }, [pre && React.createElement(\"span\", {\n    key: 'pre'\n  }, pre), matchText && React.createElement(\"span\", {\n    key: 'match',\n    style: {\n      textDecoration: 'underline'\n    }\n  }, matchText), post && React.createElement(\"span\", {\n    key: 'post'\n  }, post)]);\n};\nUnderline.displayName = 'Underline';\nUnderline.peek = {\n  description: `Underlines a portion of text that matches a given pattern.`,\n  categories: ['controls', 'selectors']\n};\nUnderline.propTypes = {\n  /**\n      Appended to the component-specific class names set on the root element.\n  */\n  className: string,\n  /**\n      Text to be partially or fully underlined. If non-text is passed as\n      children, it will not attempt to match the given pattern.\n  */\n  children: node,\n  /**\n      The first match of the given pattern has the underline style applied to it.\n  */\n  match: oneOfType([string, instanceOf(RegExp)])\n};\nexport default Underline;","map":{"version":3,"mappings":"AAAA,OAAOA,CAAC,MAAM,QAAQ;AACtB,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,SAAS,MAAM,YAAY;AAElC,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,eAAe,QAAQ,0BAA0B;AAG1D,MAAMC,EAAE,GAAGD,eAAe,CAACE,IAAI,CAAC,aAAa,CAAC;AAE9C,MAAM;EAAEC,IAAI;EAAEC,MAAM;EAAEC,UAAU;EAAEC;AAAS,CAAE,GAAGR,SAAS;AAEzD,MAAMS,cAAc,GAAG,MAAM;AAY7B,OAAO,MAAMC,SAAS,GAAG,QAKiB;EAAA,IALhB;IACzBC,SAAS;IACTC,QAAQ;IACRC,KAAK;IACL,GAAGC;EAAY,CACE;EACjB,IAAI,CAAChB,CAAC,CAACiB,QAAQ,CAACF,KAAK,CAAC,EAAE;IACvB,IAAIf,CAAC,CAACkB,QAAQ,CAACH,KAAK,CAAC,EAAE;MACtBA,KAAK,GAAG,IAAII,MAAM,CAACnB,CAAC,CAACoB,YAAY,CAACL,KAAK,CAAC,EAAE,GAAG,CAAC;KAC9C,MAAM;MACNA,KAAK,GAAGJ,cAAc;;;EAIxB,IAAI,CAACX,CAAC,CAACkB,QAAQ,CAACJ,QAAQ,CAAC,EAAE;IAC1B,OACCb;MAAMY,SAAS,EAAER,EAAE,CAAC,GAAG,EAAEQ,SAAS,CAAC;MAAA,GAAMG;IAAY,GACpDf;MACCoB,KAAK,EACJN,KAAK,KAAKJ,cAAc,GACrB;QAAEW,cAAc,EAAE;MAAW,CAAE,GAC/BC;IAAS,GAGZT,QAAQ,CACH,CACD;;EAIT,MAAM,CAACU,GAAG,EAAEC,SAAS,EAAEC,IAAI,CAAC,GAAGvB,aAAa,CAACW,QAAQ,EAAEC,KAAK,CAAC;EAE7D,OACCd;IAAMY,SAAS,EAAER,EAAE,CAAC,GAAG,EAAEQ,SAAS,CAAC;IAAA,GAAMG;EAAY,GACnD,CACAQ,GAAG,IAAIvB;IAAM0B,GAAG,EAAC;EAAK,GAAEH,GAAG,CAAQ,EACnCC,SAAS,IACRxB;IAAM0B,GAAG,EAAC,OAAO;IAACN,KAAK,EAAE;MAAEC,cAAc,EAAE;IAAW;EAAE,GACtDG,SAAS,CAEX,EACDC,IAAI,IAAIzB;IAAM0B,GAAG,EAAC;EAAM,GAAED,IAAI,CAAQ,CACtC,CACK;AAET,CAAC;AAEDd,SAAS,CAACgB,WAAW,GAAG,WAAW;AACnChB,SAAS,CAACiB,IAAI,GAAG;EAChBC,WAAW,EAAE,4DAA4D;EACzEC,UAAU,EAAE,CAAC,UAAU,EAAE,WAAW;CACpC;AACDnB,SAAS,CAACoB,SAAS,GAAG;EACrB;;;EAGAnB,SAAS,EAAEL,MAAM;EACjB;;;;EAIAM,QAAQ,EAAEP,IAAI;EACd;;;EAGAQ,KAAK,EAAEL,SAAS,CAAC,CAACF,MAAM,EAAEC,UAAU,CAACU,MAAM,CAAC,CAAC;CAC7C;AAED,eAAeP,SAAS","names":["_","React","PropTypes","partitionText","lucidClassNames","cx","bind","node","string","instanceOf","oneOfType","matchAllRegexp","Underline","className","children","match","passThroughs","isRegExp","isString","RegExp","escapeRegExp","style","textDecoration","undefined","pre","matchText","post","key","displayName","peek","description","categories","propTypes"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/Underline/Underline.tsx"],"sourcesContent":["import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport { partitionText } from '../../util/text-manipulation';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { StandardProps } from '../../util/component-types';\n\nconst cx = lucidClassNames.bind('&-Underline');\n\nconst { node, string, instanceOf, oneOfType } = PropTypes;\n\nconst matchAllRegexp = /^.*$/;\n\nexport interface IUnderlineProps\n\textends StandardProps,\n\t\tReact.DetailedHTMLProps<\n\t\t\tReact.HTMLAttributes<HTMLSpanElement>,\n\t\t\tHTMLSpanElement\n\t\t> {\n\t/** The first match of the given pattern has the underline style applied to it. */\n\tmatch?: string | RegExp;\n}\n\nexport const Underline = ({\n\tclassName,\n\tchildren,\n\tmatch,\n\t...passThroughs\n}: IUnderlineProps): React.ReactElement => {\n\tif (!_.isRegExp(match)) {\n\t\tif (_.isString(match)) {\n\t\t\tmatch = new RegExp(_.escapeRegExp(match), 'i');\n\t\t} else {\n\t\t\tmatch = matchAllRegexp;\n\t\t}\n\t}\n\n\tif (!_.isString(children)) {\n\t\treturn (\n\t\t\t<span className={cx('&', className)} {...passThroughs}>\n\t\t\t\t<span\n\t\t\t\t\tstyle={\n\t\t\t\t\t\tmatch === matchAllRegexp\n\t\t\t\t\t\t\t? { textDecoration: 'underline' }\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t\t{children}\n\t\t\t\t</span>\n\t\t\t</span>\n\t\t);\n\t}\n\n\tconst [pre, matchText, post] = partitionText(children, match);\n\n\treturn (\n\t\t<span className={cx('&', className)} {...passThroughs}>\n\t\t\t{[\n\t\t\t\tpre && <span key='pre'>{pre}</span>,\n\t\t\t\tmatchText && (\n\t\t\t\t\t<span key='match' style={{ textDecoration: 'underline' }}>\n\t\t\t\t\t\t{matchText}\n\t\t\t\t\t</span>\n\t\t\t\t),\n\t\t\t\tpost && <span key='post'>{post}</span>,\n\t\t\t]}\n\t\t</span>\n\t);\n};\n\nUnderline.displayName = 'Underline';\nUnderline.peek = {\n\tdescription: `Underlines a portion of text that matches a given pattern.`,\n\tcategories: ['controls', 'selectors'],\n};\nUnderline.propTypes = {\n\t/**\n\t\tAppended to the component-specific class names set on the root element.\n\t*/\n\tclassName: string,\n\t/**\n\t\tText to be partially or fully underlined. If non-text is passed as\n\t\tchildren, it will not attempt to match the given pattern.\n\t*/\n\tchildren: node,\n\t/**\n\t\tThe first match of the given pattern has the underline style applied to it.\n\t*/\n\tmatch: oneOfType([string, instanceOf(RegExp)]),\n};\n\nexport default Underline;\n"]},"metadata":{},"sourceType":"module"}