{"ast":null,"code":"import React, { isValidElement } from 'react';\nimport _ from 'lodash';\nimport { logger } from './logger';\nimport { createSelector } from 'reselect';\nimport createClass from 'create-react-class';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n/*\n    Returns an array of paths for each reducer function\n*/\nexport function getDeepPaths() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return _.reduce(obj, (terminalKeys, value, key) => isPlainObjectOrEsModule(value) ?\n  //getDeepPaths if value is a module or object (another Reducers)\n  terminalKeys.concat(getDeepPaths(value, path.concat(key))) :\n  //add key to terminalKeys (probably a Reducer (function))\n  terminalKeys.concat([path.concat(key)]), []);\n}\nexport function isPlainObjectOrEsModule(obj) {\n  return _.isPlainObject(obj) || _.get(obj, '__esModule', false);\n}\n/**\n    Recursively removes function type properties from obj\n */\nexport function omitFunctionPropsDeep() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return _.reduce(obj, (memo, value, key) => {\n    if (isPlainObjectOrEsModule(value)) {\n      memo[key] = omitFunctionPropsDeep(value);\n    } else if (!_.isFunction(value)) {\n      memo[key] = value;\n    }\n    return memo;\n  }, {});\n}\nexport function bindReducerToState(reducerFunction, _ref) {\n  let {\n    getState,\n    setState\n  } = _ref;\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const localPath = _.take(path, _.size(path) - 1);\n  return _.assign(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (_.isEmpty(localPath)) {\n      // Source of bug, `reducerFunction` returns undefined\n      setState(reducerFunction(getState(), ...args));\n    } else {\n      const localNextState = reducerFunction(_.get(getState(), localPath), ...args);\n      setState(_.set(_.clone(getState()), localPath, localNextState));\n    }\n  }, {\n    path\n  });\n}\nexport function bindReducersToState(reducers, _ref2) {\n  let {\n    getState,\n    setState\n  } = _ref2;\n  return _.reduce(getDeepPaths(reducers), (memo, path) => {\n    return _.set(memo, path, bindReducerToState(_.get(reducers, path), {\n      getState,\n      setState\n    }, path));\n  }, {});\n}\n/*\n\n*/\nexport function getStatefulPropsContext(reducers, _ref3) {\n  let {\n    getState,\n    setState\n  } = _ref3;\n  const boundReducers = bindReducersToState(reducers, {\n    getState,\n    setState\n  });\n  const combineFunctionsCustomizer = (objValue, srcValue) => {\n    if (_.isFunction(srcValue) && _.isFunction(objValue)) {\n      return function () {\n        objValue(...arguments);\n        return srcValue(...arguments);\n      };\n    }\n    return safeMerge(objValue, srcValue);\n  };\n  const bindFunctionOverwritesCustomizer = (objValue, srcValue) => {\n    if (_.isFunction(srcValue) && _.isFunction(objValue)) {\n      return bindReducerToState(srcValue, {\n        getState,\n        setState\n      }, objValue.path);\n    }\n    return safeMerge(objValue, srcValue);\n  };\n  return {\n    getPropReplaceReducers(props) {\n      return _.mergeWith({}, boundReducers, getState(), props, bindFunctionOverwritesCustomizer);\n    },\n    getProps(props) {\n      return _.mergeWith({}, boundReducers, getState(), props, combineFunctionsCustomizer);\n    }\n  };\n}\n/**\n * reduceSelectors\n *\n * Generates a root selector from a tree of selectors\n * @param {Object} selectors - a tree of selectors\n * @returns {function} root selector that when called with state, calls each of\n * the selectors in the tree with the state local to that selector.\n *\n * This function is memoized because it's recursive, and we want it to reuse\n * the functions created in the recursive reduce because those functions are\n * also memoized (reselect selectors are memoized with a cache of 1) and we want\n * to maintain their caches.\n *\n * TODO: the types suck on this function but we spent a couple hours trying to\n * get them to work and we couldn't figure out how to get generics to pass\n * through _.memoize correctly. ¯\\_(ツ)_/¯\n */\nexport const reduceSelectors = _.memoize(selectors => {\n  if (!isPlainObjectOrEsModule(selectors)) {\n    throw new Error('Selectors must be a plain object with function or plain object values');\n  }\n  /**\n   * For each iteration of `reduceSelectors`, we return a memoized selector so\n   * that individual branches maintain reference equality if they haven't been\n   * modified, even if a sibling (and therefore the parent) has been modified.\n   */\n  return createSelector(_.identity, state => _.reduce(selectors, (acc, selector, key) => ({\n    ...acc,\n    [key]: _.isFunction(selector) ? selector(state) : reduceSelectors(selector)(state[key])\n  }), state));\n});\nexport function safeMerge(objValue, srcValue) {\n  // don't merge arrays\n  if (_.isArray(srcValue) && _.isArray(objValue)) {\n    return srcValue;\n  }\n  // guards against traversing react elements which can cause cyclical recursion\n  // If we don't have this clause, lodash (as of 4.7.0) will attempt to\n  // deeply clone the react children, which is really freaking slow.\n  if (isValidElement(srcValue) || _.isArray(srcValue) && _.some(srcValue, isValidElement) || _.isArray(srcValue) && _.isUndefined(objValue)) {\n    return srcValue;\n  }\n}\nexport function buildHybridComponent(baseComponent) {\n  let {\n    replaceEvents = false,\n    // if true, function props replace the existing reducers, else they are invoked *after* state reducer returns\n    reducers = _.get(baseComponent, 'definition.statics.reducers', {}),\n    selectors = _.get(baseComponent, 'definition.statics.selectors', {})\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    _isLucidHybridComponent,\n    displayName,\n    propTypes,\n    definition: {\n      statics = {}\n    } = {},\n    defaultProps\n  } = baseComponent;\n  if (_isLucidHybridComponent) {\n    logger.warnOnce(displayName, `Lucid: you are trying to apply buildHybridComponent to ${displayName}, which is already a hybrid component. Lucid exports hybrid components by default. To access the dumb components, use the -Dumb suffix, e.g. \"ComponentDumb\"`);\n    return baseComponent;\n  }\n  const selector = reduceSelectors(selectors);\n  return createClass({\n    propTypes,\n    statics: {\n      _isLucidHybridComponent: true,\n      peekDefaultProps: defaultProps,\n      ...statics\n    },\n    displayName,\n    getInitialState() {\n      const {\n        initialState\n      } = this.props; //initial state overrides\n      return _.mergeWith({}, omitFunctionPropsDeep(baseComponent.defaultProps), initialState, safeMerge);\n    },\n    UNSAFE_componentWillMount() {\n      let synchronousState = this.state; //store reference to state, use in place of `this.state` in `getState`\n      this.boundContext = getStatefulPropsContext(reducers, {\n        getState: () => _.mergeWith({}, omitFunctionPropsDeep(synchronousState), omitFunctionPropsDeep(this.props), safeMerge),\n        setState: state => {\n          synchronousState = state; //synchronously update the state reference\n          this.setState(state);\n        }\n      });\n    },\n    render() {\n      if (replaceEvents) {\n        return React.createElement(baseComponent, selector(this.boundContext.getPropReplaceReducers(this.props)), this.props.children);\n      }\n      return React.createElement(baseComponent, selector(this.boundContext.getProps(this.props)), this.props.children);\n    }\n  });\n}\nexport function buildModernHybridComponent(BaseComponent, _ref4) {\n  let {\n    replaceEvents = false,\n    reducers = {},\n    selectors = {}\n  } = _ref4;\n  // TODO: make sure hybrid components don't get double wrapped. Maybe use a type guard?\n  const selector = reduceSelectors(selectors);\n  class HybridComponent extends React.Component {\n    // Note: we purposefully *do not* set defaultProps here as that would\n    // effectively eliminate our ability to distinguish what props the user\n    // explicity included.\n    constructor(props) {\n      super(props);\n      const {\n        initialState\n      } = props; // initial state overrides\n      this.state = _.mergeWith({}, omitFunctionPropsDeep(BaseComponent.defaultProps), initialState, safeMerge);\n    }\n    UNSAFE_componentWillMount() {\n      // store reference to state, use in place of `this.state` in `getState`\n      let synchronousState = this.state;\n      this.boundContext = getStatefulPropsContext(reducers, {\n        getState: () => _.mergeWith({}, omitFunctionPropsDeep(synchronousState), omitFunctionPropsDeep(this.props), safeMerge),\n        setState: state => {\n          synchronousState = state; //synchronously update the state reference\n          this.setState(state);\n        }\n      });\n    }\n    render() {\n      if (this.boundContext === undefined) {\n        return null;\n      }\n      if (replaceEvents) {\n        return React.createElement(BaseComponent, selector(this.boundContext.getPropReplaceReducers(this.props)), this.props.children);\n      }\n      return React.createElement(BaseComponent, selector(this.boundContext.getProps(this.props)), this.props.children);\n    }\n  }\n  // It would be nice to prepend \"Hybrid\" to this but some of our component\n  // sadly rely on the displayName remaining unchanged. E.g. `VerticalListMenu`.\n  HybridComponent.displayName = BaseComponent.displayName;\n  HybridComponent.propTypes = BaseComponent.propTypes;\n  HybridComponent.reducers = reducers;\n  HybridComponent.selectors = selectors;\n  HybridComponent.peekDefaultProps = BaseComponent.defaultProps;\n  // I used a type cast and intersection with `BaseType` here because I\n  // couldn't figure out any other way to generate a valid type signuture to\n  // reflected all the statics on the unerlying base component. @jondlm 2019-11-27\n  // @ts-ignore\n  return hoistNonReactStatics(HybridComponent, BaseComponent);\n}\n/*\nexport function buildStatefulComponent(...args: any[]) {\n    logger.warnOnce(\n        'buildHybridComponent-once',\n        'Lucid: buildStatefulComponent has been renamed to buildHybridComponent.'\n    );\n\n    // We don't really care about type checking our legacy buildHybridComponent\n    // @ts-ignore\n    return buildHybridComponent(...args);\n}\n     */","map":{"version":3,"mappings":"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","names":["React","isValidElement","_","logger","createSelector","createClass","hoistNonReactStatics","getDeepPaths","obj","path","reduce","terminalKeys","value","key","isPlainObjectOrEsModule","concat","isPlainObject","get","omitFunctionPropsDeep","memo","isFunction","bindReducerToState","reducerFunction","getState","setState","localPath","take","size","assign","args","isEmpty","localNextState","set","clone","bindReducersToState","reducers","getStatefulPropsContext","boundReducers","combineFunctionsCustomizer","objValue","srcValue","safeMerge","bindFunctionOverwritesCustomizer","getPropReplaceReducers","props","mergeWith","getProps","reduceSelectors","memoize","selectors","Error","identity","state","acc","selector","isArray","some","isUndefined","buildHybridComponent","baseComponent","replaceEvents","_isLucidHybridComponent","displayName","propTypes","definition","statics","defaultProps","warnOnce","peekDefaultProps","getInitialState","initialState","UNSAFE_componentWillMount","synchronousState","boundContext","render","createElement","children","buildModernHybridComponent","BaseComponent","HybridComponent","Component","constructor","undefined"],"sources":["/home/skanda/node_modules/lucid-ui/src/util/state-management.ts"],"sourcesContent":["import React, { isValidElement } from 'react';\nimport _ from 'lodash';\nimport { logger } from './logger';\nimport { createSelector } from 'reselect';\nimport createClass from 'create-react-class';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\n// TODO: could we somehow type the `...args` with a generic?\nexport type Reducer<S extends object> = (arg0: S, ...args: any[]) => S;\n\nexport type Reducers<P, S extends object> = {\n\t//TODO: used any here to cover cases where a component's reducers file also\n\t//exports child component reducers, e.g. SingleSelect/DropMenu\n\t[K in keyof P]?: Reducer<S> | Reducers<P[K], S> | Reducers<P[K], any>;\n};\n\nexport type Selector<S> = (arg0: S) => any;\nexport type Selectors<P, S extends object> = {\n\t[K in keyof P]?: (arg0: S) => any;\n};\n\ninterface IStateOptions<S extends object> {\n\tgetState: () => S;\n\tsetState: (arg0: S) => void;\n}\n\ninterface IBoundContext<P, S extends object> {\n\tgetPropReplaceReducers(props: P): {} & S & P;\n\tgetProps(props: P): {} & S & P;\n}\n\ninterface IBuildHybridComponentOptions<P = {}, S extends object = {}> {\n\treplaceEvents?: boolean; // TODO: pretty sure this isn't used in anx-react or lucid, I looked through the git history and even when Joe wrote it in 2016 he didn't seem to need it for any concrete use case\n\treducers?: Reducers<P, S>;\n\tselectors?: Selectors<P, S>;\n}\n\ninterface IBaseComponentType<P> {\n\tdisplayName: string;\n}\n\n/*\n\tReturns an array of paths for each reducer function\n*/\nexport function getDeepPaths(\n\tobj: { [k: string]: any } | null = null,\n\tpath: string[] = []\n): string[][] {\n\treturn _.reduce(\n\t\tobj,\n\t\t(terminalKeys: string[][], value, key) =>\n\t\t\tisPlainObjectOrEsModule(value)\n\t\t\t\t? //getDeepPaths if value is a module or object (another Reducers)\n\t\t\t\t  terminalKeys.concat(getDeepPaths(value, path.concat(key)))\n\t\t\t\t: //add key to terminalKeys (probably a Reducer (function))\n\t\t\t\t  terminalKeys.concat([path.concat(key)]),\n\t\t[]\n\t);\n}\n\nexport function isPlainObjectOrEsModule(obj: any): boolean {\n\treturn _.isPlainObject(obj) || _.get(obj, '__esModule', false);\n}\n\n/**\n\tRecursively removes function type properties from obj\n */\nexport function omitFunctionPropsDeep<P>(obj: object | P | null = null) {\n\treturn _.reduce<{ [k: string]: any }, { [k: string]: any }>(\n\t\tobj,\n\t\t(memo, value, key) => {\n\t\t\tif (isPlainObjectOrEsModule(value)) {\n\t\t\t\tmemo[key] = omitFunctionPropsDeep(value);\n\t\t\t} else if (!_.isFunction(value)) {\n\t\t\t\tmemo[key] = value;\n\t\t\t}\n\t\t\treturn memo;\n\t\t},\n\t\t{}\n\t);\n}\n\nexport function bindReducerToState<P, S extends object>(\n\treducerFunction: Reducer<S>,\n\t{ getState, setState }: IStateOptions<S>,\n\tpath: string[] = []\n) {\n\tconst localPath = _.take(path, _.size(path) - 1);\n\treturn _.assign(\n\t\tfunction (...args: any[]) {\n\t\t\tif (_.isEmpty(localPath)) {\n\t\t\t\t// Source of bug, `reducerFunction` returns undefined\n\t\t\t\tsetState(reducerFunction(getState(), ...args));\n\t\t\t} else {\n\t\t\t\tconst localNextState = reducerFunction(\n\t\t\t\t\t_.get(getState(), localPath),\n\t\t\t\t\t...args\n\t\t\t\t);\n\t\t\t\tsetState(_.set<S>(_.clone(getState()), localPath, localNextState));\n\t\t\t}\n\t\t},\n\t\t{ path }\n\t);\n}\n\nexport function bindReducersToState<P, S extends object>(\n\treducers: Reducers<P, S>,\n\t{ getState, setState }: IStateOptions<S>\n) {\n\treturn _.reduce(\n\t\tgetDeepPaths(reducers),\n\t\t(memo, path) => {\n\t\t\treturn _.set(\n\t\t\t\tmemo,\n\t\t\t\tpath,\n\t\t\t\tbindReducerToState(_.get(reducers, path), { getState, setState }, path)\n\t\t\t);\n\t\t},\n\t\t{}\n\t);\n}\n\n/*\n\n*/\nexport function getStatefulPropsContext<P, S extends object>(\n\treducers: Reducers<P, S>,\n\t{ getState, setState }: IStateOptions<S>\n): IBoundContext<P, S> {\n\tconst boundReducers = bindReducersToState(reducers, { getState, setState });\n\n\tconst combineFunctionsCustomizer = (objValue: any, srcValue: any) => {\n\t\tif (_.isFunction(srcValue) && _.isFunction(objValue)) {\n\t\t\treturn function (...args: any[]) {\n\t\t\t\tobjValue(...args);\n\t\t\t\treturn srcValue(...args);\n\t\t\t};\n\t\t}\n\n\t\treturn safeMerge(objValue, srcValue);\n\t};\n\n\tconst bindFunctionOverwritesCustomizer = (\n\t\tobjValue: { (...args: any[]): any; path: string[] },\n\t\tsrcValue: any\n\t) => {\n\t\tif (_.isFunction(srcValue) && _.isFunction(objValue)) {\n\t\t\treturn bindReducerToState(\n\t\t\t\tsrcValue,\n\t\t\t\t{ getState, setState },\n\t\t\t\tobjValue.path\n\t\t\t);\n\t\t}\n\n\t\treturn safeMerge(objValue, srcValue);\n\t};\n\n\treturn {\n\t\tgetPropReplaceReducers(props: P) {\n\t\t\treturn _.mergeWith(\n\t\t\t\t{},\n\t\t\t\tboundReducers,\n\t\t\t\tgetState(),\n\t\t\t\tprops,\n\t\t\t\tbindFunctionOverwritesCustomizer\n\t\t\t);\n\t\t},\n\t\tgetProps(props: P) {\n\t\t\treturn _.mergeWith(\n\t\t\t\t{},\n\t\t\t\tboundReducers,\n\t\t\t\tgetState(),\n\t\t\t\tprops,\n\t\t\t\tcombineFunctionsCustomizer\n\t\t\t);\n\t\t},\n\t};\n}\n\n/**\n * reduceSelectors\n *\n * Generates a root selector from a tree of selectors\n * @param {Object} selectors - a tree of selectors\n * @returns {function} root selector that when called with state, calls each of\n * the selectors in the tree with the state local to that selector.\n *\n * This function is memoized because it's recursive, and we want it to reuse\n * the functions created in the recursive reduce because those functions are\n * also memoized (reselect selectors are memoized with a cache of 1) and we want\n * to maintain their caches.\n *\n * TODO: the types suck on this function but we spent a couple hours trying to\n * get them to work and we couldn't figure out how to get generics to pass\n * through _.memoize correctly. ¯\\_(ツ)_/¯\n */\nexport const reduceSelectors: any = _.memoize((selectors: object) => {\n\tif (!isPlainObjectOrEsModule(selectors)) {\n\t\tthrow new Error(\n\t\t\t'Selectors must be a plain object with function or plain object values'\n\t\t);\n\t}\n\n\t/**\n\t * For each iteration of `reduceSelectors`, we return a memoized selector so\n\t * that individual branches maintain reference equality if they haven't been\n\t * modified, even if a sibling (and therefore the parent) has been modified.\n\t */\n\treturn createSelector(_.identity as any, (state: { [k: string]: any }) =>\n\t\t_.reduce(\n\t\t\tselectors,\n\t\t\t(acc: object, selector: any, key: string) => ({\n\t\t\t\t...acc,\n\t\t\t\t[key]: _.isFunction(selector)\n\t\t\t\t\t? selector(state)\n\t\t\t\t\t: reduceSelectors(selector)(state[key]),\n\t\t\t}),\n\t\t\tstate\n\t\t)\n\t);\n});\n\nexport function safeMerge(objValue: any, srcValue: any) {\n\t// don't merge arrays\n\tif (_.isArray(srcValue) && _.isArray(objValue)) {\n\t\treturn srcValue;\n\t}\n\n\t// guards against traversing react elements which can cause cyclical recursion\n\t// If we don't have this clause, lodash (as of 4.7.0) will attempt to\n\t// deeply clone the react children, which is really freaking slow.\n\tif (\n\t\tisValidElement(srcValue) ||\n\t\t(_.isArray(srcValue) && _.some(srcValue, isValidElement)) ||\n\t\t(_.isArray(srcValue) && _.isUndefined(objValue))\n\t) {\n\t\treturn srcValue;\n\t}\n}\n\nexport function buildHybridComponent(\n\tbaseComponent: any,\n\t{\n\t\treplaceEvents = false, // if true, function props replace the existing reducers, else they are invoked *after* state reducer returns\n\t\treducers = _.get(baseComponent, 'definition.statics.reducers', {}),\n\t\tselectors = _.get(baseComponent, 'definition.statics.selectors', {}),\n\t} = {}\n) {\n\tconst {\n\t\t_isLucidHybridComponent,\n\t\tdisplayName,\n\t\tpropTypes,\n\t\tdefinition: { statics = {} } = {},\n\t\tdefaultProps,\n\t} = baseComponent;\n\n\tif (_isLucidHybridComponent) {\n\t\tlogger.warnOnce(\n\t\t\tdisplayName,\n\t\t\t`Lucid: you are trying to apply buildHybridComponent to ${displayName}, which is already a hybrid component. Lucid exports hybrid components by default. To access the dumb components, use the -Dumb suffix, e.g. \"ComponentDumb\"`\n\t\t);\n\n\t\treturn baseComponent;\n\t}\n\n\tconst selector = reduceSelectors(selectors);\n\n\treturn createClass({\n\t\tpropTypes,\n\t\tstatics: {\n\t\t\t_isLucidHybridComponent: true,\n\t\t\tpeekDefaultProps: defaultProps,\n\t\t\t...statics,\n\t\t},\n\t\tdisplayName,\n\t\tgetInitialState() {\n\t\t\tconst { initialState } = this.props; //initial state overrides\n\t\t\treturn _.mergeWith(\n\t\t\t\t{},\n\t\t\t\tomitFunctionPropsDeep(baseComponent.defaultProps),\n\t\t\t\tinitialState,\n\t\t\t\tsafeMerge\n\t\t\t);\n\t\t},\n\t\tUNSAFE_componentWillMount() {\n\t\t\tlet synchronousState = this.state; //store reference to state, use in place of `this.state` in `getState`\n\t\t\tthis.boundContext = getStatefulPropsContext(reducers, {\n\t\t\t\tgetState: () =>\n\t\t\t\t\t_.mergeWith(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tomitFunctionPropsDeep(synchronousState),\n\t\t\t\t\t\tomitFunctionPropsDeep(this.props),\n\t\t\t\t\t\tsafeMerge\n\t\t\t\t\t),\n\t\t\t\tsetState: (state) => {\n\t\t\t\t\tsynchronousState = state; //synchronously update the state reference\n\t\t\t\t\tthis.setState(state);\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\trender() {\n\t\t\tif (replaceEvents) {\n\t\t\t\treturn React.createElement(\n\t\t\t\t\tbaseComponent,\n\t\t\t\t\tselector(this.boundContext.getPropReplaceReducers(this.props)),\n\t\t\t\t\tthis.props.children\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn React.createElement(\n\t\t\t\tbaseComponent,\n\t\t\t\tselector(this.boundContext.getProps(this.props)),\n\t\t\t\tthis.props.children\n\t\t\t);\n\t\t},\n\t});\n}\n\nexport interface IHybridComponent<P, S extends object> {\n\treducers: Reducers<P, S>;\n\tselectors: Selectors<P, S>;\n\tpeekDefaultProps: { [key: string]: any }; // not sure how to give this a better type\n}\n\nexport function buildModernHybridComponent<\n\tP extends object = {},\n\tS extends object = {},\n\tBaseType extends object = {}\n>(\n\tBaseComponent: React.ComponentType<P>,\n\t{\n\t\treplaceEvents = false,\n\t\treducers = {},\n\t\tselectors = {},\n\t}: IBuildHybridComponentOptions<P, S>\n) {\n\t// TODO: make sure hybrid components don't get double wrapped. Maybe use a type guard?\n\n\ttype AugmentedProps = P & { initialState?: P & S };\n\n\tconst selector = reduceSelectors(selectors);\n\n\tclass HybridComponent extends React.Component<AugmentedProps, S> {\n\t\tprivate boundContext?: IBoundContext<P, S>;\n\n\t\t// It would be nice to prepend \"Hybrid\" to this but some of our component\n\t\t// sadly rely on the displayName remaining unchanged. E.g. `VerticalListMenu`.\n\t\tstatic displayName = BaseComponent.displayName;\n\n\t\tstatic propTypes = BaseComponent.propTypes;\n\t\tstatic reducers = reducers;\n\t\tstatic selectors = selectors;\n\t\tstatic peekDefaultProps = BaseComponent.defaultProps;\n\n\t\t// Note: we purposefully *do not* set defaultProps here as that would\n\t\t// effectively eliminate our ability to distinguish what props the user\n\t\t// explicity included.\n\n\t\tconstructor(props: AugmentedProps) {\n\t\t\tsuper(props);\n\n\t\t\tconst { initialState } = props; // initial state overrides\n\n\t\t\tthis.state = _.mergeWith(\n\t\t\t\t{},\n\t\t\t\tomitFunctionPropsDeep(BaseComponent.defaultProps),\n\t\t\t\tinitialState,\n\t\t\t\tsafeMerge\n\t\t\t);\n\t\t}\n\n\t\tUNSAFE_componentWillMount() {\n\t\t\t// store reference to state, use in place of `this.state` in `getState`\n\t\t\tlet synchronousState: S = this.state;\n\n\t\t\tthis.boundContext = getStatefulPropsContext<P, S>(reducers, {\n\t\t\t\tgetState: () =>\n\t\t\t\t\t_.mergeWith(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tomitFunctionPropsDeep(synchronousState),\n\t\t\t\t\t\tomitFunctionPropsDeep(this.props),\n\t\t\t\t\t\tsafeMerge\n\t\t\t\t\t) as S,\n\t\t\t\tsetState: (state) => {\n\t\t\t\t\tsynchronousState = state; //synchronously update the state reference\n\t\t\t\t\tthis.setState(state);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\trender() {\n\t\t\tif (this.boundContext === undefined) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (replaceEvents) {\n\t\t\t\treturn React.createElement(\n\t\t\t\t\tBaseComponent,\n\t\t\t\t\tselector(this.boundContext.getPropReplaceReducers(this.props)),\n\t\t\t\t\tthis.props.children\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn React.createElement(\n\t\t\t\tBaseComponent,\n\t\t\t\tselector(this.boundContext.getProps(this.props)),\n\t\t\t\tthis.props.children\n\t\t\t);\n\t\t}\n\t}\n\n\t// I used a type cast and intersection with `BaseType` here because I\n\t// couldn't figure out any other way to generate a valid type signuture to\n\t// reflected all the statics on the unerlying base component. @jondlm 2019-11-27\n\t// @ts-ignore\n\treturn hoistNonReactStatics(HybridComponent, BaseComponent) as BaseType &\n\t\tIHybridComponent<P, S>;\n}\n\n/*\nexport function buildStatefulComponent(...args: any[]) {\n\tlogger.warnOnce(\n\t\t'buildHybridComponent-once',\n\t\t'Lucid: buildStatefulComponent has been renamed to buildHybridComponent.'\n\t);\n\n\t// We don't really care about type checking our legacy buildHybridComponent\n\t// @ts-ignore\n\treturn buildHybridComponent(...args);\n}\n\t */\n"]},"metadata":{},"sourceType":"module"}