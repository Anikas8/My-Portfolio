{"ast":null,"code":"import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Shape from 'd3-shape';\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { groupByFields } from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\nimport Line from '../Line/Line';\nconst cx = lucidClassNames.bind('&-Lines');\nconst {\n  arrayOf,\n  func,\n  number,\n  object,\n  bool,\n  string\n} = PropTypes;\nconst isUniform = array => _.every(array, val => val === _.first(array));\nconst defaultProps = {\n  xField: 'x',\n  yFields: ['y'],\n  isStacked: false,\n  colorOffset: 0,\n  palette: chartConstants.PALETTE_7\n};\nexport const Lines = props => {\n  const {\n    className,\n    data,\n    isStacked,\n    palette,\n    colorMap,\n    colorOffset,\n    xScale,\n    xField,\n    yFields,\n    yScale: yScaleOriginal,\n    yStackedMax,\n    ...passThroughs\n  } = props;\n  // Copy the original so we can mutate it\n  const yScale = yScaleOriginal.copy();\n  // If we are stacked, we need to calculate a new domain based on the sum of\n  // the various series' y data. One row per series.\n  const transformedData = isStacked ? d3Shape.stack().keys(yFields)(data) : groupByFields(data, yFields);\n  const stackedArea = d3Shape.area().defined(a => _.isFinite(a[0]) && _.isFinite(a[1])).x((a, i) => xScale(data[i][xField])).y0(a => yScale(a[1])).y1(a => yScale(a[0]));\n  const area = d3Shape.area().defined(a => _.isFinite(a) || _.isDate(a)).x((a, i) => xScale(data[i][xField])).y((a, i) => yScale(a));\n  // If we are stacked, we need to calculate a new domain based on the sum of\n  // the various group's y data\n  if (isStacked) {\n    yScale.domain([yScale.domain()[0], yStackedMax || _.max(_.flatten(_.last(transformedData)))]);\n  }\n  return React.createElement(\"g\", {\n    ...passThroughs,\n    className: cx(className, '&')\n  }, _.map(transformedData, (d, dIndex) => React.createElement(\"g\", {\n    key: dIndex\n  }, React.createElement(Line, {\n    color: _.get(colorMap, yFields[dIndex], palette[(dIndex + colorOffset) % palette.length]),\n    d: isStacked ? stackedArea(d) : area(d),\n    // Fixes a bug in chrome by forcing a reflow of the element (ANXR-1405)\n    style: isUniform(d) ? {\n      transform: 'scaleX(0.999)'\n    } : undefined\n  }))));\n};\nLines.defaultProps = defaultProps;\nLines.displayName = 'Lines';\nLines.peek = {\n  description: `*For use within an \\`svg\\`*. A \\`Line\\` is typically used to represent continuous data and can be stacked.`,\n  categories: ['visualizations', 'chart primitives'],\n  madeFrom: ['Line']\n};\nLines.propTypes = {\n  /**\n      Appended to the component-specific class names set on the root element.\n  */\n  className: string,\n  /**\n      Top\n  */\n  top: number,\n  /**\n      Left\n  */\n  left: number,\n  /**\n      Takes one of the palettes exported from \\`lucid.chartConstants\\`.\n      Available palettes:\n       - \\`PALETTE_7\\` (default)\n      - \\`PALETTE_30\\`\n      - \\`PALETTE_MONOCHROME_0_5\\`\n      - \\`PALETTE_MONOCHROME_1_5\\`\n      - \\`PALETTE_MONOCHROME_2_5\\`\n      - \\`PALETTE_MONOCHROME_3_5\\`\n      - \\`PALETTE_MONOCHROME_4_5\\`\n      - \\`PALETTE_MONOCHROME_5_5\\`\n      - \\`PALETTE_MONOCHROME_6_5\\`\n  */\n  palette: arrayOf(string),\n  /**\n      You can pass in an object if you want to map fields to\n      \\`lucid.chartConstants\\` or custom colors:\n           {\n              'imps': COLOR_0,\n              'rev': COLOR_3,\n              'clicks': '#abc123',\n          }\n  */\n  colorMap: object,\n  /**\n      De-normalized data, e.g.\n           [\n              { x: 'one'   , y: 1 },\n              { x: 'two'   , y: 2 },\n              { x: 'three' , y: 2 },\n              { x: 'four'  , y: 3 },\n              { x: 'five'  , y: 4 },\n          ]\n        Or (be sure to set \\`yFields\\` to \\`['y0', 'y1', 'y2', 'y3']\\`)\n           [\n              { x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },\n              { x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },\n              { x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },\n              { x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },\n              { x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },\n              { x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },\n          ]\n  */\n  data: arrayOf(object).isRequired,\n  /**\n      The scale for the x axis. Must be a d3 scale. Lucid exposes the\n      \\`lucid.d3Scale\\` library for use here.\n  */\n  xScale: func.isRequired,\n  /**\n      The scale for the y axis. Must be a d3 scale. Lucid exposes the\n      \\`lucid.d3Scale\\` library for use here.\n  */\n  yScale: func.isRequired,\n  /**\n      Typically this number can be derived from the yScale. However when we're\n      \\`isStacked\\` we need to calculate a new domain for the yScale based on\n      the sum of the data. If you need explicit control of the y max when\n      stacking, pass it in here.\n  */\n  yStackedMax: number,\n  /**\n      The field we should look up your x data by.\n  */\n  xField: string,\n  /**\n      The field(s) we should look up your y data by. Each entry represents a\n      series. Your actual y data should be numeric.\n  */\n  yFields: arrayOf(string),\n  /**\n      This will stack the data instead of grouping it. In order to stack the\n      data we have to calculate a new domain for the y scale that is based on\n      the \\`sum\\` of the data.\n  */\n  isStacked: bool,\n  /**\n      Sometimes you might not want the colors to start rotating at the blue\n      color, this number will be added the line index in determining which\n      color the lines are.\n  */\n  colorOffset: number\n};\nexport default Lines;","map":{"version":3,"mappings":"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","names":["_","React","PropTypes","d3Shape","lucidClassNames","groupByFields","chartConstants","Line","cx","bind","arrayOf","func","number","object","bool","string","isUniform","array","every","val","first","defaultProps","xField","yFields","isStacked","colorOffset","palette","PALETTE_7","Lines","props","className","data","colorMap","xScale","yScale","yScaleOriginal","yStackedMax","passThroughs","copy","transformedData","stack","keys","stackedArea","area","defined","a","isFinite","x","i","y0","y1","isDate","y","domain","max","flatten","last","map","d","dIndex","key","color","get","length","style","transform","undefined","displayName","peek","description","categories","madeFrom","propTypes","top","left","isRequired"],"sources":["/home/skanda/node_modules/lucid-ui/src/components/Lines/Lines.tsx"],"sourcesContent":["import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as d3Shape from 'd3-shape';\nimport * as d3Scale from 'd3-scale';\n\nimport { lucidClassNames } from '../../util/style-helpers';\nimport { StandardProps } from '../../util/component-types';\nimport { groupByFields } from '../../util/chart-helpers';\nimport * as chartConstants from '../../constants/charts';\nimport Line from '../Line/Line';\n\nconst cx = lucidClassNames.bind('&-Lines');\n\nconst { arrayOf, func, number, object, bool, string } = PropTypes;\n\nconst isUniform = (array: any[]): boolean =>\n\t_.every(array, (val): boolean => val === _.first(array));\n\nexport interface ILinesProps\n\textends StandardProps,\n\t\tReact.SVGProps<SVGGElement> {\n\t/** Top */\n\ttop?: number;\n\n\t/** Left */\n\tleft?: number;\n\n\t/** \tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\tAvailable palettes:\n\n\t- \\`PALETTE_7\\` (default)\n\t- \\`PALETTE_30\\`\n\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t- \\`PALETTE_MONOCHROME_6_5\\` */\n\tpalette: string[];\n\n\t/** You can pass in an object if you want to map fields to\n\t\\`lucid.chartConstants\\` or custom colors:\n\n\t\t{\n\t\t\t'imps': COLOR_0,\n\t\t\t'rev': COLOR_3,\n\t\t\t'clicks': '#abc123',\n\t\t} */\n\tcolorMap?: object;\n\n\t/** De-normalized data, e.g.\n\n\t\t[\n\t\t\t{ x: 'one'   , y: 1 },\n\t\t\t{ x: 'two'   , y: 2 },\n\t\t\t{ x: 'three' , y: 2 },\n\t\t\t{ x: 'four'  , y: 3 },\n\t\t\t{ x: 'five'  , y: 4 },\n\t\t]\n\n\tOr (be sure to set \\`yFields\\` to \\`['y0', 'y1', 'y2', 'y3']\\`)\n\n\t\t[\n\t\t\t{ x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },\n\t\t\t{ x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },\n\t\t\t{ x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },\n\t\t\t{ x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },\n\t\t\t{ x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },\n\t\t\t{ x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },\n\t\t] */\n\n\tdata: Array<{ [key: string]: any }>;\n\n\t//TODO: xScale can support several different types of scales, maybe all types; we need to enumerate what it acccepts and encode it into the type\n\t// Having a number | string union type gets converted by TypeScript to ReactText; It may be related to the LibraryManagedAttributes\n\t/** The scale for the x axis. Must be a d3 scale. Lucid exposes the\n\t\t`lucid.d3Scale` library for use here. */\n\txScale:\n\t\t| d3Scale.ScaleBand<string>\n\t\t| d3Scale.ScalePoint<string>\n\t\t| d3Scale.ScaleTime<number, number>;\n\n\t/** The scale for the y axis. Must be a d3 scale. Lucid exposes the\n\t\t`lucid.d3Scale` library for use here. */\n\tyScale:\n\t\t| d3Scale.ScaleContinuousNumeric<number, number>\n\t\t| d3Scale.ScaleBand<number>\n\t\t| d3Scale.ScalePoint<number>\n\t\t| d3Scale.ScaleLinear<number, number>;\n\n\t/** Typically this number can be derived from the yScale. However when we're\n\t\t\\`isStacked\\` we need to calculate a new domain for the yScale based on\n\t\tthe sum of the data. If you need explicit control of the y max when\n\t\tstacking, pass it in here. */\n\tyStackedMax?: number | object;\n\n\t/** The field we should look up your x data by. */\n\txField: string;\n\n\t/** The field(s) we should look up your y data by. Each entry represents a\n\t\tseries. Your actual y data should be numeric. */\n\tyFields: string[];\n\n\t/** This will stack the data instead of grouping it. In order to stack the\n\t\tdata we have to calculate a new domain for the y scale that is based on\n\t\tthe \\`sum\\` of the data. */\n\tisStacked: boolean;\n\n\t/** Sometimes you might not want the colors to start rotating at the blue\n\t\tcolor, this number will be added the line index in determining which\n\t\tcolor the lines are. */\n\tcolorOffset: number;\n}\n\nconst defaultProps = {\n\txField: 'x',\n\tyFields: ['y'],\n\tisStacked: false,\n\tcolorOffset: 0,\n\tpalette: chartConstants.PALETTE_7,\n};\n\nexport const Lines = (props: ILinesProps): React.ReactElement => {\n\tconst {\n\t\tclassName,\n\t\tdata,\n\t\tisStacked,\n\t\tpalette,\n\t\tcolorMap,\n\t\tcolorOffset,\n\t\txScale,\n\t\txField,\n\t\tyFields,\n\t\tyScale: yScaleOriginal,\n\t\tyStackedMax,\n\t\t...passThroughs\n\t} = props;\n\n\t// Copy the original so we can mutate it\n\tconst yScale = yScaleOriginal.copy();\n\n\t// If we are stacked, we need to calculate a new domain based on the sum of\n\t// the various series' y data. One row per series.\n\tconst transformedData = isStacked\n\t\t? d3Shape.stack().keys(yFields)(data as Array<{ [key: string]: number }>)\n\t\t: groupByFields(data, yFields);\n\n\tconst stackedArea = d3Shape\n\t\t.area<[number, number]>()\n\t\t.defined((a): boolean => _.isFinite(a[0]) && _.isFinite(a[1]))\n\t\t.x((a, i): number => xScale(data[i][xField]) as number)\n\t\t.y0((a): number => yScale(a[1]) as number)\n\t\t.y1((a): number => yScale(a[0]) as number);\n\n\tconst area = d3Shape\n\t\t.area<number>()\n\t\t.defined((a): boolean => _.isFinite(a) || _.isDate(a))\n\t\t.x((a, i): number => xScale(data[i][xField]) as number)\n\t\t.y((a, i): number => yScale(a) as number);\n\n\t// If we are stacked, we need to calculate a new domain based on the sum of\n\t// the various group's y data\n\tif (isStacked) {\n\t\tyScale.domain([\n\t\t\tyScale.domain()[0], // only stacks well if this is `0`\n\t\t\tyStackedMax || _.max(_.flatten(_.last(transformedData))),\n\t\t]);\n\t}\n\n\treturn (\n\t\t<g {...passThroughs} className={cx(className, '&')}>\n\t\t\t{_.map(\n\t\t\t\ttransformedData,\n\t\t\t\t(d, dIndex): React.ReactElement => (\n\t\t\t\t\t<g key={dIndex}>\n\t\t\t\t\t\t<Line\n\t\t\t\t\t\t\tcolor={_.get(\n\t\t\t\t\t\t\t\tcolorMap,\n\t\t\t\t\t\t\t\tyFields[dIndex],\n\t\t\t\t\t\t\t\tpalette[(dIndex + colorOffset) % palette.length]\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\td={(isStacked ? stackedArea(d) : area(d)) as string}\n\t\t\t\t\t\t\t// Fixes a bug in chrome by forcing a reflow of the element (ANXR-1405)\n\t\t\t\t\t\t\tstyle={isUniform(d) ? { transform: 'scaleX(0.999)' } : undefined}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t)\n\t\t\t)}\n\t\t</g>\n\t);\n};\n\nLines.defaultProps = defaultProps;\nLines.displayName = 'Lines';\nLines.peek = {\n\tdescription: `*For use within an \\`svg\\`*. A \\`Line\\` is typically used to represent continuous data and can be stacked.`,\n\tcategories: ['visualizations', 'chart primitives'],\n\tmadeFrom: ['Line'],\n};\nLines.propTypes = {\n\t/**\n\t\tAppended to the component-specific class names set on the root element.\n\t*/\n\tclassName: string,\n\n\t/**\n\t\tTop\n\t*/\n\ttop: number,\n\n\t/**\n\t\tLeft\n\t*/\n\tleft: number,\n\n\t/**\n\t\tTakes one of the palettes exported from \\`lucid.chartConstants\\`.\n\t\tAvailable palettes:\n\n\t\t- \\`PALETTE_7\\` (default)\n\t\t- \\`PALETTE_30\\`\n\t\t- \\`PALETTE_MONOCHROME_0_5\\`\n\t\t- \\`PALETTE_MONOCHROME_1_5\\`\n\t\t- \\`PALETTE_MONOCHROME_2_5\\`\n\t\t- \\`PALETTE_MONOCHROME_3_5\\`\n\t\t- \\`PALETTE_MONOCHROME_4_5\\`\n\t\t- \\`PALETTE_MONOCHROME_5_5\\`\n\t\t- \\`PALETTE_MONOCHROME_6_5\\`\n\t*/\n\tpalette: arrayOf(string),\n\n\t/**\n\t\tYou can pass in an object if you want to map fields to\n\t\t\\`lucid.chartConstants\\` or custom colors:\n\n\t\t\t{\n\t\t\t\t'imps': COLOR_0,\n\t\t\t\t'rev': COLOR_3,\n\t\t\t\t'clicks': '#abc123',\n\t\t\t}\n\t*/\n\tcolorMap: object,\n\n\t/**\n\t\tDe-normalized data, e.g.\n\n\t\t\t[\n\t\t\t\t{ x: 'one'   , y: 1 },\n\t\t\t\t{ x: 'two'   , y: 2 },\n\t\t\t\t{ x: 'three' , y: 2 },\n\t\t\t\t{ x: 'four'  , y: 3 },\n\t\t\t\t{ x: 'five'  , y: 4 },\n\t\t\t]\n\n\n\t\tOr (be sure to set \\`yFields\\` to \\`['y0', 'y1', 'y2', 'y3']\\`)\n\n\t\t\t[\n\t\t\t\t{ x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },\n\t\t\t\t{ x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },\n\t\t\t\t{ x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },\n\t\t\t\t{ x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },\n\t\t\t\t{ x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },\n\t\t\t\t{ x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },\n\t\t\t]\n\t*/\n\tdata: arrayOf(object).isRequired,\n\n\t/**\n\t\tThe scale for the x axis. Must be a d3 scale. Lucid exposes the\n\t\t\\`lucid.d3Scale\\` library for use here.\n\t*/\n\txScale: func.isRequired,\n\n\t/**\n\t\tThe scale for the y axis. Must be a d3 scale. Lucid exposes the\n\t\t\\`lucid.d3Scale\\` library for use here.\n\t*/\n\tyScale: func.isRequired,\n\n\t/**\n\t\tTypically this number can be derived from the yScale. However when we're\n\t\t\\`isStacked\\` we need to calculate a new domain for the yScale based on\n\t\tthe sum of the data. If you need explicit control of the y max when\n\t\tstacking, pass it in here.\n\t*/\n\tyStackedMax: number,\n\n\t/**\n\t\tThe field we should look up your x data by.\n\t*/\n\txField: string,\n\n\t/**\n\t\tThe field(s) we should look up your y data by. Each entry represents a\n\t\tseries. Your actual y data should be numeric.\n\t*/\n\tyFields: arrayOf(string),\n\n\t/**\n\t\tThis will stack the data instead of grouping it. In order to stack the\n\t\tdata we have to calculate a new domain for the y scale that is based on\n\t\tthe \\`sum\\` of the data.\n\t*/\n\tisStacked: bool,\n\n\t/**\n\t\tSometimes you might not want the colors to start rotating at the blue\n\t\tcolor, this number will be added the line index in determining which\n\t\tcolor the lines are.\n\t*/\n\tcolorOffset: number,\n};\n\nexport default Lines;\n"]},"metadata":{},"sourceType":"module"}